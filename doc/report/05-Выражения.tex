\hypertarget{expressions}{%
\section{Выражения}\label{expr:chapter}}

Выражение определяет вычисление значения путем применения операций к операндам. 

\begin{Grammar}
Выражение
    : Унарное-выражение
    | Проверка-типа
    | Выражение Бинарная-операция Выражение

Унарное-выражение
    : Первичное-выражение
    | Унарная-операция Унарное-выражение
    
Проверка-типа: Выражение 'типа' Указ-типа 
\end{Grammar}    

\hypertarget{primary-expr}{%
\subsection{Первичные выражения}\label{expr:primary-expr}}

Первичные выражения - это выражения, которые являются операндами унарных (\See{expr:unary-ops}) и бинарных (\See{expr:binary-ops}) операций .

\begin{Grammar}
Первичное-выражение
    : Операнд
    ( Доступ
    | Индексация
    | Преобразование
    | Вызов
    | Конструктор-вектора
    | Конструктор-класса
    | Подтверждение-типа
    )*
\end{Grammar}    

\begin{Trivil}
1
к.поле
а[№]
Факториал(5)
А[1, 2, 3]
К{имя: "Вася", возраст: 23}
а^
объект.вектор[номер].метод()
\end{Trivil}

\hypertarget{operands}{%
\subsection{Операнды}\label{expr:operands}}

Операнды - это элементарные значения в выражении. Операнд может быть литералом, именем объекта, 
обозначающим константу, переменную или функцию, или выражением в скобках.

\begin{Grammar}
Операнд: Литерал | Имя-объекта | '(' Выражение ')'
Литерал
    : Целочисленный-литерал
    | Вещественный-литерал
    | Строковый-литерал
    | Символьный-литерал
Имя-объекта: Идентификатор | Импорт-идент
Импорт-идент: Идентификатор '.' Идентификатор
\end{Grammar}    

Если в качестве имени объекта используется \emph{Импорт-идент}, то первый идентификатор в нем должен обозначать имя импортированного модуля (\See{mods:import}), а второй идентификатор должен быть идентификатором экспортированного из этого модуля объекта.

\smallskip
\begin{tabular}[c]{l|l}
\textbf{Операнд} & \textbf{Тип выражения} \\ \hline
Имя объекта & тип объекта \\
Целочисленный-литерал & Цел64 \\
Вещественный-литерал & Вещ64 \\ 
Строковый-литерал & Строка \\ 
Символьный-литерал & Символ \\
Выражение в скобках & тип выражения \\
\end{tabular}

\hypertarget{selector}{%
\subsection{Доступ к полям и методам}\label{expr:selector}}

Доступ применяется к первичному выражению.

\begin{Grammar}
Доступ: '.' Идентификатор
\end{Grammar}    

В выражении \verb|что-то.имя|:
\begin{d_itemize}
\item
    \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип класса. 
\item
    а \verb|имя| должно быть идентификатором поля или метода типа \emph{Т} или базового класса \emph{Т}
\end{d_itemize}

Типом выражения доступа является тип поля или метода.

\begin{Trivil}
чел.возраст := 5

если чел.возраст < 18 { ... }
\end{Trivil}

\hypertarget{indexation}{%
\subsection{Индексация}\label{expr:indexation}}

Индексация применяется к первичному выражению.

\begin{Grammar}
Индексация: '[' Выражение '['
\end{Grammar}    

Выражение \verb|что-то[индекс]| обозначает элемент вектора или вариативного параметра, индекс которого определяется выражением \verb|индекс|.
\begin{d_itemize}
\item
    \verb|что-то| должно быть идентификатором, обозначающим вариативный параметр
\item
    или \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип вектора
\item
    \verb|индекс| должен быть выражением типа \verb|Цел64| или \verb|Байт|
\end{d_itemize}

Если во время исполнения индекс выходит за границы вектора или параметра (индекс < 0 | индекс >= длина), происходит \emph{авария} (\See{stmt:crash-stmt}).

Типом выражения индексации является тип элемента вектора, если индексируется вектор или тип вариативного параметра, если индексируется вариативный параметр.

Так как индексация и конструктор вектора (\See{expr:vector-composite}) не всегда различимы синтаксически, выбор между ними происходит на уровне семантики, 
если выражение \verb|что-то|  обозначает тип, то это конструктор вектора, иначе индексация.

\hypertarget{conversion}{%
\subsection{Преобразование типа}\label{expr:conversion}}

Преобразование типа применяется к первичному выражению, и преобразует, если это возможно, значение выражения к \emph{целевому типу}, указанному в операции преобразования.

\begin{Grammar}
Преобразование: '(:' 'осторожно'? Указ-типа ')'
\end{Grammar}   

Если в преобразование есть ключевое слово \keyword{осторожно}, то это небезопасная операция, которая рассматривается отдельно (\See{unsafe:conversions}).

Часть преобразований, например, преобразования между числовыми типами и символами, а так же строковые преобразования могут изменить 
представление значения первичного выражения и повлечь за собой затраты на выполнение.

Преобразование может привести к \emph{аварийному завершению}, если условие преобразования не выполнено, см. столбец \textbf{Условие выполнения} в таблице. Если в столбце  указано 'нет условия', то преобразование не может привести к \emph{аварийному завершению}.

\bigskip
Разрешенные преобразования:
\smallskip

\begin{tabular}[c]{p{2cm}|p{5cm}|p{6cm}}
\textbf{Целевой тип} & \textbf{Тип выражения} &  \textbf{Условие выполнения} \\ 
\hline
Байт & Цел64, Слово64, Символ, Строковый литерал длины 1 & значение в диапазоне 0..255 \\
\hline
Цел64 & Байт, Символ, Строковый литерал длины 1 & нет условия \\ 
\hline
Цел64 & Слово64 & значение в диапазоне 0..Max(Цел64) \\
\hline
Цел64 & Вещ64  & нет условия \\
\hline
Слово64 & Байт, Символ, Строковый литерал длины 1 & нет условия \\
\hline
Слово64 & Цел64 & не отрицательное значение \\
\hline
Вещ64 & Цел64 & нет условия \\
\hline
Символ &  Байт, Строковый литерал длины 1 & нет условия \\
\hline
Символ & Цел64, Слово64 & значение в диапазоне, разрешенном для Unicode символа \\
\hline
Строка & Символ, \verb+[]+Символ, \verb+[]+Байт & нет условия \\
\hline
\verb+[]+Байт & Строка, Символ  & нет условия \\
\hline
\verb+[]+Символ & Строка  & всегда \\
\hline
Класс Ц & Класс К & К является базовым классом класса Ц \\
\hline
Класс Ц & \keyword{мб} К, где К - класс & значение не равно пусто, и К является базовым классом класса Ц \\
\hline
произвольный тип \emph{Т} & полиморфный тип (*) & полиморфное значение содержит значение типа \emph{Т} \\
\hline
\end{tabular}

\bigskip
Преобразование к типу класса изменяет только тип (статический тип объекта), но не представление значения.

\begin{Trivil}
тип Байты = []Байт
пусть байты = "Привет"(:Байты)

пусть три = pi(:Цел64)

фн хочу целое(п: *) {
    пусть к = п(:Цел64)
}
\end{Trivil}

\hypertarget{call}{%
\subsection{Вызов функции или метода}\label{expr:call}}

Вызов применяется к первичному выражению. Это выражение
\begin{d_itemize}
\item
    является идентификатором стандартной функции (\See{stdfuncs:std-funcs})
\item
    или обозначает функцию, тогда это \emph{вызов функции}
\item
    или явлется выражением типа класс, тогда это \emph{вызов метода}
\end{d_itemize}

\begin{Grammar}
Вызов: '(' Список-аргументов? ')'
Список-аргументов: Аргумент (',' Аргумент)* ','?
Аргумент: Выражение '...'?
\end{Grammar}   

В вызове указывается список аргументов. Число аргументов в списке должно быть равно числу параметров в сигнатуре функции или метода, за исключение случая, 
когда в сигнатуре есть вариативный параметр. Для вариативного параметра число аргументов может быть от нуля и более.

Каждый аргумент в вызове является \emph{выражением}. 
Если для вариативного параметра задан единственный аргумент, то после выражения может стоять знак операции \verb+...+, делающий  \emph{развернутое выражение} (\See{expr:call-unfold}).

Для всех других аргументов, выражение должно быть \emph{совместимо по присваиванию} с типом параметра (\See{compat:assign}).

Типом выражения вызова является тип результата. Если в сигнатуре функции или метода тип результата отсутствует, то вызов не может быть операндом для любой операции.

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 { /*тело*/ }

пусть рез = Факториал(5)
\end{Trivil}

\hypertarget{call-unfold}{%
\subsubsection{Развернутое выражение}\label{expr:call-unfold}}

\emph{Развернутое выражение} может быть использовано только как аргумент для вариативного параметра и только, если это единственный аргумент для этого параметра. 
Если развернутое выражение \emph{х}\verb+...+ используется как аргумент для параметра \verb+п: ...Т+, то должно выполняется одно из условий:
\begin{d_itemize}
\item
    \emph{х} является вариативным параметром того же типа \verb+Т+
\item
    \emph{х} - это выражение типа вектора, причем тип вектора определен, как \verb+[]Т+
\end{d_itemize}

Пример использования развернутого вектора в качестве аргумента вариативного параметра:
\begin{Trivil}[vspace=2pt]
фн Соединить(список: ...Строка) {/*тело*/}

тип Строки = []Строка

фн Сохранить(строки: Строки) {
   пусть текст = Соединить(строки...)
   /* сохранение текста */
}
\end{Trivil}

\hypertarget{vector-composite}{%
\subsection{Конструктор вектора}\label{expr:vector-composite}}

Конструктор вектора применяется к первичному выражению, которое должно обозначать тип вектора. Результатом выполнения конструктора является вектор.

\begin{Grammar}
Конструктор-вектора: '[' (Значения | Элементы)? ']' 
Значения: Значение (',' Значение)* ','?
Значение: Выражение
Элементы:  Элемент (',' Элемент)* ','?
Элемент: 
    ('длина' | 'выделить' | '*' | Индекс) ':' Выражение
Индекс: Выражение
\end{Grammar}   

Простой конструктор вектора задает последовательность выражений, каждое из которых должно быть \emph{совместимым по присваиванию} с типом элемента вектора (\See{compat:assign}). Первое выражение в последовательности определяет значение элемента вектора с индексом 0, и так далее. Если ни одного значения не задано, то длина вектора равно нулю.

\begin{Trivil}[vspace=2pt]
тип Числа = []Цел64

пусть ч = Число[] // вектор длины 0
пусть ч1 = Число[1, 2, 3] // вектор длины 3
\end{Trivil}

Пример использования конструктора вектора в вызове:
\begin{Trivil}[vspace=2pt]
тип Строки = []Строка
фн Сохранить(строки: Строки) { /*тело*/ }

Сохранить(Строки["привет", "мир"])
\end{Trivil}

Конструктор вектора может быть задан последовательностью \emph{Элементов}, где каждый элемент - это пара, разделенная двоеточием.
Если хотя бы один элемент задан парой, то все элементы конструктора должны быть также заданы парами.

\bigskip

Для \emph{Элемента} \verb+Х:выражение+:

\smallskip
\begin{tabular}[c]{r|p{8.5cm}}
\verb+X+ & \verb+выражение+ \\ 
\hline
\verb+длина+ &  задает длину конструируемого вектора \\
\hline
\verb+выделить+ & задает число элементов, выделяемых для конструируемого вектора \\
\hline
\verb+*+ & задает значение по умолчанию для всех элементов, для которых оно не задано явно \\
\hline
Индекс &  задает значение элемента с индексом \emph{Индекс} \\
\end{tabular}

\bigskip
Следующие условия должны выполняться для вектора, заданного \emph{Элементами}:
\begin{d_itemize}
\item
    выражение для \verb+длина+ должно быть \emph{совместимым по присваиванию} c типом \verb|Цел64|
\item
    выражение для \verb+выделить+ должно быть \emph{совместимым по присваиванию} c типом \verb|Цел64|. 
    Оно определяет число элементов, выделенных для вектора, но не обязательно использованных.
    Если значение для выделить меньше или равно длине, то оно игнорируется.
\item
    выражение для \verb+*+ должно быть \emph{совместимым по присваиванию} с типом элемента вектора (\See{compat:assign}) 
\item
    \emph{Индекс} должен быть выражением  \emph{совместимым по присваиванию} c типом \verb|Цел64|
\item
    \emph{Индекс} должен быть константным выражением (\See{expr:const-expr})
\item
    выражение для \emph{Индекса} должно быть \emph{совместимым по присваиванию} с типом элемента вектора (\See{compat:assign})
\item
    если длина вектора явно задана, то значение всех индексов должно быть в диапазоне [0..длина-1]. 
    Это ограничение проверяется во время компиляции, если длина задана константным выражением, иначе во время исполнения
\item
    если в конструкторе задаются значения не для всех индексов, задание значения по умолчанию является обязательным
\item
    повторное задание значения для элемента с одним индексом является ошибкой
\end{d_itemize}

Если длина конструируемого вектора не задана явно, то она равна максимальному индексу + 1.

\bigskip
Примеры конструкторов:
\begin{Trivil}[vspace=2pt]
тип Числа = []Цел64

пусть ч1 = Число[длина: 3, *: 0] 
// вектор [0, 0, 0]

пусть ч2 = Число[длина: 5, *:0, 1: 1, 3: 3] 
// вектор [0, 1, 0, 3, 0]

пусть ч3 = Число[*: 0, 1: 1, 3: 3]  
// [0, 1, 0, 3], длина - макс индекс + 1
\end{Trivil}

Пример ошибки - значение по умолчанию не задано:
\begin{SampleErr}[vspace=2pt]
пусть ч3 = Число[1: 1, 3: 3]  
\end{SampleErr}

Вектор является динамическим массивом, длина которого может изменяться во время выполнения. Конструктор вектора выделяет память под max(длина, выделить) элементов. 
Если к вектору добавляются элементы (см. \See{stdfuncs:vector-append}) и новое число элементов не превышает число выделенных, то выделения новой памяти не происходит. 

\begin{Trivil}
пусть ч1 = Число[выделить: 100] 
// вектор [], выделено место до 100 элементов
\end{Trivil}

\TBD: методы выделено, выделить

\hypertarget{class-composite}{%
\subsection{Конструктор экземпляра класса}\label{expr:class-composite}}

Конструктор вектора применяется к первичному выражению, которое должно обозначать тип класса. 
Результатом выполнения конструктора является экземпляр класса.

\begin{Grammar}
Конструктор-класса: '{' Список-значений? '}' 
Список-значений: Значение-поля (',' Значение-поля)* ','?
Значение-поля: Идентификатор ':' Значение
\end{Grammar}   

Для каждого \emph{Значения поля} идентификатор должен обозначать поле конструируемого класса. 
В результирующем экземпляре значением этого поля будет значение выражения \emph{Значение}.    
\emph{Значение} должно быть выражением, \emph{совместимым по присваиванию} с типом поля (\See{compat:assign}).

Указание нескольких значений для одного идентификатора поля является ошибкой.

Конструктор должен задавать значения для каждого поля класса с \emph{поздней инициализацией} (\See{decls:fields-init}).

Если класс импортирован из другого модуля, в конструкторе не могут использоваться идентификаторы не экспортированных полей. 
Если при этом у не экспортированного поля задана \emph{поздняя инициализация}, конструктор такого класса может быть использован только в модуле,
содержащем описание класса.

\begin{Trivil}[vspace=2pt]
тип Человек = класс {
    имя: Строка = позже
    возраст := 0
}

пусть Вася = Человек{имя: "Вася", возраст: 25}
\end{Trivil}

Пример ошибки - значение поля "имя" с поздней инициализацией не задано:
\begin{SampleErr}[vspace=2pt]
пусть Некто := Человек{возраст: 25}
\end{SampleErr}

\hypertarget{confirmation}{%
\subsection{Подтверждение типа}\label{expr:confirmation}}

Подтверждение типа применяется к первичному выражению, которое должно быть \emph{может быть} типа (\See{decls:mb-types}). 

\begin{Grammar}
Подтверждение-типа: '^'
\end{Grammar}   

Если значение первичного выражение, тип которого есть \keyword{мб} \emph{Т} равно \verb+'пусто'+, 
то происходит \emph{авария} (\See{stmt:crash-stmt}), иначе тип выражения становится равным \emph{Т}.


\begin{Trivil}[vspace=2pt]
пусть кличка: мб Строка = пусто
...
кличка = "Мурка"
...
напечатать(кличка^)
\end{Trivil}

\hypertarget{unary-ops}{%
\subsection{Унарные операции}\label{expr:unary-ops}}

\begin{Grammar}
Унарная-операция: '-' | '~' | ':~' 
\end{Grammar}   

\begin{tabular}[c]{c|l|l}
\textbf{Операция} & \textbf{Действие} &  \textbf{Разрешенные типы} \\ 
\hline
\verb|-| & отрицание & Байт, Цел64, Слово64, Вещ64 \\
\verb|~| & логическое НЕ & Лог \\
\verb|:~| & инвертирование битов & Байт, Цел64, Слово64 \\
\hline
\end{tabular}

\bigskip
Унарные операторы имеют приоритет выше, чем бинарные, то есть выражение \verb|-х + 1| выполняется как \verb|(-х) + 1|.
Тип результата унарных операций равен типу операнда.

\hypertarget{of-type}{%
\subsection{Проверка типа}\label{expr:of-type}}

Операция \emph{проверка типа} применима к операнду типа класс или \emph{мб} класс. Тип, указанный в операции справа, должен быть типом класса.
Тип результата - логический.

Для операнда \emph{мб} типа со значением \verb+'пусто'+ операция возвращает  \verb+ложь+. 
Иначе, операция проверяет, что \emph{динамический} тип объекта равен типу, 
указанному в операции, или является расширением этого типа и возвращает значение \verb+истина+, если это так.

\begin{Grammar}
Проверка-типа: Выражение 'типа' Указ-типа 
\end{Grammar}    

\begin{Trivil}
тип К1 = класс {}
тип К2 = класс (К1) {}

пусть к1: К1 = К1{}
пусть к2: К1 = К2{}
пусть к3: мб К1 = пусто

пусть б :=  к1 типа К2 // ложь
б := к2 типа К2 // истина
б := к3 типа К2 // ложь
\end{Trivil}


\hypertarget{binary-ops}{%
\subsection{Бинарные операции}\label{expr:binary-ops}}

\begin{Grammar}
Бинарная-операция
    : Арифметические
    | Сравнения
    | Логические
    | Битовые
    | Сдвиги
Арифметические: '+' | '-' | '*' | '/' | '%'
Сравнения: '=' | '#' | '<' | '<=' | '>' | '>='
Логические: '|' | '&' 
Битовые: ':|' | ':&' | ':\'
Сдвиги:   '<<' | '>>'
\end{Grammar} 


\hypertarget{ops-precedence}{%
\subsubsection{Приоритеты операции}\label{expr:ops-precedence}}

Язык определяется пять уровней приоритета для бинарных операций. Операции умножения имеют самый высокий приоритет, а операция логическое ИЛИ (\verb+|+) имеет самый низкий приоритет.

\begin{tabular}[c]{c|l}
\textbf{Приоритет} & \textbf{Операция} \\ 
\hline
5 &   \verb#* / %# \\
4 &   \verb#+ -# \\
3 &   \verb|= # < <= > >=| \\
2 &   \verb#&# \\
1 &  \verb#|# \\
\hline
\end{tabular}

\bigskip
Бинарные операции с одинаковым приоритетом ассоциируются слева направо. Например, \verb|x / y * z| эквивалентно \verb|(x / y) * z|.

\hypertarget{ops-arithmetic}{%
\subsubsection{Арифметические операции}\label{expr:ops-arithmetic}}

Арифметические операторы применяются к числовым операндам, выдают результат того же типа, что и тип операндов.
Типы левого и правого операнда должны совпадать. 

\bigskip
\begin{tabular}[c]{c|l|l}
\textbf{Операция} & \textbf{Действие} & \textbf{Разрешенные типы} \\ 
\hline
\verb|+| & сумма & Байт, Цел64, Слово64, Вещ64 \\
\verb|-| &  разница & Байт, Цел64, Слово64, Вещ64 \\
\verb|*| & произведение & Байт, Цел64, Слово64, Вещ64 \\
\verb|/| &  деление & Байт, Цел64, Слово64, Вещ64\\
\% & остаток от деления  &  Байт, Цел64, Слово64 \\
\hline
\end{tabular}


\hypertarget{ops-comparison}{%
\subsubsection{Операции сравнения}\label{expr:ops-comparison}}

Операции сравнения выдают результат типа Лог. 

Все операции сравнения \verb|'=', '#', '<', '<=', '>', '>='| применимы к операндам типов Байт, Цел64, Слово64, Цел64 и Символ. 
Типы левого и правого операнда, при этом, должны совпадать.

Операции \verb|'=', '#'| также применимы в следующих случаях:

\smallskip
\begin{tabular}[c]{r|l}
\textbf{Тип левого операнда} & \textbf{Правый операнд}  \\ 
\hline
Лог & операнд типа Лог \\
Строка & операнд типа Строка \\
класс \emph{Т} & операнд типа \emph{Т} \\
\keyword{мб} \emph{Т} & 'пусто' или операнд типа \keyword{мб} \emph{Т} \\
\hline
\end{tabular}

\hypertarget{ops-logical}{%
\subsubsection{Логические операции}\label{expr:ops-logical}}

Операции \emph{логическое ИЛИ} (\verb+|+) и \emph{логическое И} (\verb+&+) применимы к операндам типа Лог и выдают результат типа Лог.

\smallskip
\begin{tabular}[c]{rcl}
\verb+а | б+  & означает & если а, то истина, иначе б \\
\verb+а & б+  & означает & если а, то б,  иначе ложь \\
\end{tabular}

\hypertarget{ops-bitwise}{%
\subsubsection{Битовые операции}\label{expr:ops-bitwise}}

Операции \emph{битовое ИЛИ} (\verb+:|+), \emph{битовое И} (\verb+:&+) и \emph{XOR - битовое исключающее ИЛИ} (\verb+:\+) 
применимы к операндам целых типов (Байт, Цел64, Слово64), оба операнда должны быть одного типа. 
Тип результата равен типу операндов.

\hypertarget{ops-shifts}{%
\subsubsection{Операции сдвига}\label{expr:ops-shifts}}

Операции \emph{сдвиг влево} (\verb+<<+) и \emph{сдвиг вправо} (\verb+>>+) применимы к операндам целых типов
и выдают результат того же типа, что и тип первого операнда.


\hypertarget{const-expr}{%
\subsection{Константные выражения}\label{expr:const-expr}}

Константные выражения - это выражения, которые могут быть вычислены во время компиляции.

Минимальные требования к компилятору языка \thelang{}: компилятор должен вычислять выражение, состоящее из одного операнда, который является литералом или 
идентификатором, обозначающим константу или функцию (не метод).




