\hypertarget{statements}{%
\section{Операторы}\label{stmt:chapter}}

Операторы задают действия.

\begin{Grammar}
Оператор
    : Локальное-описание
    | Простой-оператор
    | Оператор-если
    | Оператор-надо
    | Оператор-выбор
    | Оператор-пока
    | Оператор-вернуть
    | Оператор-прервать
    | Оператор-авария

Простой-оператор
    : Оператор-выражение 
    | Оператор-присваивания
    | Инкремент 
    | Декремент
\end{Grammar}

\hypertarget{blocks}{%
\subsection{Блоки}\label{stmt:blocks}}

Операторы сгрупированы в \emph{Блоки}, которые задают последовательность действий для функций и методов (\See{decls:functions}, \See{decls:methods}) и входа в модуль (\See{mods:entry}).
Блок - это, возможно, пустая последовательность операторов, которые могут включать локальные описания.


\begin{Grammar}
Блок: '{' Список-операторов? '}'
Список-операторов: Оператор (Разделитель Оператор)* 
\end{Grammar}

\hypertarget{local-decls}{%
\subsection{Локальные описания}\label{stmt:local-decls}}

Локальное описание определяет идентификатор, для которого областью действия (\See{decls:scopes}) является часть блока, 
от точки завершения описания до завершающей скобки блока, исключая вложенные блоки, в которых описан такой же идентификатор.

\begin{Grammar}
Локальное-описание: Описание-переменной
\end{Grammar}

Для локальных переменных не может быть задана \emph{поздняя инициализация} (\See{decls:variables}).

\TBD: Нужны ли локальные константы? Или это задача оптимизации?

\hypertarget{expr-stmt}{%
\subsection{Выражение, как оператор}\label{stmt:expr-stmt}}

Выражение, являющееся вызовом функции или метода, кроме вызова стандартных функций (\See{stdfuncs:std-funcs}), может быть использовано как оператор. 
Результат вызова при этом игнорируется. 

\begin{Grammar}
Оператор-выражение: Выражение
\end{Grammar}

\begin{Trivil}
напечатать("Привет")
Факториал(5)
\end{Trivil}

Не могут быть использованы в качестве оператора:
\begin{SampleErr}[vspace=2pt]
1 + 1
длина(а)
\end{SampleErr}

\hypertarget{assignment}{%
\subsection{Оператор присваивания}\label{stmt:assignment}}

Присваивание заменяет текущее значение, хранящееся в переменной, новым значением, заданным выражением.

\begin{Grammar}
Оператор-присваивания: Выражение ':=' Выражение
\end{Grammar}

Выражение в левой части должно быть \emph{изменяемым}:

\smallskip
\begin{tabular}[l]{l|l|p{4.8cm}}
 \multicolumn{2}{l|}{\textbf{Левое выражение}}   & \textbf{Условие}  \\ 
\hline
Имя объекта  & \verb+пер+ или \verb+мод.пер+ &  \emph{пер} - это изменяемая переменная (\See{decls:variables}) \\
Доступ к полю & \verb+что-то.поле+ & \emph{что-то} - это изменяемое выражение, \emph{поле} - это изменяемое поле (\See{decls:fields-init}) \\
Индексация & \verb+что-то[индекс]+ & \emph{что-то} - это изменяемое выражение \\
Преобразование & \verb+что-то(:Тип)+ & \emph{что-то} - это изменяемое выражение \\
\hline
\end{tabular}

\bigskip
Выражение в правой части должно быть \emph{совместимо по присваиванию} с типом левого выражение (\See{compat:assign}).

\begin{Trivil}
пусть ц := 0
пусть байты := Байты[1, 2, 3]
ц := 2
байты[ц] = 5
\end{Trivil}

Ошибка присваивания в неизменяемое выражение:
\begin{SampleErr}[vspace=2pt]
пусть ц = 0
ц := 2
\end{SampleErr}

\hypertarget{inc-dec}{%
\subsection{Инкремент и декремент}\label{stmt:inc-dec}}

Операторы \emph{Инкремент} ('++') и \emph{Декремент} ('--') увеличивают или уменьшают свои операнды на 1. 

\begin{Grammar}
Инкремент: Выражение '++'
Декремент: Выражение '--'
\end{Grammar}

Как и в случае присваивания (\See{stmt:assignment}), выражение должно быть \emph{изменяемым}.
Тип выражения должен быть одного из типов: Байт, Цел64, Слово64.

\begin{Trivil}
пусть ц := 1
пусть байты := Байты[1, 2, 3]
байты[ц]++
\end{Trivil}

\hypertarget{if-stmt}{%
\subsection{Оператор 'если'}\label{stmt:if-stmt}}

Оператор \keyword{если} определяет условное выполнение двух ветвей в соответствии со значением логического выражения. 
Если выражение принимает значение \verb+истина+, выполняется Блок первой веткви, в противном случае, выполняется ветвь \keyword{иначе}, если она задана.

\begin{Grammar}
Оператор-если: 
    'если' Выражение Блок ('иначе' (Оператор-если | Блок))?
\end{Grammar}

\begin{Trivil}
если ц > макс { ц := макс }

если Буква?(сим) { Имя() }
иначе если Цифра?(сим) { Число() }
иначе { Ошибка!() }
\end{Trivil}

\hypertarget{guard-stmt}{%
\subsection{Оператор 'надо'}\label{stmt:if-guard}}

Оператор \keyword{надо} используется для завершения исполнения операторов некоторого контекста, 
если условие, заданое логическим выражением, не выполнено.

\begin{Grammar}
Оператор-надо: 
    'надо' Выражение 'иначе' (Завершающий-оператор | Блок)
Завершающий-оператор
    : Оператор-вернуть
    | Оператор-прервать
    | Оператор-авария
\end{Grammar}

Если в ветви \keyword{иначе} стоит \emph{Блок}, то последним оператором блока должен быть завершающий оператор.

\smallskip
\begin{tabular}[c]{r|p{6.5cm}}
 \textbf{Завершающий оператор} & \textbf{Действие}  \\ 
\hline
\keyword{вернуть} (\See{stmt:return-stmt}) & выход из тела функции, метода или входа \\
\keyword{прервать} (\See{stmt:break-stmt}) & выход из ближайшего объемлющего цикла \\
\keyword{авария} (\See{stmt:crash-stmt}) & аварийное завершение программы \\
\hline
\end{tabular}

\begin{Trivil}
надо делитель # 0 иначе авария("деление на ноль")

надо число > 1 иначе вернуть 1
\end{Trivil}

\hypertarget{switch-stmt}{%
\subsection{Оператор 'выбор'}\label{stmt:switch-stmt}}

Оператор \keyword{выбор} выбирает одну ветвь выполнения из нескольких вариантов. 

\begin{Grammar}
Оператор-выбор
    : Выбор-по-выражению 
    | Выбор-по-предикатам
    | Выбор-по-типу
\end{Grammar}

Есть три разновидности оператора выбора
\begin{d_itemize}
\item
    \emph{выбор по выражению} (\See{stmt:switch-stmt-expr})
\item
    \emph{выбор по предикатам} (\See{stmt:switch-stmt-predicate})
\item
    \emph{выбор по типу} (\See{stmt:switch-stmt-type})
\end{d_itemize}
 
\hypertarget{switch-stmt-expr}{%
\subsubsection{Выбор по выражению}\label{stmt:switch-stmt-expr}}

В операторе \emph{выбор по выражению} выбор идет по по значению выражения оператора (значение сравнивается со значениями выражений в вариантах).

\begin{Grammar}
Выбор-по-выражению: 
    'выбор' Выражение '{'
    Вариант*
    ('другое' Список-операторов?)?
    '}'
Вариант:
    'когда' Выражение (',' Выражение)* ':' 
    Список-операторов?
\end{Grammar}

При выполнении вычисляется \emph{Выражение} оператора,
затем выражения в \emph{Вариантах} вычисляются слева направо и сверху вниз. 
Как только значение выражения \emph{Варианта} стало равным значению выражения оператора, выполняется список операторов этого \emph{Варианта}.
Остальные варинты игнорируются.
Если ни один из вариантов не выполнен, и есть ветка \keyword{другое}, выполняется список операторов этой ветки.

Тип каждого выражения в вариантах должен быть равен эквивалентен типу первого выражения (\See{compat:equal-types}).

\begin{Trivil}
выбор х {
когда 0: вернуть "ничего"
когда 1: вернуть "один"
когда 2: вернуть "два"
другое вернуть "много"
}
\end{Trivil}

\hypertarget{switch-stmt-predicate}{%
\subsubsection{Выбор по предикатам}\label{stmt:switch-stmt-predicate}}

Если выражение после ключевого слова \keyword{выбор} отсутствует, 
то это оператор \emph{выбора по предикатам}.

\begin{Grammar}
Выбор-по-выражению: 
    'выбор' '{'
    Вариант*
    ('другое' Список-операторов?)?
    '}'
Вариант:
    'когда' Выражение (',' Выражение)* ':' 
    Список-операторов?
\end{Grammar}

В этом случае, каждое выражение в \emph{Вариантах} должно быть выражением логического типа. 
Эти выражения вычисляются  слева направо и сверху вниз до тех пор, когда значение выражения не равно истине. 
Как только значение выражения стало рано истине, выполняется список операторов этого варианта. Остальные варинты игнорируются.
Если ни один из вариантов не выполнен, и есть ветка \keyword{другое}, выполняется список операторов этой ветки.

\begin{Trivil}
выбор х {
когда х < 0: вернуть "отрицательное"
когда х > 0: вернуть "положительное"
другое вернуть "ноль"
}
\end{Trivil}

\hypertarget{switch-stmt-type}{%
\subsubsection{Выбор по типу}\label{stmt:switch-stmt-type}}

В операторе \emph{выбор по типу} выбор ветви выполнения происходит по типу выражения.

\begin{Grammar}
Выбор-по-выражению: 
    'выбор' Переменная-варианта? 'тип' Выражение '{'
    Вариант-типа*
    ('другое' Список-операторов?)?
    '}'
Переменная-варианта:    
    'пусть' Идентификатор ':'
Вариант-типа:
    'когда' Указ-типа (',' Указ-типа)* ':' 
    Список-операторов?
\end{Grammar}

Рассмотрим сначала оператор, в котором \emph{переменная варианта} не указана.

При выполнении такого оператора вычисляется \emph{Выражение}, тип которого должен быть типом класса (\See{decls:class-types}).
Для дальнейшего сравнения используется тип объекта, то есть тип, с которым объект был создан, иначе говоря, динамический тип.

В следующем примере для сравнения будет использовать тип \verb+К2+, так как это тип объекта \verb+к+:
\begin{Trivil}[vspace=2pt]
тип К1 = класс {}
тип К2 = класс (К1) {}
вход{
    пусть к: К = К2{}
    выбор тип к { ... }
}
\end{Trivil}

Динамический тип выражения сравнивается слева направо и сверху вниз на равенство типам, указанным в вариантах.
Как только один из типов \emph{Варианта} оказался равен типу выражения, выполняется список операторов этого \emph{Варианта}.
Остальные варинты игнорируются.
Если ни один из вариантов не выполнен, и есть ветка \keyword{другое}, выполняется список операторов этой ветки.

 Сравнение типа выражение оператора выполняется на строгое равентсво, наследование не учитывается. 
 Таким образом, в примере сработает ветка \verb+когда К2+, независимо от порядка веток в операторе.
\begin{Trivil}[vspace=2pt]
тип К1 = класс {}
тип К2 = класс (К1) {}
вход{
    пусть к: К = К2{}
    выбор тип к { 
    когда К1: 
    когда К2: // сработает эта ветка
    }
}
\end{Trivil}

Если в операторе указана \emph{переменная варианта}, то в каждой ветки исполнения 
(но не в ветке \keyword{другое}) будет доступна переменная с именем, заданным идентификатором,
 и типом, указанном в варианте. При этом в варианте должен быть указан только один тип.
 
\begin{Trivil}
тип Человек = класс { имя := "" }
тип Работник = класс (Человек) {
    зарплата := 0.0
}
фн зарплата(чел: Человек): Вещ64 {
    выбор пусть х: тип чел { 
    когда Работник: вернуть х.зарплата
    другое вернуть 0.0
    }
}
\end{Trivil}

\hypertarget{while-stmt}{%
\subsection{Оператор цикла 'пока' }\label{stmt:while-stmt}}

Оператор \keyword{пока} определяет повторное выполнение блока до тех пор, пока значение логического выражение равно \verb+истина+. 
Выражение вычисляется перед каждой итерацией.

\begin{Grammar}
Оператор-пока: 'пока' Выражение Блок 
\end{Grammar}

\begin{Trivil}
пока а < б {
    а := а * 2
}
\end{Trivil}

\hypertarget{break-stmt}{%
\subsection{Оператор 'прервать'}\label{stmt:break-stmt}}

Оператор \keyword{прервать} завершает выполнение самого внутреннего оператора цикла в рамках одной и той же функции.

\begin{Grammar}
Оператор-прервать: 'прервать' 
\end{Grammar}

\begin{Trivil}
пока истина {
    а := а * 2
    если а > б { прервать }
}
\end{Trivil}

\hypertarget{return-stmt}{%
\subsection{Оператор 'вернуть'}\label{stmt:return-stmt}}

Оператор \keyword{вернуть} завершает выполнение тела функции, метода или входа, и, возможно, возращает значение.

\begin{Grammar}
Оператор-вернуть: 'вернуть' (Выражение | Разделитель)
\end{Grammar}

Если оператор \keyword{вернуть} используется в теле входа или в теле функции или метода, в сигнатуре которых не указан тип результата, 
то выражение в операторе должно отсутствовать. 

И наоборот, если в оператор используется в теле функции или метода, в сигнатуре которых указан тип результата, выражение должно быть и 
оно должно быть \emph{совместимо по присваиванию} с типом результата (\See{compat:assign}).

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 {
    если ц <= 1 { вернуть 1 }
    вернуть ц * Факториал(ц - 1)
}
\end{Trivil}

Если выражение в операторе присутствует, то оно должно начинаться на одной строке с ключевым словом \keyword{вернуть},
иначе компилятор выдаст ошибку:
\begin{SampleErr}[vspace=2pt]
фн цифра?(сим: Символ): Лог {
    вернуть  // ошибка компиляции
        '0' <= сим & сим <= '9'
}
\end{SampleErr}

А так верно:
\begin{Trivil}[vspace=2pt]
фн цифра?(сим: Символ): Лог {
    вернуть '0' <= сим 
      & сим <= '9'
}
\end{Trivil}



\hypertarget{crash-stmt}{%
\subsection{Оператор 'авария' и аварийная ситуация}\label{stmt:crash-stmt}}

Оператор \keyword{авария} запускает аварийную ситуация, которая, как правило, приводит к аварийному завершению программы. 

\begin{Grammar}
Оператор-авария: 'авария' '(' Выражение ')'
\end{Grammar}

Тип выражения должен быть Строка. Значение этого выражения используется в сообщении об аварийной ситуации.

Кроме явного запуска аварийной ситуации, аварийная ситуация может быть запущена неявно, в следующих случаях:
\begin{d_itemize}
\item
    Выход индекса за границы вектора при индексации
\item
    Операция подтверждения типа выполнена над объектом со значением 'пусто'
\item
    Недопустимое преобразование типа 
\item
    Недопустимая последовательность байт в кодировке UTF-8
\item
    Невозможность выделения памяти для динамического объекта
\item
    Нереализованная возможность в системе поддержки выполнения
\end{d_itemize}

\bigskip
Язык \thelang{} не содержит средств перехвата аварийной ситуации или восстановления после него. 
Такие средства могут быть добавлены на уровне библиотек.
