\hypertarget{statements}{%
\section{Операторы}\label{stmt:chapter}}

Операторы задают действия.

\begin{Grammar}
Оператор
    : Локальное-описание
    | Простой-оператор
    | Оператор-если
    | Оператор-надо
    | Оператор-выбор
    | Оператор-пока
    | Оператор-вернуть
    | Оператор-прервать
    | Оператор-авария

Простой-оператор
    : Оператор-выражение 
    | Оператор-присваивания
    | Инкремент 
    | Декремент
\end{Grammar}

\hypertarget{blocks}{%
\subsection{Блоки}\label{stmt:blocks}}

Операторы сгрупированы в \emph{Блоки}, которые задают последовательность действий для функций и методов (\See{decls:functions}, \See{decls:methods}) и входа в модуль (\See{mods:entry}).
Блок - это, возможно, пустая последовательность операторов, которые могут включать локальные описания.


\begin{Grammar}
Блок: '{' Список-операторов? '}'
Список-операторов: Оператор (Разделитель Оператор)* 
\end{Grammar}

\hypertarget{local-decls}{%
\subsection{Локальные описания}\label{stmt:local-decls}}

Локальное описание определяет идентификатор, для которого областью действия (\See{decls:scopes}) является часть блока, 
от точки завершения описания до завершающей скобки блока, исключая вложенные блоки, в которых описан такой же идентификатор.

\begin{Grammar}
Локальное-описание: Описание-переменной
\end{Grammar}

Для локальных переменных не может быть задана \emph{поздняя инициализация} (\See{decls:variables}).

\TBD: Нужны ли локальные константы? Или это задача оптимизации?

\hypertarget{expr-stmt}{%
\subsection{Выражение, как оператор}\label{stmt:expr-stmt}}

Выражение, являющееся вызовом функции или метода, кроме вызова стандартных функций (\See{stdfuncs:std-funcs}), может быть использовано как оператор. 
Результат вызова при этом игнорируется. 

\begin{Grammar}
Оператор-выражение: Выражение
\end{Grammar}

\begin{Trivil}
напечатать("Привет")
Факториал(5)
\end{Trivil}

Не могут быть использованы в качестве оператора:
\begin{SampleErr}[vspace=2pt]
1 + 1
длина(а)
\end{SampleErr}

\hypertarget{assignment}{%
\subsection{Оператор присваивания}\label{stmt:assignment}}

Присваивание заменяет текущее значение, хранящееся в переменной, новым значением, заданным выражением.

\begin{Grammar}
Оператор-присваивания: Выражение ':=' Выражение
\end{Grammar}

Выражение в левой части должно быть \emph{изменяемым}:

\smallskip
\begin{tabular}[l]{l|l|p{4.8cm}}
 \multicolumn{2}{l|}{\textbf{Левое выражение}}   & \textbf{Условие}  \\ 
\hline
Имя объекта  & \verb+пер+ или \verb+мод.пер+ &  \emph{пер} - это изменяемая переменная (\See{decls:variables}) \\
Доступ к полю & \verb+что-то.поле+ & \emph{что-то} - это изменяемое выражение, \emph{поле} - это изменяемое поле (\See{decls:fields-init}) \\
Индексация & \verb+что-то[индекс]+ & \emph{что-то} - это изменяемое выражение \\
Преобразование & \verb+что-то(:Тип)+ & \emph{что-то} - это изменяемое выражение \\
\hline
\end{tabular}

\bigskip
Выражение в правой части должно быть \emph{совместимо по присваиванию} с типом левого выражение (\See{compat:assign}).

\begin{Trivil}
пусть ц := 0
пусть байты := Байты[1, 2, 3]
ц := 2
байты[ц] = 5
\end{Trivil}

Ошибка присваивания в неизменяемое выражение:
\begin{SampleErr}[vspace=2pt]
пусть ц = 0
ц := 2
\end{SampleErr}

\hypertarget{inc-dec}{%
\subsection{Инкремент и декремент}\label{stmt:inc-dec}}

Операторы \emph{Инкремент} ('++') и \emph{Декремент} ('--') увеличивают или уменьшают свои операнды на 1. 

\begin{Grammar}
Инкремент: Выражение '++'
Декремент: Выражение '--'
\end{Grammar}

Как и в случае присваивания (\See{stmt:assignment}), выражение должно быть \emph{изменяемым}.
Тип выражения должен быть одного из типов: Байт, Цел64, Слово64.

\begin{Trivil}
пусть ц := 1
пусть байты := Байты[1, 2, 3]
байты[ц]++
\end{Trivil}

\hypertarget{if-stmt}{%
\subsection{Оператор 'если'}\label{stmt:if-stmt}}

Оператор \keyword{если} определяет условное выполнение двух ветвей в соответствии со значением логического выражения. 
Если выражение принимает значение \verb+истина+, выполняется Блок первой веткви, в противном случае, выполняется ветвь \keyword{иначе}, если она задана.

\begin{Grammar}
Оператор-если: 
    'если' Выражение Блок ('иначе' (Оператор-если | Блок))?
\end{Grammar}

\begin{Trivil}
если ц > макс { ц := макс }

если Буква?(сим) { Имя() }
иначе если Цифра?(сим) { Число() }
иначе { Ошибка!() }
\end{Trivil}

\hypertarget{guard-stmt}{%
\subsection{Оператор 'надо'}\label{stmt:if-guard}}

Оператор \keyword{надо} используется для завершения исполнения операторов некоторого контекста, 
если условие, заданое логическим выражением, не выполнено.

\begin{Grammar}
Оператор-надо: 
    'надо' Выражение 'иначе' (Завершающий-оператор | Блок)
Завершающий-оператор
    : Оператор-вернуть
    | Оператор-прервать
    | Оператор-авария
\end{Grammar}

Если в ветви \keyword{иначе} стоит \emph{Блок}, то последним оператором блока должен быть завершающий оператор.

\smallskip
\begin{tabular}[c]{r|p{6.5cm}}
 \textbf{Завершающий оператор} & \textbf{Действие}  \\ 
\hline
\keyword{вернуть} (\See{stmt:return-stmt}) & выход из тела функции, метода или входа \\
\keyword{прервать} (\See{stmt:break-stmt}) & выход из ближайшего объемлющего цикла \\
\keyword{авария} (\See{stmt:crash-stmt}) & аварийное завершение программы \\
\hline
\end{tabular}

\begin{Trivil}
надо делитель # 0 иначе авария("деление на ноль")

надо число > 1 иначе вернуть 1
\end{Trivil}

\hypertarget{switch-stmt}{%
\subsection{Оператор 'выбор'}\label{stmt:switch-stmt}}

Оператор \keyword{выбор} выбирает одну ветвь выполнения из нескольких вариантов.

\begin{Grammar}
Оператор-выбор: 
    'выбор' Выражение? '{'
    Вариант*
    ('другое' Список-операторов?)?
    '}'
Вариант:
    'когда' Выражение (',' Выражение)* ':' Список-операторов?
\end{Grammar}

Если  \emph{Выражение} после ключевого слова \keyword{выбор} задано, 
то выбор идет по по значению этого выражения (\See{stmt:switch-stmt-expr}), иначе выбор по предикатам (\See{stmt:switch-stmt-predicate}).

\bigskip
\TBD: Добавить оператор выбора по типу?

\hypertarget{switch-stmt-expr}{%
\subsubsection{Оператор 'выбор' по выражению}\label{stmt:switch-stmt-expr}}

При выполнении оператора \keyword{выбор} вычисляется \emph{Выражение} оператора,
затем выражения в \emph{Вариантах} вычисляются слева направо и сверху вниз. 
Как только значение выражения \emph{Варианта} стало равным значению выражения оператора, выполняется список операторов этого \emph{Варианта}.
Остальные варинты игнорируются.
Если ни один из вариантов не выполнен, и есть ветка \keyword{иначе}, выполняется список операторов этой ветки.

Тип каждого выражения в вариантах должен быть равен эквивалентен типу первого выражения (\See{compat:equal-types}).

\begin{Trivil}
выбор х {
когда 0: вернуть "ничего"
когда 1: вернуть "один"
когда 2: вернуть "два"
другое вернуть "много"
}
\end{Trivil}

\hypertarget{switch-stmt-predicate}{%
\subsubsection{Оператор 'выбор' по предикатам}\label{stmt:switch-stmt-predicate}}

В этом случае, каждое выражение в \emph{Вариантах} должно быть выражением логического типа. 
Эти выражения вычисляются  слева направо и сверху вниз до тех пор, когда значение выражения не равно истине. 
Как только значение выражения стало рано истине, выполняется список операторов этого варианта. Остальные варинты игнорируются.
Если ни один из вариантов не выполнен, и есть ветка \keyword{иначе}, выполняется список операторов этой ветки.

\begin{Trivil}
выбор х {
когда х < 0: вернуть "отрицательное"
когда х > 0: вернуть "положительное"
другое вернуть "ноль"
}
\end{Trivil}

\hypertarget{while-stmt}{%
\subsection{Оператор цикла 'пока' }\label{stmt:while-stmt}}

Оператор \keyword{пока} определяет повторное выполнение блока до тех пор, пока значение логического выражение равно \verb+истина+. 
Выражение вычисляется перед каждой итерацией.

\begin{Grammar}
Оператор-пока: 'пока' Выражение Блок 
\end{Grammar}

\begin{Trivil}
пока а < б {
    а := а * 2
}
\end{Trivil}

\hypertarget{break-stmt}{%
\subsection{Оператор 'прервать'}\label{stmt:break-stmt}}

Оператор \keyword{прервать} завершает выполнение самого внутреннего оператора цикла в рамках одной и той же функции.

\begin{Grammar}
Оператор-прервать: 'прервать' 
\end{Grammar}

\begin{Trivil}
пока истина {
    а := а * 2
    если а > б { прервать }
}
\end{Trivil}

\hypertarget{return-stmt}{%
\subsection{Оператор 'вернуть'}\label{stmt:return-stmt}}

Оператор \keyword{вернуть} завершает выполнение тела функции, метода или входа, и, возможно, возращает значение.

\begin{Grammar}
Оператор-вернуть: 'вернуть'  (Выражение | Разделитель)
\end{Grammar}

Если оператор \keyword{вернуть} используется в теле входа или в теле функции или метода, в сигнатуре которых не указан тип результата, 
то выражение в операторе должно отсутствовать.

И наоборот, если в оператор используется в теле функции или метода, в сигнатуре которых указан тип результата, выражение должно быть и 
оно должно быть \emph{совместимо по присваиванию} с типом результата (\See{compat:assign}).

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 {
    если ц <= 1 { вернуть 1 }
    вернуть ц * Факториал(ц - 1)
}
\end{Trivil}

\hypertarget{crash-stmt}{%
\subsection{Оператор 'авария' и аварийная ситуация}\label{stmt:crash-stmt}}

Оператор \keyword{авария} запускает аварийную ситуация, которая, как правило, приводит к аварийному завершению программы. 

\begin{Grammar}
Оператор-авария: 'авария' '(' Выражение ')'
\end{Grammar}

Тип выражения должен быть Строка. Значение этого выражения используется в сообщении об аварийной ситуации.

Кроме явного запуска аварийной ситуации, аварийная ситуация может быть запущена неявно, в следующих случаях:
\begin{d_itemize}
\item
    Выход индекса за границы вектора при индексации
\item
    Операция подтверждения типа выполнена над объектом со значением 'пусто'
\item
    Недопустимое преобразование типа 
\item
    Недопустимая последовательность байт в кодировке UTF-8
\item
    Невозможность выделения памяти для динамического объекта
\item
    Нереализованная возможность в системе поддержки выполнения
\end{d_itemize}

\bigskip
Язык \thelang{} не содержит средств перехвата аварийной ситуации или восстановления после него. 
Такие средства могут быть добавлены на уровне библиотек.
