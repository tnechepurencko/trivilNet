\hypertarget{expressions}{%
\section{Выражения}\label{expr:chapter}}

Выражение определяет вычисление значения путем применения операторов и функций к операндам. 

\begin{Grammar}
Выражение
    : Унарное-выражение
	| Выражение Бинарная-операция Выражение

Унарное-выражение
	: Первичное-выражение
	| Унарная-операция Унарное-выражение
\end{Grammar}    

\hypertarget{primary-expr}{%
\subsection{Первичные выражения}\label{expr:primary-expr}}

Первичные выражения - это выражения, которые являются операндами унарных и бинарных операций.

\begin{Grammar}
Первичное-выражение
    : Операнд
	( Доступ
	| Индексация
	| Преобразование
	| Вызов
	| Конструктор-вектора
	| Конструктор-класса
	| Отмена-может-быть
	)*
\end{Grammar}    

\begin{Trivil}
1
к.поле
а[№]
Факториал(5)
А[1, 2, 3]
К{имя: "Вася", возраст: 23}
а^
объект.вектор[номер].метод()
\end{Trivil}

\hypertarget{operands}{%
\subsection{Операнды}\label{expr:operands}}

Операнды - это элементарные значения в выражении. Операнд может быть литералом, именем объекта, 
обозначающим константу, переменную или функцию, или выражением в скобках.

\begin{Grammar}
Операнд: Литерал | Имя-объекта | '(' Выражение ')'
Литерал
    : Целочисленный-литерал
    | Вещественный-литерал
    | Строковый-литерал
    | Символьный-литерал
Имя-объекта: Идентификатор | Импорт-идент
Импорт-идент: Идентификатор '.' Идентификатор
\end{Grammar}    

Если в качестве имени объекта используется \emph{Импорт-идент}, то первый идентификатор в нем должен обозначать имя импортированного модуля (\See{mods:import}), а второй идентификатор должен быть идентификатором экспортированного из этого модуля объекта.

\smallskip
\begin{tabular}[c]{l|l}
\textbf{Операнд} & \textbf{Тип выражения} \\ \hline
Имя объекта & тип объекта \\
Целочисленный-литерал & Цел64 \\
Вещественный-литерал & Вещ64 \\ 
Строковый-литерал & Строка \\ 
Символьный-литерал & Символ \\
Выражение в скобках & тип выражения \\
\end{tabular}

\hypertarget{selector}{%
\subsection{Доступ к полям и методам}\label{expr:selector}}

Доступ применяется к первичному выражению.

\begin{Grammar}
Доступ: '.' Идентификатор
\end{Grammar}    

В выражении \verb|что-то.имя|:
\begin{d_itemize}
\item
    \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип класса. 
\item
    а \verb|имя| должно быть идентификатором поля или метода типа \emph{Т} или базового класса \emph{Т}
\end{d_itemize}

Типом выражения доступа является тип поля или метода.

\begin{Trivil}
чел.возраст := 5

если чел.возраст < 18 { ... }
\end{Trivil}

\hypertarget{indexation}{%
\subsection{Индексация}\label{expr:indexation}}

Индексация применяется к первичному выражению.

\begin{Grammar}
Индексация: '[' Выражение '['
\end{Grammar}    

Выражении \verb|что-то[индекс]| обозначает элемент вектора или вариативного параметра, индекс которого определяется выражением \verb|индекс|.
\begin{d_itemize}
\item
    \verb|что-то| должно быть идентификатором, обозначающим вариативный параметр
\item
    или \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип вектора
\item
    \verb|индекс| должен быть выражением типа \verb|Цел64| или \verb|Байт|
\end{d_itemize}

Если во время исполнения индекс выходит за границы вектора или параметра (индекс < 0 | индекс >= длина), происходит \emph{авария}.

Типом выражения индексации является тип элемента вектора, если индексируется вектор или тип вариативного параметра, если индексируется вариативный параметр.

Так как индексация и конструктор вектора (\See{expr:vector-composite}) не всегда различимы синтаксически, выбор между ними происходит на уровне семантики, 
если выражение \verb|что-то|  обозначает тип, то это конструктор вектора, иначе индексация.

\hypertarget{conversion}{%
\subsection{Преобразование типа}\label{expr:conversion}}

Преобразование типа применяется к первичному выражению, и преобразует, если это возможно, значение выражения к \emph{целевому типу}, указанному в операции преобразования.

\begin{Grammar}
Преобразование: '(:' 'осторожно'? Указ-типа ')'
\end{Grammar}   

Если в преобразование есть ключевое слово \keyword{осторожно}, то это небезопасная операция, которая рассматривается отдельно (\See{unsafe:conversions}).

Часть преобразований, например, преобразования между числовыми типами и символами, а так же строковые преобразования могут изменить 
представление значения первичного выражения и повлечь за собой затраты на выполнение, а так же \emph{аварийное завершение}, если выполнить преобразование невозможно.

Преобразование классов изменяют только тип, но не представление значения.

\bigskip
Разрешенные преобразования:

\begin{tabular}[c]{p{2cm}|p{4.5cm}|p{4cm}}
\textbf{Целевой тип} & \textbf{Тип выражения} &  \textbf{Условие выполнения} \\ 
\hline
Байт & Цел64, Слово64, Символ, Строковый литерал длины 1 & значение в диапазоне 0..255 \\
\hline
\multirow{3}*{Цел64} & Байт, Символ, Строковый литерал длины 1 & всегда \\ 
 & Слово64 & значение в диапазоне 0..Max(Цел64) \\
 & Вещ64  & всегда \\
\hline
\multirow{2}*{Слово64} & Байт, Символ, Строковый литерал длины 1 & всегда \\
   & Цел64 & не отрицательное значение \\
\hline
Вещ64 & Цел64 & всегда \\
\hline
\multirow{2}*{Символ} &  Байт, Строковый литерал длины 1 & всегда \\
    & Цел64, Слово64 & значение в диапазоне Unicode символа \\
\hline
Строка & Символ, \verb+[]+Символ, \verb+[]+Байт & всегда \\
\hline
\verb+[]+Байт & Строка, Символ  & всегда \\
\hline
\verb+[]+Символ & Строка  & всегда \\
\hline
Класс & Класс & От базового класса к расширенному \\
\hline
\end{tabular}

\begin{Trivil}
тип Байты = []Байт
пусть байты = "Привет"(:Байты)

пусть три = pi(:Цел64)
\end{Trivil}

\hypertarget{call}{%
\subsection{Вызов функции или метода}\label{expr:call}}

Вызов применяется к первичному выражению. Это выражение
\begin{d_itemize}
\item
    является идентификатором стандартной функции (\See{stdfuncs:chapter})
\item
    или обозначает функцию, тогда это \emph{вызов функции}
\item
    или явлется выражением типа класс, тогда это \emph{вызов метода}
\end{d_itemize}

\begin{Grammar}
Вызов: '(' Список-аргументов? ')'
Список-аргументов: Аргумент (',' Аргумент)* ','?
Аргумент: Выражение '...'?
\end{Grammar}   

В вызове указывается список аргументов. Число аргументов в списке должно быть равно числу параметров в сигнатуре функции или метода, за исключение случая, 
когда в сигнатуре есть вариативный параметр. Для вариативного параметра число аргументов может быть от нуля и более.

Каждый аргумент в вызове является \emph{выражением}. 
Если для вариативного параметра задан единственный аргумент, то после выражения может стоять знак операции \verb+...+, делающий  \emph{развернутое выражение} (\See{expr:call-unfold}).

Для всех других аргументов, выражение должно быть совместимо по присваиванию с типом параметра (\See{compat:assign}).

Типом выражения вызова является тип результата. Если в сигнатуре функции или метода тип результата отсутствует, то вызов не может быть операндом для любой операции.

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 { /*тело*/ }

пусть рез = Факториал(5)
\end{Trivil}

\hypertarget{call-unfold}{%
\subsubsection{Развернутое выражение}\label{expr:call-unfold}}

\emph{Развернутое выражение} может быть использовано только как аргумент для вариативного параметра и только, если это единственный аргумент для этого параметра. 
Если развернутое выражение \emph{х}\verb+...+ используется как аргумент для параметра \verb+п: ...Т+, то должно выполняется одно из условий:
\begin{d_itemize}
\item
    \emph{х} является вариативным параметром того же типа \verb+Т+
\item
    \emph{х} - это выражение типа вектора, причем тип вектора определен, как \verb+[]Т+
\end{d_itemize}

Пример использования развернутого вектора в качестве аргумента вариативного параметра:
\begin{Trivil}[vspace=2pt]
фн Соединить(список: ...Строка) {/*тело*/}

тип Строки = []Строка

фн Сохранить(строки: Строки) {
   пусть текст = Соединить(строки...)
   /* сохранение текста */
}
\end{Trivil}

\hypertarget{vector-composite}{%
\subsection{Конструктор вектора}\label{expr:vector-composite}}

Конструктор вектора применяется к первичному выражению, которое должно обозначать тип вектора. Результатом выполнения конструктора является экземпляр типа вектора.

\begin{Grammar}
Конструктор-вектора: '[' Список-элементов? ']' 
Список-элементов: Элемент (',' Элемент)* ','?
Элемент: (Индекс-элемента ':')? Значение-элемента
Индекс-элемента: Выражение
Значение-элемента: Выражение
\end{Grammar}   

Пример использования конструктора вектора в вызове:
\begin{Trivil}[vspace=2pt]
тип Строки = []Строка
фн Сохранить(строки: Строки) { /*тело*/ }

Сохранить(Строки["привет", "мир"])
\end{Trivil}

Для всех элементов должно выполняться:
\begin{d_itemize}
\item
    \emph{Индекс-элемента} должен быть выражением типа \verb|Цел64| или \verb|Байт|
\item
    \emph{Значение-элемента} должен быть выражением, совместимым по присваиванию с типом элемента вектора (\See{compat:assign}).
\end{d_itemize}

Если хотя бы для одного элемента конструктора задан \emph{Индекс-элемента}, то он должен быть задан для всех элементов конструктора.

Если \emph{Индекс-элемента} задан, то в результируюшем векторе в позиции \emph{Индекс-элемента} будет стоять значение \emph{Значение-элемента}.
Если \emph{Индекс-элемента} не задан, то элементы будет размещены в результирующем векторе последовательно, начиная с индекса 0.

Длина результирующего вектора равна максимальному индексу + 1.

\TBD: Если конструктор вектора задает значения не для всех индексов, то тип элемента вектора должен быть типом, для которое есть значение по умолчанию.

\hypertarget{class-composite}{%
\subsection{Конструктор экземпляра класса}\label{expr:class-composite}}

\hypertarget{mb-ops}{%
\subsection{Операции для объектов может быть типа}\label{expr:mb-ops}}

\hypertarget{operators}{%
\subsection{Операции}\label{expr:operators}}

\hypertarget{const-expr}{%
\subsection{Константные выражения}\label{expr:const-expr}}