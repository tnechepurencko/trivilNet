\hypertarget{expressions}{%
\section{Выражения}\label{expr:chapter}}

Выражение определяет вычисление значения путем применения операторов и функций к операндам. 

\begin{Grammar}
Выражение
    : Унарное-выражение
	| Выражение Бинарная-операция Выражение

Унарное-выражение
	: Первичное-выражение
	| Унарная-операция Унарное-выражение
\end{Grammar}    

\hypertarget{primary-expr}{%
\subsection{Первичные выражения}\label{expr:primary-expr}}

Первичные выражения - это выражения, которые являются операндами унарных и бинарных операций.

\begin{Grammar}
Первичное-выражение
    : Операнд
	( Доступ
	| Индексация
	| Преобразование
	| Аргументы-вызова
	| Конструктор-массива
	| Конструктор-класса
	| Отмена-может-быть
	)*
\end{Grammar}    

\begin{Trivil}
1
к.поле
а[№]
Факториал(5)
А[1, 2, 3]
К{имя: "Вася", возраст: 23}
а^
объект.вектор[номер].метод()
\end{Trivil}

\hypertarget{operands}{%
\subsection{Операнды}\label{expr:operands}}

Операнды - это элементарные значения в выражении. Операнд может быть литералом, именем объекта, 
обозначающим константу, переменную или функцию, или выражением в скобках.

\begin{Grammar}
Операнд: Литерал | Имя-объекта | '(' Выражение ')'
Литерал
    : Целочисленный-литерал
    | Вещественный-литерал
    | Строковый-литерал
    | Символьный-литерал
Имя-объекта: Идентификатор | Импорт-идент
Импорт-идент: Идентификатор '.' Идентификатор
\end{Grammar}    

Если в качестве имени объекта используется \emph{Импорт-идент}, то первый идентификатор в нем должен обозначать имя импортированного модуля (\See{mods:import}), а второй идентификатор должен быть идентификатором экспортированного из этого модуля объекта.

\smallskip
\begin{tabular}[c]{l|l}
\textbf{Операнд} & \textbf{Тип выражения} \\ \hline
Имя объекта & тип объекта \\
Целочисленный-литерал & Цел64 \\
Вещественный-литерал & Вещ64 \\ 
Строковый-литерал & Строка \\ 
Символьный-литерал & Символ \\
Выражение в скобках & тип выражения \\
\end{tabular}

\hypertarget{selector}{%
\subsection{Доступ к полям и методам}\label{expr:selector}}

Доступ применяется к первичному выражению.

\begin{Grammar}
Доступ: '.' Идентификатор
\end{Grammar}    

В выражении \verb|что-то.имя|:
\begin{itemize}
\item
    \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип класса. 
\item
    а \verb|имя| должно быть идентификатором поля или метода типа \emph{Т} или базового класса \emph{Т}
\end{itemize}

Типом выражения доступа является тип поля или метода.

\begin{Trivil}
чел.возраст := 5

если чел.возраст < 18 { ... }
\end{Trivil}

\hypertarget{indexation}{%
\subsection{Индексация}\label{expr:indexation}}

Индексация применяется к первичному выражению.

\begin{Grammar}
Индексация: '[' Выражение '['
\end{Grammar}    

Выражении \verb|что-то[индекс]| обозначает элемент вектора или вариативного параметра, индекс которого определяется выражением \verb|индекс|.
\begin{itemize}
\item
    \verb|что-то| должно быть идентификатором, обозначающим вариативный параметр
\item
    или \verb|что-то| должно быть выражением типа \emph{Т}, где \emph{Т} - это тип вектора
\item
    \verb|индекс| должен быть выражением типа \verb|Цел64| или \verb|Байт|
\end{itemize}

Если во время исполнения индекс выходит за границы вектора или параметра (индекс < 0 | индекс >= длина), происходит \emph{авария}.

Типом выражения индексации является тип элемента вектора, если индексируется вектор или тип вариативного параметра, если индексируется вариативный параметр.

Так как индексация и конструктор вектора (\See{expr:vector-composite}) не всегда различимы синтаксически, выбор между ними происходит на уровне семантики, 
если выражение \verb|что-то|  обозначает тип, то это конструктор вектора, иначе индексация.

\hypertarget{conversion}{%
\subsection{Преобразование типа}\label{expr:conversion}}

Преобразование типа применяется к первичному выражению, и преобразует, если это возможно, значение выражения к \emph{целевому типу}, указанному в операции преобразования.

\begin{Grammar}
Преобразование: '(:' 'осторожно'? Указ-типа ')'
\end{Grammar}   

Если в преобразование есть ключевое слово \keyword{осторожно}, то это небезопасная операция, которая рассматривается отдельно (\See{unsafe:conversions}).

Часть преобразований, например, преобразования между числовыми типами и символами, а так же строковые преобразования могут изменить 
представление значения первичного выражения и повлечь за собой затраты на выполнение, а так же \emph{аварийное завершение}, если выполнить преобразование невозможно.

Преобразование классов изменяют только тип, но не представление значения.

\bigskip
Разрешенные преобразования:

\begin{tabular}[c]{p{2cm}|p{4.5cm}|p{4cm}}
\textbf{Целевой тип} & \textbf{Тип выражения} &  \textbf{Условие выполнения} \\ 
\hline
Байт & Цел64, Слово64, Символ, Строковый литерал длины 1 & значение в диапазоне 0..255 \\
\hline
\multirow{3}*{Цел64} & Байт, Символ, Строковый литерал длины 1 & всегда \\ 
 & Слово64 & значение в диапазоне 0..Max(Цел64) \\
 & Вещ64  & всегда \\
\hline
\multirow{2}*{Слово64} & Байт, Символ, Строковый литерал длины 1 & всегда \\
   & Цел64 & не отрицательное значение \\
\hline
Вещ64 & Цел64 & всегда \\
\hline
\multirow{2}*{Символ} &  Байт, Строковый литерал длины 1 & всегда \\
    & Цел64, Слово64 & значение в диапазоне Unicode символа \\
\hline
Строка & Символ, \verb+[]+Символ, \verb+[]+Байт & всегда \\
\hline
\verb+[]+Байт & Строка, Символ  & всегда \\
\hline
\verb+[]+Символ & Строка  & всегда \\
\hline
Класс & Класс & От базового класса к расширенному \\
\hline
\end{tabular}

\begin{Trivil}
тип Байты = []Байт
пусть байты = "Привет"(:Байты)

пусть три = pi(:Цел64)
\end{Trivil}

\hypertarget{call}{%
\subsection{Вызов функции или метода}\label{expr:call}}

\hypertarget{vector-composite}{%
\subsection{Конструктор вектора}\label{expr:vector-composite}}

\hypertarget{class-composite}{%
\subsection{Конструктор экземпляра класса}\label{expr:class-composite}}

\hypertarget{mb-ops}{%
\subsection{Операции для объектов может быть типа}\label{expr:mb-ops}}

\hypertarget{operators}{%
\subsection{Операции}\label{expr:operators}}

\hypertarget{const-expr}{%
\subsection{Константные выражения}\label{expr:const-expr}}