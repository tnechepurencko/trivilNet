\hypertarget{generic}{%
\section{Обобщенные модули}\label{generic:chapter}}

Практически все современные языки программирования содержат конструкции для определения обобщенных (generic) типов и функций.
Одна из важнейших областей применения обобщенных конструкций - библиотечная реализация полиморфных контейнеров: стек, очередь, деревья, словари (map). 

Как правило, семантика обобщенных типов и их реализации весьма нетривиальна, и тем самым не подходит для \thelang{}.

\bigskip
Для языка \thelang{} выбрано решение предельно простое во всех отношениях. 
Обобщение в нем сделано на уровне модулей, то есть только модуль целиком может быть обобщенным или, другими словами, параметризованным.
Причем, он может быть параметризован не только типом, а также любым языковым объектом, например, константой или функцией.

\emph{Обобщенный модуль} - это модуль, в котором опущено то определение (или определения), которым он параметризован. 
Другими словами - обобщенный модуль является недопределенным.

Рассмотрим, в качестве примера, обобщенный модуль Стек (полный текст см. "стд/контейнеры/стек"):
\begin{Trivil}[vspace=2pt]
модуль стек

тип Элементы = []Элемент

тип Стек* = класс {
    элементы = Элементы[] 
    верх: Цел64 := 0 // ... [0..верх[
}

фн (с: Стек) положить*(э: Элемент) {
    если с.верх = длина(с.элементы) {
        с.элементы.добавить(э)
    } иначе {
        с.элементы[с.верх] := э
    }
    с.верх++
}
/* другие методы */
\end{Trivil}

Тип элемента стека - это \emph{Элемент}, и этот тип не определен в самом модуле.

\bigskip
Для использования конкретного стека, например, стека целых чисел, необходимо определить \emph{настройку}. 
Настройка - отдельный модуль, в котором указан путь к обобщенному модулю и заданы параметры обобщенного модуля:
\begin{Trivil}[vspace=2pt]
настройка "стд/контейнеры/стек"
модуль стек-цел

тип Элемент = Цел64
\end{Trivil}

Настроенный модуль используется обычным образом. Например, если \verb+стек-цел+ размещен в папке \verb+"модули/стек-цел"+, то использование его выглядит так:
\begin{Trivil}[vspace=2pt]
модуль пример

импорт "модули/стек-цел"

вход { 
    пусть с = стек-цел.Стек{}
    с.положить(1)
}    
\end{Trivil}

Несколько настроек можно использовать одновременно, например, если модель стек настроен также на Строку:
\begin{Trivil}[vspace=2pt]
модуль пример

импорт "стд/вывод"
импорт "модули/стек-цел"
импорт "модули/стек-строк"

вход { 
    пусть с1 = стек-цел.Стек{}
    пусть с2 = стек-строк.Стек{}

    с1.положить(777)
    с2.положить("привет")
\end{Trivil}

\hypertarget{generic-impl}{%
\subsection{Последствия принятого решения}\label{generic:generic-impl}}

Сравнение подхода с другими известными подходами выходит за рамки описания языка. 
Замечу только, что главной причиной выбора такого подхода является тривиальность реализации и простота использования.

Прямым (и несколько непривычным) следствием подхода является то, что 
обобщенный модуль не может быть использован без настройки. 
Попытка импорта обобщенного модуля приведет к ошибкам компиляции.

Перед компиляцией компилятор соберет модуль, например, \verb+стек-цел+, из двух частей:
\begin{d_itemize}
\item
    из обобщенного модуля, в котором параметры не определены
\item
    и из модуля с настройкой, в котором параметры определены
\end{d_itemize}

Такой собранный модуль является полностью определенным, он компилируется обычным образом. 
Каждый настроенный модуль компилируется отдельно и для него строится отдельный код. 
Так код для \verb+стек-цел+ никак не связан с кодом для \verb+стек-строк+. 

Говоря в принятых терминах, \thelang{} использует \emph{мономорфизацию на уровне исходного текста}, 
тем самым получая оптимальный по скорости код за счет увеличения размера кода. 
Вся работа с обобщенными модулями происходит во время компиляции, во время исполнения все модули являются полностью определенными.

Замечу, что никаких синтаксических конструкций для ограничения параметров (constraints) в языке не предусмотрено, 
они накладываются неявно.
Например, если в обобщенном модуле использовать операцию \verb+<+, то настройка на арифметический тип будет работать, 
а настройка на тип, для которого эта операция не определена, приведет к ошибкам компиляции.


\hypertarget{refine-module}{%
\subsection{Уточненный синтаксис модуля}\label{generic:refine-module}}

Уточненный синтаксис модуля с добавлением опциональной настройки (исходное определение см. \See{mods:chapter}):
\begin{Grammar}[vspace=2pt]
Модуль: Исходный-файл+
Исходный-файл:
    ('настройка' Путь-импорта)?
    Заголовок-модуля
    Список-импорта
    Описание-или-вход*
\end{Grammar} 
