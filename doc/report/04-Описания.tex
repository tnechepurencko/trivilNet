\hypertarget{decls}{%
\section{Описания и области действия}\label{decls:chapter}}

Каждый идентификатор, встречающийся в программе, должен быть описан, если только это
не предопределенный идентификатор (\See{decls:predefined-idents}). 
Идентификатор может быть описан как тип, константа, переменная, функция или метод, 
а так же как параметр в сигнатуре функции или метода, и как поле в типе класса.

\begin{Grammar}
Описание
	: Описание-типов
	| Описание-констант
	| Описание-переменных
	| Описание-функций
	| Описание-метода
\end{Grammar} 

\hypertarget{scopes}{%
\subsection{Области действия}\label{decls:scopes}}

Описанный идентификатор используется для ссылки на связанный объект, в тех частях программы, которые попадают в \emph{область действия} описания. 
Идентификатор не может обозначать более одного объекта в пределах заданной области действия. 
Область действия может содержать внутри себя другие области действия, в которых идентификатор может быть переопределен.

Область действия, которая содержит в себе все исходные тексты на языке \thelang{} называется \emph{Универсум}.

Области действия:
\begin{d_itemize}
\item
Областью действия предопределенного идентификатора является Универсум
\item
Областью действия идентификатора, описанного на верхнем уровне (вне какой-либо функции), является весь модуль (\See{mods:chapter}).
\item
Областью действия идентификатора импортируемого модуля является файл (часть модуля), содержащего импорт (\See{mods:import}).
\item
Областью действия идентификатора, обозначающего параметр функции, является тело функции (\See{decls:functions}).
\item
Областью действия идентификатора, описанного в теле функции (\See{decls:functions}) или теле входа (\See{mods:entry}), является часть \emph{блока} (\See{stmt:blocks}), в котором описан идентификатор, от точки завершения описания и до завершения этого блока. 
\end{d_itemize}

В описании верхнего уровня за идентификатором может следовать признак экспорта \verb|'*'|, указывающий, что идентификатор \emph{экспортирован} и может использоваться в другом модуле, \emph{импортирующем} данный (\See{mods:import}). 

\bigskip
Правило для опционально экспортированного идентификатора:
\begin{Grammar}[vspace=2pt]
Идент-оп:  Идентификатор '*'?
\end{Grammar} 

\hypertarget{predefined-idents}{%
\subsection{Предопределенные идентификаторы}\label{decls:predefined-idents}}

Следующие идентификаторы неявно описаны в области действия \emph{Универсум}.
\bigskip

Типы (\See{decls:predefined-types}):
\begin{Verbatim}
    Байт Цел64 Слово64 Вещ64 Лог Символ Строка Строка8 Пусто
\end{Verbatim}

Константы типа Лог (\See{decls:predefined-types}):
\begin{Verbatim}
    ложь истина
\end{Verbatim}

Литерал, обозначающий отсутствие значения для \emph{может быть} типа (\See{decls:mb-types}):
\begin{Verbatim}
    пусто
\end{Verbatim}

Стандартные функции (\See{stdfuncs:std-funcs}):
\begin{Verbatim}
    длина тег нечто
\end{Verbatim}

Кроме того, для векторных типов определен набор встроенных методов (\See{stdfuncs:stdvector}).

\hypertarget{predefined-types}{%
\subsection{Предопределенные типы}\label{decls:predefined-types}}

Следующие типы обозначаются предопределенными идентификаторами, значениями данных типов являются:

\smallskip
\begin{tabular}[c]{l|l}
\textbf{Тип} & \textbf{Множество значений} \\ \hline
Байт &  множество целых чисел от 0 до 255   \\
Цел64 & множество всех 64-битных знаковых целых чисел \\
Слово64 & множество всех 64-битных беззнаковых целых чисел  \\ 
Вещ64 & множество всех 64-разрядных чисел с плавающей запятой стандарта IEEE-754 \\ 
Лог & константы \verb|ложь| и \verb|истина| \\ 
Символ & множество всех Unicode символов \\ 
Строка & множество всех строковых значений (\See{decls:string-type}) \\
Строка8 & множество всех строковых значений (\See{decls:string8-type}) \\
Пусто & литерал \verb+пусто+ \\
\end{tabular}

\bigskip
Операции над значениями этих типов определены в (\See{expr:unary-ops}, \See{expr:binary-ops}).

\hypertarget{string-type}{%
\subsubsection{Тип Строка}\label{decls:string-type}}

Строковый тип представляет собой набор строковых значений. Строковое значение - это (возможно, пустая) последовательность Unicode символов в кодировке UTF-8.
Количество символов называется длиной строки и никогда не бывает отрицательным. 
Строки неизменяемы: после создания изменить содержимое строки невозможно. 
Количество символов строки можно определить с помощью встроенной функции \verb+длина+ (\See{stdfuncs:stdlen}).

Операция индексации для строк не определена:
\begin{SampleErr}[vspace=2pt]
    пусть с = "привет"
    пусть сим = с[0] // ошибка
\end{SampleErr}

Для работы с байтами строки можно использовать тип Строка8 (\See{decls:string8-type}).

\hypertarget{string8-type}{%
\subsubsection{Тип Строка8}\label{decls:string8-type}}

Тип Строка8 введен для удобной и быстрой работы со строками в стандартных библиотеках. 
Единственным способом получения значения типа Строка8 является преобразование из строки. 
Это преобразование выполняется только во время компиляции.

\begin{Trivil}
пусть с8 = "Привет"(:Строка8)
\end{Trivil}

Значение типа Строка8 - это неизменяемая, индексируемая последовательность байтов.
Стандартная функция \verb+длина+ примененная к значению типа Строка8 возвращает число байтов.

\bigskip
Сравнение типов:

\bigskip
\begin{tabular}[c]{l|p{3.5cm}|p{3.5cm}}
& \textbf{Строка} & \textbf{Строка8}  \\ 
\hline
Определение &  последовательность символов & последовательность байтов \\
Индексация & нет & да \\
\verb+длина+(c) & число символов & число байтов \\
можно менять & нет & нет \\
\hline
\end{tabular}

\begin{Trivil}
пусть с = "Привет"
пусть с8 = с(:Строка8)

вывод.ф("%v\n", длина(с)) // выведет: 6
вывод.ф("%v\n", длина(с8)) // выведет: 12
вывод.ф("%v\n", с8[0]) // выведет: 0xD0
\end{Trivil}

Значение типа Строка8 неизменяемое, менять байты в нем нельзя:
\begin{SampleErr}[vspace=2pt]
    пусть с8 = "Привет"(:Строка8)
    с8[0] := 1 // ошибка
\end{SampleErr}

\hypertarget{type-ref}{%
\subsection{Указание типа}\label{decls:type-ref}}

\thelang{} является языком со статической типизацией, что означает, что тип любого объекта языка явно или неявно указывается во время описания объекта. 
Неявное указание типа может быть использовано в описании констант (\See{decls:constants}), переменных (\See{decls:constants}) и полей класса (\See{decls:class-types}).

Для явного указании типа используется имя типа, перед которым может стоять ключевое слово \keyword{мб} (\emph{может быть}). 

\begin{Grammar}
Указ-типа: 'мб'? Имя-типа 
Имя-типа: Идентификатор | Импорт-идент
Импорт-идент: Идентификатор '.' Идентификатор
\end{Grammar} 

Если в качестве имени типа используется \emph{Импорт-идент}, то первый идентификатор в нем должен обозначать имя импортированного модуля (\See{mods:import}), а второй идентификатор должен быть идентификатором экспортированного из этого модуля объекта, в данном контексте - идентификатор типа.

Множество значений объекта с типом \keyword{мб} T состоит из значения, обозначенного предопределенным идентификатором  \keyword{пусто} и значений типа Т. 
Тип такого объекта называется \emph{может быть Т} (\See{decls:mb-types}). 

\hypertarget{constants}{%
\subsection{Описание констант}\label{decls:constants}}

Описание константы связывает идентификатор с постоянным значением. 
Значение константы может быть задано явно или неявно, в случае группового описания констант.

\begin{Grammar}
Описание-констант: 'конст' (Константа | Группа-констант)
Константа: Идент-оп (':' Указ-типа)? '=' Выражение
\end{Grammar} 

Если тип константы не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).
Выражение для константы должно быть константным выражением (\See{expr:const-expr}).

\begin{Trivil}
конст к1: Цел64 = 1 // тип Цел64
конст к2: Байт = 2 // тип Байт
конст к3 = 3 // тип Цел64
конст к4 = "Привет" // тип Строка
\end{Trivil}

Групповое описание констант позволяет опускать тип и выражение для всех констант, кроме первой константы в группе и указать признак экспорт для всех констант группы.

\begin{Grammar}
Группа-констант: 
    '*'? '(' 
    Константа (Разделитель След-константа)* 
    ')'
След-константа: Идент-оп ((':' Указ-типа)? '=' Выражение)?
\end{Grammar} 

Пример группового экспорта:
\begin{Trivil}[vspace=2pt]
конст *(
    Счетчик = 1
    Имя = "Вася"
)
\end{Trivil}

Пример неявного задания значения для констант:
\begin{Trivil}[vspace=2pt]
конст ( 
    / / операции
    ПЛЮС = 1   // тип Цел64, значение = 1
    МИНУС       // тип Цел64, значение = 2  
    ОСТАТОК   // тип Цел64, значение = 3 
    // ключевые слова
    ЕСЛИ = 21   // тип Цел64, значение = 21
    ИНАЧЕ        // тип Цел64, значение = 22
    ПОКА          // тип Цел64, значение = 23
)
\end{Trivil}


\hypertarget{variables}{%
\subsection{Описание переменных}\label{decls:variables}}

Описание переменной создает переменную, привязывает к ней идентификатор и указывает её тип и начальное значение через \emph{Инициализацию}. 

\begin{Grammar}
Описание-переменной: 
    'пусть' Идент-оп (':' Указ-типа)? Инициализация
Инициализация: (':=' | '=') ('позже' | Выражение)
\end{Grammar} 

Если тип переменной не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).

Каждая переменная должна быть явно проинициализирована.
Если инициализация задана через лексему '=', то значениe переменной не может быть изменено (\emph{переменная с единственным присваиванием}), 
если же в инициализации используется лексема ':=', то значение может быть изменено (\See{stmt:assignment}, \See{stmt:inc-dec}), а переменная называется \emph{изменяемой}.

Явное указание типа:
\begin{Trivil}[vspace=2pt]
пусть ц1: Цел64 = 1 
пусть ц2: Цел64 := 2
\end{Trivil}

Неявное указание типа:
\begin{Trivil}[vspace=2pt]
пусть ц3 = 3   // неявное указание типа
пусть ц4 := 4
пусть имя = Имя языка() 
\end{Trivil}

Компилятор выдает ошибку, при попытке изменить значение переменной с единственным присваиванием:
\begin{SampleErr}[vspace=2pt]
    ц1 := 2 
    ц3++
    имя := "С++"
\end{SampleErr}

Если в инициализации задано \emph{Выражение}, то начальным значение переменной является значение выражения.
Если при этом тип переменной явно задан, то выражение должно быть \emph{совместимо по присваиванию} с типом переменной (\See{compat:assign}).

Вместо выражения может быть указано ключевое слово \keyword{позже}, это \emph{поздняя инициализация}. 
Такая форма инициализации разрешена только для переменных уровня модуля, при этом тип таких переменных, должен быть явно указан.

Значение переменной с поздней инициализацией должно быть задано в инициализации модуля (\See{mods:entry}). 
Текущая реализация компилятора запрещает позднюю инициализацию для переменных с единственным присваиванием.

\hypertarget{types}{%
\subsection{Описание типов}\label{decls:types}}

Описание типа связывает идентификатор с новым или существующим типом.

\begin{Grammar}
Описание-типа: 
    'тип' Идент '=' 
    ( Тип-вектора 
    | Тип-класса
    | Указ-типа
    )
\end{Grammar} 

Если в описание типа указан тип вектора (\See{decls:vector-types}) или тип класса (\See{decls:class-types}), то создается новый тип и определяется структура данных этого типа, и, как следствие, набор операций над данными этого типа.

Если в описании типа стоит указание на тип (\See{decls:type-ref}), 
то это определение еще одного имени для уже существующего типа 
или задание имени для \emph{типа вектора} (\See{decls:vector-types}) или \emph{может быть типа} (\See{decls:mb-types}). 

\begin{Trivil}
тип Цел = Цел64
тип Текст= []Строка
тип Строка? = мб Строка
\end{Trivil}

Так как указание типа не создает новый тип, использование типа \verb+Цел+ из примера идентично использованию типа \verb+Цел64+.

\hypertarget{vector-types}{%
\subsection{Тип вектора}\label{decls:vector-types}}

Вектор - это пронумерованная последовательность элементов одного типа, называемая типом элемента. Количество элементов называется длиной вектора, длина не может быть отрицательной. Элементы вектора доступны через операцию индексации (\See{expr:indexation}). Для индексации вектора используются целочисленные индексы  от 0 до длина-1. Векторы всегда одномерны, но типом элемента может быть вектор, там самым формируя многомерную структуру.

\begin{Grammar}
Тип-вектора: '[' ']'  Указ-типа
\end{Grammar} 

\begin{Trivil}
тип Байты = []Байт
тип Матрица = [][]Вещ64
\end{Trivil}

Длина вектора может изменятся во время выполнения, другими словами, вектор - это \emph{динамический массив}. Для получения текущей длины вектора используется стандартная функция \verb|длина| (\See{stdfuncs:stdlen}).
Начальное значение для объекта типа вектор задается с помощью конструктора вектора (\See{expr:vector-composite}). Далее, длину вектора можно поменять с помощью стандартных методов (\See{stdfuncs:stdvector}).

Пример инициализации вектора из трех элементов:
\begin{Trivil}[vspace=2pt]
пусть байты = Байты[1, 2, 3]
\end{Trivil}

\hypertarget{class-types}{%
\subsection{Тип класса}\label{decls:class-types}}

Тип класса - это структура, состоящая из полей. С типом класса могут быть связаны функции, называемые методами (\See{decls:methods}).

Описание класса состоит из опционального указания базового класса и списка полей. 
Если базовый класс указан, то класс \emph{наследует} поля и методы базового класса (\See{decls:inheritance}). 

Для каждого поля в списке задается идентификатор, тип (явно или неявно) и начальное значение.
Областью действия идентификаторов полей является само описание класса, но они могут быть доступны в операции доступа к полям и методам (\See{expr:selector}).

\begin{Grammar}
Тип-класса:  'класс' Базовый-класс? '{' Список-полей? '}'
Базовый-класс: '(' Указ-типа ')'
Список-полей: Поле (Разделитель Поле)*
Поле: Идент-оп (':' Указ-типа)? Инициализация
\end{Grammar} 

\begin{Trivil}
тип Человек = класс {
    имя: Строка := ""
    возраст: Цел64 := 0
}
\end{Trivil}

Если тип поля не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).

\hypertarget{fields-init}{%
\subsubsection{Инициализация полей}\label{decls:fields-init}}

Каждое поле класса должно быть явно проинициализировано.
Если инициализация задана через лексему '=', то значениe поля не может быть изменено (\emph{поле с единственным присваиванием}), 
если же в инициализации используется лексема ':=', то значение поля может быть изменено  (\See{stmt:assignment}, \See{stmt:inc-dec}), а поле называется \emph{изменяемым}.

Если в инициализации задано \emph{Выражение}, то начальным значение поля является значение выражения.
Если при этом тип поля явно задан, то выражение должно быть \emph{совместимо по присваиванию} с типом поля (\See{compat:assign}).

Вместо выражения может быть указано ключевое слово \keyword{позже}, это \emph{поздняя инициализация}. 
Такая форма инициализации разрешена только для полей, тип которых явно указан.

Значение поля с поздней инициализацией должно быть задано при создании экземпляра класса в конструкторе экземпляра класса (\See{expr:class-composite}). 

\hypertarget{exported-fields}{%
\subsubsection{Экспорт полей}\label{decls:exported-fields}}

Если тип класса экспортируется, его поля могут быть помечены признаком экспорта, такие поля называется \emph{экспортированными полями}.
Поля, которые не экспортированы, доступны только в том модуле, в котором описан тип класса.

\hypertarget{inheritance}{%
\subsubsection{Наследование}\label{decls:inheritance}}

Наследование позволяет определить новый (\emph{расширенный}) класс  на основе существующего (\emph{базового}) класса. 

\begin{Trivil}
тип Работник = класс (Человек) {
    зарплата := 0.0
}
\end{Trivil}

Базовый класс \emph{Человек}, указанный в описании класса \emph{Работник}, называется \emph{прямым базовым классом}. 
Так как \emph{Человек} может быть, в свою очередь, расширением другого базового класса, для каждого класса определен список базовых классов, возможно, пустой.
Термин \emph{базовый класс} будет использовать для обозначения любого класса из этого списка. Циклы в списке базовых классов запрещены.

Расширенный класс наследует поля и методы базового класса и может добавлять новые поля и методы.
Обращение к полям и методам базового класса ничем не отличается от обращения к полям и методам самого класса. 
Методы базового класса можно переопределять, сохраняя те же самые типы параметра и тип результата (See{compat:equal-types}).

\hypertarget{mb-types}{%
\subsection{Может быть тип}\label{decls:mb-types}}

Как правило, современные языки программирования ограничивают работу со объектами ссылочных (\emph{reference}) типов для того, 
чтобы сделать явными все места в программе, в которых может возникнуть ошибка использования нулевой ссылки (\emph{null pointer exception}). 
Так как русская терминология в этой области не устоялась, приходится обращаться к англоязычным терминам.

Язык \thelang{} следует уже выработанному в современных языках программированию подходу (но не синтаксису):
\begin{d_itemize}
\item
    Если в указании типа объекта использована нотация \emph{\keyword{мб} Т}, где \emph{Т} - это некоторый ссылочный тип,  
    то значением этого объекта, кроме значений типа \emph{Т}, может быть специальное значение 'пусто'. Тип такого объекта называется \emph{может быть Т}. Тип \emph{Т} называется \emph{базовым типом}.
\item
    Иначе, если ключевое слово \keyword{мб} отсутствует в указании типа объекта, значением этого объекта может быть только значений типа \emph{Т}.
\end{d_itemize}

Ссылочными типами являются Строка, типы вектора и типы класса, к остальным типам \keyword{мб} не может применятся.

Для объекта типа \emph{мб Т} определены следующие действия:
\begin{d_itemize}
\item
    Присваивание объекту значения 'пусто' или значения типа Т (\See{compat:assign})
\item
    Сравнение на равно/не равно с 'пусто'  или с другим объектом типа \emph{мб Т} (\See{expr:ops-comparison})
\item
    Операция подтверждения типа \verb+'^'+ (\See{expr:confirmation}), позволяющая перейти от значения типа \emph{мб Т} к значению типа \emph{Т}
\end{d_itemize}

\bigskip
Пример указания типа и использования объекта:
\begin{Trivil}[vspace=2pt]
пусть кличка: мб Строка := пусто
...
если кличка # пусто { вывод.ф("%v\n", кличка^}
\end{Trivil}


\hypertarget{functions}{%
\subsection{Описание функций}\label{decls:functions}}

Описание функции состоит из идентификатора, сигнатуры  и тела функции. 
Сигнатура определяет формальные параметры и тип результата (если таковой имеется). 
Особым видом функции является метод, см. \See{decls:methods}.

\begin{Grammar}
Описание-функции: 'фн' Идент-оп Сигнатура Тело
Сигнатура: '(' Список-параметров? ')' Тип-результата?
Тип-результата: ':' ('*' | Указ-типа)
Тело: (Блок | Модификатор)?
\end{Grammar} 

Вместо тела функции может стоять модификтор (\See{lex:modifiers}) \verb|@внеш|, см. \See{decls:extern-fn}.

Если у функции задан тип результата, тело функции должно завершаться операторами \keyword{вернуть} (\See{stmt:return-stmt}) или \keyword{авария} (\See{stmt:crash-stmt}). 

Если в типе результата вместо указания типа использован символ \verb|'*'|, то функция возвращает полиморфный результат.
Такая функция может возвращать значение любого типа.
Для работы с полиморфным значением определены специальные стандартные функции (\See{stdfuncs:stdpoly}).

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 {
    если ц <= 1 { вернуть 1 }
    вернуть ц * Факториал(ц - 1)
}
\end{Trivil}

\hypertarget{params}{%
\subsubsection{Параметры}\label{decls:params}}

Формальные параметры - это идентификаторы, которые обозначают \emph{аргументы} (фактические параметры), указанные при вызове функции (\See{expr:call}).

\begin{Grammar}
Список-параметров: Параметр (',' Параметр)* ','?
Параметр: 
    Идентификатор (':' | ':=') '...'? ('*' | Указ-типа)  
\end{Grammar} 

Параметры бывают двух видов: \emph{входные} и \emph{выходные} параметры. 
Вид параметра задается символом после идентификатора, 
задающего имя параметра. Для входных параметров это символ ':', для выходных - символ ':='. 
Выходной параметр, в более привычной терминологии,
является \emph{in out} параметром. 

Аргументом для входного параметра должно быть выражение, тип которого совместим по присваиванию с типом параметра. 
Аргументом для выходного параметра должно быть \emph{изменяемое выражение} (\See{stmt:assignment}), 
тип которого эквивалентен типу параметра. 

В теле функции, входной параметр имеет значение, которое передается в функцию, 
изменяется функцией и передается обратно из функции для замены исходного значения.


\begin{Trivil}
фн извлечь число(стр: Строка, число:= Цел64): Лог {...}

пусть рез := 0
если ~ извлечь число(с, рез) {
    вывод.ф("не удалось извлечь число")
}
\end{Trivil}

Последний параметр функции может иметь тип с префиксом \verb|...| - это \emph{вариативный параметр}. Функция с таким параметром может быть вызвана с нулем или более аргументов для этого параметра. Если тип вариативного параметра указан как \emph{Т}, то в теле функции типом  параметра является \verb+[]T+.

\begin{Trivil}
фн сумма(числа: ...Цел64): Цел64 {...}

// В вызове можно указать любое число аргументов
ответ := сумма() // без аргументов
ответ := сумма(1, 2, 3) //  три аргумента
\end{Trivil}

\hypertarget{params-poly}{%
\subsubsection{Полиморфные параметры}\label{decls:params-poly}}

Если вместо типа параметра указан символ \verb|'*'|, то параметр называется полиморфным.
Аргумент, соотвествующий этому параметру, может быть выражением любого типа. 
Для вариативного полиморфного параметра каждый аргумент может быть выражением любого типа. 
Для работы с полиморфным параметром определены специальные стандартные функции (\See{stdfuncs:stdpoly}).

\begin{Trivil}
фн печать по формату(формат: Строка, аргументы: ...*) {
...
}
\end{Trivil}

\hypertarget{extern-fn}{%
\subsubsection{Внешние функции}\label{decls:extern-fn}}

Функция, в которой вместо тела стоит модификатор \verb|@внеш|, является \emph{внешней функцией}, то есть реализованной каким-то внешним способом.
Атрибут "имя"\space  модификатора задает внешнее имя функции.

\begin{Trivil}
фн строка(с: Строка) @внеш("имя":"print_string")
\end{Trivil}

Если атрибут "имя"\space не задан, внешнее имя совпадает с идентификатором функции.

\hypertarget{methods}{%
\subsection{Описание методов}\label{decls:methods}}

Метод - это функция, связанная с типом классом. Для вызова метода (\See{expr:call}) должен быть указан экземпляр этого класса или расширенного класса. 
В описание метода класс, с которым связан метод указывается с помощью \emph{Привязки}.

\begin{Grammar}
Описание-метода: 'фн' Привязка Идент-оп Сигнатура Блок
Привязка: '(' Идентификатор ':' Указ-типа ')'
\end{Grammar} 

Привязка определяет идентификатор и тип, который должен быть типом класса. В теле функции идентификатор привязки является параметром указанного типа.

\begin{Trivil}
тип К = класс {}

фн (к: К) метод() {}
\end{Trivil}

Идентификатор метода должен быть уникальным в классе среди идентификатором полей и методов. 

В расширенном классе может быть определен метод с таким же идентификатором как в одном из базовых классов.

\emph{переопределен}, то есть опеределен другой метод . При этом сигнатура переопределеного метода должна совпадать с сигнатуром переопределяемого метода, а именно:
\begin{d_itemize}
\item
    Число параметров должно совпадать
\item
    Типы  результата должны быть равны \See{compat:equal-types}
\item
    Типы  параметров должны быть равны \See{compat:equal-types}
\item 
    Признаки вариативности и полиморфности для каждого параметра должны совпадать
\end{d_itemize}

Пример ошибки при переопределении метода (разное число параметров):
\begin{SampleErr}[vspace=2pt]
тип К1 = класс (К) {}

фн (к: К1) метод(с: Строка) {}
\end{SampleErr}