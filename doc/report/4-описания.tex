\hypertarget{decls}{%
\section{Описания и области действия}\label{decls:chapter}}

Каждый идентификатор, встречающийся в программе, должен быть описан, если только это
не предопределенный идентификатор (\See{decls:predefined-idents}). 
Идентификатор может быть описан как тип, константа, переменная, функция или метод, 
а так же как параметр в сигнатуре функции или метода, и как поле в типе класса.

\begin{Grammar}
Описание
	: Описание-типов
	| Описание-констант
	| Описание-переменных
	| Описание-функций
	| Описание-метода
\end{Grammar} 

\hypertarget{scopes}{%
\subsection{Области действия}\label{decls:scopes}}

Описанный идентификатор используется для ссылки на связанный объект, в тех частях программы, которые попадают в \emph{область действия} описания. 
Идентификатор не может обозначать более одного объекта в пределах заданной области действия. 
Область действия может содержать внутри себя другие области действия, в которых идентификатор может быть переопределен.

Область действия, которая содержит в себе все исходные тексты на языке \thelang{} называется \emph{Универсум}.

Области действия:
\begin{d_itemize}
\item
Областью действия предопределенного идентификатора является Универсум
\item
Областью действия идентификатора, описанного на верхнем уровне (вне какой-либо функции), является весь модуль (\See{mods:chapter}).
\item
Областью действия идентификатора импортируемого модуля является файл (часть модуля), содержащего импорт (\See{mods:import}).
\item
Областью действия идентификатора, обозначающего параметр функции, является тело функции (\See{decls:functions}).
\item
Областью действия идентификатора, описанного в теле функции (\See{decls:functions}) или теле входа (\See{mods:entry}), является часть \emph{блока} (\See{stmt:blocks}), в котором описан идентификатор, от точки завершения описания и до завершения этого блока. 
\end{d_itemize}

В описании верхнего уровня за идентификатором может следовать признак экспорта \verb|'*'|, указывающий, что идентификатор \emph{экспортирован} и может использоваться в другом модуле, \emph{импортирующем} данный (\See{mods:import}). 

\bigskip
Правило для опционально экспортированного идентификатора:
\begin{Grammar}[vspace=2pt]
Идент-оп:  Идентификатор '*'?
\end{Grammar} 

\hypertarget{predefined-idents}{%
\subsection{Предопределенные идентификаторы}\label{decls:predefined-idents}}

Следующие идентификаторы неявно описаны в области действия \emph{Универсум}.
\bigskip

Типы (\See{decls:predefined-types}):
\begin{Verbatim}
    Байт Цел64 Слово64 Вещ64 Лог Символ Строка
\end{Verbatim}

Константы типа Лог (\See{decls:predefined-types}):
\begin{Verbatim}
    ложь истина
\end{Verbatim}

Литерал nullable (\See{decls:mb-types}):
\begin{Verbatim}
    пусто
\end{Verbatim}

Стандартные функции (\See{stdfuncs:chapter}):
\begin{Verbatim}
    длина тег нечто
\end{Verbatim}

Кроме того, для векторных типов определен набор встроенных методов (\See{stdfuncs:stdvector}).

\hypertarget{predefined-types}{%
\subsection{Предопределенные типы}\label{decls:predefined-types}}

Следующие типы обозначаются предопределенными идентификаторами, значениями данных типов являются:

\smallskip
\begin{tabular}[c]{l|l}
\textbf{Тип} & \textbf{Множество значений} \\ \hline
Байт &  множество целых числа от 0 до 255   \\
Цел64 & множество всех 64-битных знаковых целых чисел \\
Слово64 & множество всех 64-битных беззнаковых целых чисел  \\ 
Вещ64 & множество всех 64-разрядных чисел с плавающей запятой стандарта IEEE-754 \\ 
Лог & константы \verb|ложь| и \verb|истина| \\ 
Символ & множество всех Unicode символов \\ 
Строка & множество всех строковых литералов
\end{tabular}

\bigskip
Операции над значениями этих типов определены в (\See{expr:operators}).

\hypertarget{type-ref}{%
\subsection{Указание типа}\label{decls:type-ref}}

\thelang{} является языком со статической типизацией, что означает, что тип любого объекта языка явно или неявно указывается во время описания объекта. 
Неявное указание типа может быть использовано в описании констант (\See{decls:constants}), переменных (\See{decls:constants}) и полей класса (\See{decls:class-types}).

Для явного указании типа используется имя типа, перед которым может стоять ключевое слово \keyword{мб} (\emph{может быть}). 

\begin{Grammar}
Указ-типа: 'мб'? Имя-типа 
Имя-типа: Идентификатор | Импорт-идент
Импорт-идент: Идентификатор '.' Идентификатор
\end{Grammar} 

Если в качестве имени типа используется \emph{Импорт-идент}, то первый идентификатор в нем должен обозначать имя импортированного модуля (\See{mods:import}), а второй идентификатор должен быть идентификатором экспортированного из этого модуля объекта, в данном контексте - идентификатор типа.

Множество значений объекта с типом \keyword{мб} T состоит из значения, обозначенного предопределенным идентификатором  \keyword{пусто} и значений типа Т. 
Тип такого объекта называется \emph{может быть Т} (\See{decls:mb-types}). 

\hypertarget{constants}{%
\subsection{Описание констант}\label{decls:constants}}

Описание константы связывает идентификатор с постоянным значением. 
Значение константы может быть задано явно или неявно, в случае группового описания констант.

\begin{Grammar}
Описание-констант: 'конст' (Константа | Группа-констант)
Константа: Идент-оп (':' Указ-типа)? '=' Выражение
\end{Grammar} 

Если тип константы не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).
Выражение для константы должно быть константным выражением (\See{expr:const-expr}).

\begin{Trivil}
конст к1: Цел64 = 1 // тип Цел64
конст к2: Байт = 2 // тип Байт
конст к3 = 3 // тип Цел64
конст к4 = "Привет" // тип Строка
\end{Trivil}

Групповое описание констант позволяет опускать тип и выражение для всех констант, кроме первой константы в группе и указать признак экспорт для всех констант группы.

\begin{Grammar}
Группа-констант: 
    '*'? '(' 
    Константа (Разделитель След-константа)* 
    ')'
След-константа: Идент-оп ((':' Указ-типа)? '=' Выражение)?
\end{Grammar} 

Пример группового экспорта:
\begin{Trivil}[vspace=2pt]
конст *(
    Счетчик = 1
    Имя = "Вася"
)
\end{Trivil}

Пример неявного задания значения для констант:
\begin{Trivil}[vspace=2pt]
конст ( 
    / / операции
    ПЛЮС = 1   // тип Цел64, значение = 1
    МИНУС       // тип Цел64, значение = 2  
    ОСТАТОК   // тип Цел64, значение = 3 
    // ключевые слова
    ЕСЛИ = 21   // тип Цел64, значение = 21
    ИНАЧЕ        // тип Цел64, значение = 22
    ПОКА          // тип Цел64, значение = 23
)
\end{Trivil}


\hypertarget{variables}{%
\subsection{Описание переменных}\label{decls:variables}}

Описание переменной создает переменную, привязывает к ней идентификатор и указывает её тип и начальное значение через \emph{Инициализацию}. 

\begin{Grammar}
Описание-переменной: 
    'пусть' Идент-оп (':' Указ-типа)? Инициализация
Инициализация: (':=' | '=') ('позже' | Выражение)
\end{Grammar} 

Если тип переменной не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).

Каждая переменная должна быть явно проинициализирована.
Если инициализация задана через лексему '=', то значениe переменной не может быть изменено (\emph{переменная с единственным присваиванием}), 
если же в инициализации используется лексема ':=', то значение может быть изменено (\See{stmt:assignment}, \See{stmt:inc-dec}).

Явное указание типа:
\begin{Trivil}[vspace=2pt]
пусть ц1: Цел64 = 1 
пусть ц2: Цел64 := 2
\end{Trivil}

Неявное указание типа:
\begin{Trivil}[vspace=2pt]
пусть ц3 = 3   // неявное указание типа
пусть ц4 := 4
пусть имя = Имя языка() 
\end{Trivil}

Компилятор выдает ошибку, при попытке изменить значение переменной с единственным присваиванием:
\begin{SampleErr}[vspace=2pt]
    ц1 := 2 
    ц3++
    имя := "С++"
\end{SampleErr}

Если в инициализации задано \emph{Выражение}, то начальным значение переменной является значение выражения.
Вместо выражения может быть указано ключевое слово \keyword{позже}, это \emph{поздняя инициализация}. 
Такая форма инициализации разрешена только для переменных уровня модуля, при этом тип таких переменных, должен быть явно указан.

Значение переменной с поздней инициализацией должно быть задано в инициализации модуля (\See{mods:entry}). 
Текущая реализация компилятора запрещает позднюю инициализацию для переменных с единственным присваиванием.

\hypertarget{types}{%
\subsection{Описание типов}\label{decls:types}}

Описание типа связывает идентификатор с новым типом, который определяет структуру данных этого типа, и, как следствие, набор операций над данными этого типа.

\begin{Grammar}
Описание-типа: 'тип' Идент '=' (Тип-вектора | Тип-класса)
\end{Grammar} 

В текущей версии языка поддерживают два структурных типа: тип вектора (\See{decls:vector-types}) и тип класса (\See{decls:class-types}).

\hypertarget{vector-types}{%
\subsection{Тип вектора}\label{decls:vector-types}}

Вектор - это пронумерованная последовательность элементов одного типа, называемая типом элемента. Количество элементов называется длиной вектора, длина не может быть отрицательной. Элементы вектора доступны через операцию индексации (\See{expr:indexation}). Для индексации вектора используются целочисленные индексы  от 0 до длина-1. Векторы всегда одномерны, но типом элемента может быть вектор, там самым формируя многомерную структуру.

\begin{Grammar}
Тип-вектора: '[' ']'  Указ-типа
\end{Grammar} 

\begin{Trivil}
тип Байты = []Байт
тип Матрица = [][]Вещ64
\end{Trivil}

Длина вектора может изменятся во время выполнения, другими словами, вектор - это \emph{динамический массив}. Для получения текущей длины вектора используется стандартная функция \verb|длина| (\See{stdfuncs:stdlen}).
Начальное значение для объекта типа вектор задается с помощью конструктора вектора (\See{expr:vector-composite}). Далее, длину вектора можно поменять с помощью стандартных методов (\See{stdfuncs:stdvector}).

Пример инициализации вектора из трех элементов:
\begin{Trivil}[vspace=2pt]
пусть байты = Байты[1, 2, 3]
\end{Trivil}

\hypertarget{class-types}{%
\subsection{Тип класса}\label{decls:class-types}}

Тип класса - это структура, состоящая из полей. С типом класса могут быть связаны функции, называемые методами (\See{decls:methods}).

Описание класса состоит из опционального указания базового класса и списка полей. 
Если базовый класс указан, то класс \emph{наследует} поля и методы базового класса (\See{decls:inheritance}). 

Для каждого поля в списке задается идентификатор, тип (явно или неявно) и начальное значение.
Областью действия идентификаторов полей является само описание класса, но они могут быть доступны в операции доступа к полям и методам (\See{expr:selector}).

\begin{Grammar}
Тип-класса:  'класс' Базовый-класс? '{' Список-полей? '}'
Базовый-класс: '(' Указ-типа ')'
Список-полей: Поле (Разделитель Поле)*
Поле: Идент-оп (':' Указ-типа)? Инициализация
\end{Grammar} 

\begin{Trivil}
тип Человек = класс {
    имя: Строка := ""
    возраст: Цел64 := 0
}
\end{Trivil}

Если тип поля не указан, то он устанавливается равным типу выражения (\See{expr:chapter}).

Каждое поле класса должно быть явно проинициализировано.
Если инициализация задана через лексему '=', то значениe поля не может быть изменено (\emph{поле с единственным присваиванием}), 
если же в инициализации используется лексема ':=', то значение поля может быть изменено  (\See{stmt:assignment}, \See{stmt:inc-dec}).

Если в инициализации задано \emph{Выражение}, то начальным значение поля является значение выражения.
Вместо выражения может быть указано ключевое слово \keyword{позже}, это \emph{поздняя инициализация}. 
Такая форма инициализации разрешена только для полей, тип которых явно указан.

Значение поля с поздней инициализацией должно быть задано при создании экземпляра класса в конструкторе экземпляра класса (\See{expr:class-composite}). 

\hypertarget{exported-fields}{%
\subsubsection{Экспорт полей}\label{decls:exported-fields}}

Если тип класса экспортируется, его поля могут быть помечены признаком экспорта, такие поля называется \emph{экспортированными полями}.
Поля, которые не экспортированы, доступны только в том модуле, в котором описан тип класса.

\hypertarget{inheritance}{%
\subsubsection{Наследование}\label{decls:inheritance}}

Наследование позволяет определить новый (\emph{расширенный}) класс  на основе существующего (\emph{базового}) класса. 

Базовый класс \emph{Б}, указанный в описании класса \emph{К}, называется \emph{прямым базовым классом}. 
Так как \emph{Б} может быть, в свою очередь, расширением другого базового класса, для каждого класса определен список базовых классов, возможно, пустой.
Термин \emph{базовый класс} будет использовать для обозначения любого класса из этого списка. Циклы в списке базовых классов запрещены.

Расширенный класс наследует поля и методы базового класса и может добавлять новые поля и методы.
Обращение к полям и методам базового класса ничем не отличается от обращения к полям и методам самого класса. 
Методы базового класса можно переопределять, сохраняя те же самые типы параметра и тип результата.

\hypertarget{mb-types}{%
\subsection{Может быть тип}\label{decls:mb-types}}

Как правило, современные языки программирования ограничивают работу со объектами ссылочных (\emph{reference}) типов для того, 
чтобы сделать явными все места в программе, в которых может возникнуть ошибка использования нулевой ссылки (\emph{null pointer exception}). 
Так как русская терминология в этой области не устоялась, приходится обращаться к англоязычным терминам.

Язык \thelang{} следует уже выработанному в современных языках программированию подходу (но не синтаксису):
\begin{d_itemize}
\item
    Если в указании типа объекта использована нотация \emph{\keyword{мб} Т}, где \emph{Т} - это некоторый ссылочный тип,  
    то значением этого объекта, кроме значений типа \emph{Т}, может быть специальное значение 'пусто'. Тип такого объекта называется \emph{может быть Т}.
\item
    Иначе, если ключевое слово \keyword{мб} отсутствует в указании типа объекта, значением этого объекта может быть только значений типа \emph{Т}.
\end{d_itemize}

Ссылочными типами являются Строка, типы вектора и типы класса, к остальным типам \keyword{мб} не может применятся.

Для объекта типа \emph{мб Т} определены следующие действия:
\begin{d_itemize}
\item
    Присваивание объекту значения 'пусто' или значения типа Т
\item
    Сравнение на равно/не равно с 'пусто'  или с другим объектом типа \emph{мб Т}
\item
    Операция \verb+'^'+ перехода от значения типа \emph{мб Т} к значению типа \emph{Т}
\end{d_itemize}
Подробнее в  \See{expr:mb-ops}, \See{compat:assign}.

\bigskip
Пример указания типа и использования объекта:
\begin{Trivil}[vspace=2pt]
пусть кличка: мб Строка := пусто
...
если кличка # пусто { вывод.ф("%v\n", кличка^}
\end{Trivil}


\hypertarget{functions}{%
\subsection{Описание функций}\label{decls:functions}}

Описание функции состоит из идентификатора, сигнатуры  и тела функции. 
Сигнатура определяет формальные параметры и тип результата (если таковой имеется). 
Особым видом функции является метод, см. \See{decls:methods}.

\begin{Grammar}
Описание-функции: 'фн' Идент-оп Сигнатура Тело
Сигнатура: '(' Список-параметров? ')' Тип-результата?
Список-параметров: Параметр (',' Параметр)* ','?
Параметр: Идентификатор ':' '...'? ('*' | Указ-типа)  
Тело: (Блок | Модификатор)?
\end{Grammar} 

Вместо тела функции может стоять модификтор (\See{lex:modifiers}) \verb|@внеш|, см. \See{decls:extern-fn}.

Если у функции задан тип результата, тело функции должно завершаться операторами \keyword{вернуть} (\See{stmt:return}) или \keyword{авария} (\See{stmt:crash}).

\begin{Trivil}
фн Факториал(ц: Цел64): Цел64 {
    если ц <= 1 { вернуть 1 }
    вернуть ц * Факториал(ц - 1)
}
\end{Trivil}

\hypertarget{params}{%
\subsubsection{Параметры}\label{decls:params}}

Формальные параметры - это идентификаторы, которые обозначают \emph{аргументы} (фактические параметры), указанные при вызове функции (\See{expr:call}).

\begin{Grammar}
Параметр: Идентификатор ':' '...'? ('*' | Указ-типа)  
\end{Grammar} 

Последний параметр функции может иметь тип с префиксом \verb|...| - это \emph{вариативный параметр}. Функция с таким параметром может быть вызвана с нулем или более аргументов для этого параметра. Если тип вариативного парметра указан как \emph{Т}, то в теле функции типом  параметра является \verb+[]T+.

Если вместо типа параметра указан символ \verb|'*'|, то параметр называется полиморфным.
Аргумент, соотвествующий этому параметру, может быть выражением любого типа. 
Для вариативного полиморфного параметра каждый аргумент может быть выражением любого типа. 
Для работы с полиморфным параметром определены специальные стандартные функции (\See{stdfuncs:stdpoly}).

\begin{Trivil}
фн печать по формату(формат: Строка, аргументы: ...*) {
...
}
\end{Trivil}

\hypertarget{extern-fn}{%
\subsubsection{Внешние функции}\label{decls:extern-fn}}

Функция, в которой вместо тела стоит модификатор \verb|@внеш|, является \emph{внешней функцией}, то есть реализованной каким-то внешним способом.
Атрибут "имя" модификатора задает внешнее имя функции.

\begin{Trivil}
фн строка(с: Строка) @внеш("имя":"print_string")
\end{Trivil}

Если атрибут "имя" не задан, внешнее имя совпадает с идентификатором функции.

\hypertarget{methods}{%
\subsection{Описание методов}\label{decls:methods}}

Метод - это функция, связанная с типом классом. Для вызова метода (\See{expr:call}) должен быть указан экземпляр этого класса или расширенного класса. 
В описание метода класс, с которым связан метод указывается с помощью \emph{Привязки}.

\begin{Grammar}
Описание-метода: 'фн' Привязка Идент-оп Сигнатура Блок
Привязка: '(' Идентификатор ':' Указ-типа ')'
\end{Grammar} 

Привязка определяет идентификатор и тип, который должен быть типом класса. В теле функции идентификатор привязки является параметром указанного типа.

\begin{Trivil}
тип К = класс {}

фн (к: К) метод() {}
\end{Trivil}

Идентификатор метода должен быть уникальным в классе среди идентификатором полей и методов. 

В расширенном классе может быть определен метод с таким же идентификатором как в одном из базовых классов.

\emph{переопределен}, то есть опеределен другой метод . При этом сигнатура переопределеного метода должна совпадать с сигнатуром переопределяемого метода, а именно:
\begin{d_itemize}
\item
    Число параметров должно совпадать
\item
    Типы  параметров должны быть эквивалентны \See{compat:equal-types}
\item 
    Признаки вариативности и полиморфности должны совпадать
\end{d_itemize}

Пример ошибки при переопределении метода (разное число параметров):
\begin{SampleErr}[vspace=2pt]
тип К1 = класс (К) {}

фн (к: К1) метод(с: Строка) {}
\end{SampleErr}