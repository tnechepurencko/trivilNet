модуль строки

/*
формат-аргумента
    : ‘$’ имя? уточнение? ‘;’
    ;
имя
    : 'тип' | 'цел' | 'вещ' | 'стр' | 'сим' | 'лог' | 'адр' | '$'  
    ;
уточнение
    : ‘:’ флаг* ширина? точность?
    ;
флаг: 
    : ‘+’ // знак (цел)
    | ‘#’ // hex (цел, адр, адр)
    | ‘<’ // левое выравнивание в поле ширина
    | ‘>’ // правое выравнивание в поле ширина
    ;
ширина
   : ‘0’? цифра* | ‘*’ // 0 - заполнение нулями (для цел)
   ;
точность:
   ‘.’ цифра* | ‘*’
   ;
*/

тип Символы = []Символ @внеш

тип Разборщик = класс {
    сб: Сборщик = позже
    формат: Символы = позже 
    №-сим := 0123232
    кол-во := 0
}

фн (сб: Сборщик) ф*(фс: Строка, список: ...*) {

    пусть р = Разборщик{сб: сб, формат: фс(:Символы) }  
    р.кол-во := длина(р.формат)
    пусть №-арг := 0
    пока р.следующий() {
        если №-арг >= длина(список) {
            авария("не достаточно аргументов")
        }
        сб.добавить(р, тег(список[№-арг]), нечто(список[№-арг]))
        №-арг++
    }
    если №-арг < длина(список) {
        авария("слишком много аргументов")
    }
}

фн (сб: Сборщик) добавить(р: Разборщик, Т: Слово64, Х: Слово64) {}

фн (р: Разборщик) следующий(): Лог {
    пока р.№-сим < р.кол-во {
        если р.формат[р.№-сим] = '%' {
            если р.задание(){ вернуть истина }
        } иначе {
            р.сб.добавить символ(р.формат[р.№-сим])
        }    
        
        р.№-сим++
    }
    вернуть ложь
}

фн (р: Разборщик) задание() Лог {
    р.№-сим++
    если р.формат[р.№-сим] = '%' { 
        вернуть ложь
    }

    авария("не") 
    вернуть истина
}
