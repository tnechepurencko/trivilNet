модуль строки

импорт "стд/юникод"
/*
формат-аргумента
    : ‘$’ имя? уточнение? ‘;’
    ;
имя
    : 'тип' | 'цел' | 'вещ' | 'стр' | 'сим' | 'лог' | 'адр' 
    ;
уточнение
    : ‘:’ флаг* ширина? точность?
    ;
флаг: 
    : ‘+’ // знак (цел)
    | ‘#’ // hex (цел, адр, адр)
    | ‘<’ // левое выравнивание в поле ширина
    | ‘>’ // правое выравнивание в поле ширина
    ;
ширина
   : ‘0’? цифра* | ‘*’ // 0 - заполнение нулями (для цел)
   ;
точность:
   ‘.’ цифра* | ‘*’
   ;
*/

тип Символы = []Символ 

тип Разборщик = класс {
    сб: Сборщик = позже
    формат: Символы = позже 
    №-сим := 0123232
    кол-во := 0
    
    // аргумент:
    норм := истина
    ошибка := ""
    имя := ""
}

фн (сб: Сборщик) ф*(фс: Строка, список: ...*) {

    пусть р = Разборщик{сб: сб, формат: фс(:Символы) }  
    р.кол-во := длина(р.формат)
    пусть №-арг := 0
    пока р.следующий() {
        если №-арг >= длина(список) {
            авария("не достаточно аргументов")
        }
        сб.добавить(р, тег(список[№-арг]), нечто(список[№-арг]))
        №-арг++
    }
    если №-арг < длина(список) {
        авария("слишком много аргументов")
    }
}

фн (сб: Сборщик) добавить(р: Разборщик, Т: Слово64, Х: Слово64) {}

фн (р: Разборщик) следующий(): Лог {
    пока р.№-сим < р.кол-во {
        если р.формат[р.№-сим] = '$' {
            если р.задание() { вернуть истина }
        } 
        р.сб.добавить символ(р.формат[р.№-сим])
        
        р.№-сим++
    }
    вернуть ложь
}

фн (р: Разборщик) задание(): Лог {
    р.№-сим++
    если р.формат[р.№-сим] = '$' { 
        вернуть ложь
    }
    
    р.норм := истина
    р.взять имя()
    // проверить :

    авария("не") 
    вернуть истина
}

фн (р: Разборщик) взять имя() {
    пусть начало = р.№-сим

    пока р.№-сим < р.кол-во & юникод.Буква?(р.формат[р.№-сим])  {
        р.№-сим++
    }

    если р.№-сим > начало {
        авария("не сделано") // рантайм?
        //р.имя := подстрока(р.формат, начало, р.№-сим - начало)
    }
}