модуль строки
осторожно

импорт "стд/юникод"
/*
формат-аргумента
    : ‘$’ имя? уточнение? ‘;’
    ;
имя
    : 'тип' | 'цел' | 'вещ' | 'стр' | 'сим' | 'лог' | 'адр' 
    ;
уточнение
    : ‘:’ флаг* ширина? точность?
    ;
флаг: 
    : ‘+’ // знак (цел)
    | ‘#’ // hex (цел, сим, адр)
    | ‘<’ // левое выравнивание в поле ширина
    | ‘>’ // правое выравнивание в поле ширина
    ;
ширина
   : ‘0’? цифра* | ‘*’ // 0 - заполнение нулями (для цел)
   ;
точность:
   ‘.’ цифра* | ‘*’
   ;
*/

фн строка*(с: Строка) @внеш("имя":"print_string")
фн символ*(с: Символ) @внеш("имя":"print_symbol")
фн цел64*(ц: Цел64) @внеш("имя":"print_int64")
фн кс*() @внеш("имя":"println")

тип Символы = []Символ 

тип Разборщик = класс {
    сб: Сборщик = позже
    формат: Символы = позже 
    №-сим := 0
    кол-во := 0
    
    // аргумент:
    норм := истина
    ошибка := ""
    имя := ""
}

фн (сб: Сборщик) ф*(фс: Строка, список: ...*) {

    пусть р = Разборщик{сб: сб, формат: фс(:Символы) }  
    р.кол-во := длина(р.формат)
    пусть №-арг := 0
    
    пока р.следующий() {
        если №-арг >= длина(список) {
            авария("не достаточно аргументов")
        }
        // учесть ширину и точность из аргументов
        р.добавить аргумент(тег(список[№-арг]), нечто(список[№-арг]))
        №-арг++
    }
    если №-арг < длина(список) {
        авария("слишком много аргументов")
    }
}



//=== добавление аргументов

фн (р: Разборщик) добавить аргумент(аргТ: Слово64, арг: Слово64) {

    если р.имя = "" {
        р.добавить нечто(аргТ, арг)
        вернуть
    }

    // здесь по имени
    авария("не сделано")

}

// Имя не задано, формат по умолчанию
фн (р: Разборщик) добавить нечто(аргТ: Слово64, арг: Слово64) {

    когда аргТ {
    есть тег(Цел64): р.добавить целое(арг(:осторожно Цел64))
    есть тег(Строка): р.добавить строку(арг(:осторожно Строка))
    иначе
        р.сб.добавить строку(" *арг?* ")
    }
}

фн (р: Разборщик) добавить строку(ст: Строка) {
    // TODO: обработать уточнение
    р.сб.добавить строку(ст)
}

фн (р: Разборщик) добавить целое(ц: Цел64) {
    // TODO: обработать уточнение
    р.сб.добавить строку("*цел64*")
}


//=== разбор форматной строки

фн (р: Разборщик) следующий(): Лог {
    пока р.№-сим < р.кол-во {
        строка("'"); символ(р.формат[р.№-сим]); кс()
    
        если р.формат[р.№-сим] = '$' {
            если р.задание() { вернуть истина }
        } 
        р.сб.добавить символ(р.формат[р.№-сим])
        
        р.№-сим++
    }
    вернуть ложь
}

фн (р: Разборщик) задание(): Лог {
     строка("!задание");  кс()

    р.№-сим++
    если р.формат[р.№-сим] = '$' {  вернуть ложь  }
    
    р.норм := истина
    р.взять имя()
    
    надо р.норм & р.№-сим < р.кол-во иначе { р.норм := ложь; вернуть истина } // дойти до ; ?
    
    если р.формат[р.№-сим] = ':' {
        р.уточнение()
        надо р.норм & р.№-сим < р.кол-во иначе { р.норм := ложь; вернуть истина }
    }
    
    если р.формат[р.№-сим] = ';' {
        р.№-сим++
    }
    вернуть истина
}

фн (р: Разборщик) взять имя() {
    пусть начало = р.№-сим

    пока р.№-сим < р.кол-во & юникод.Буква?(р.формат[р.№-сим])  {
        р.№-сим++
    }

    если р.№-сим > начало {
        авария("не сделано") // рантайм?
        //р.имя := подстрока(р.формат, начало, р.№-сим - начало)
    }
}

фн (р: Разборщик) уточнение() {
     строка("!уточнение");  кс()
}