модуль строки
осторожно

импорт "стд::юникод"

/*
формат-аргумента: ‘$’ форма? ( ‘:’ поле)?   ‘;’
вид
    : тип
    | стр #? (. ограничение)? // # - "в кавычках" escaped
    | сим #?    // # 'в кавычках' escaped
    | адр 0? размер?
    | цел +? 0? размер?
    | (ш | Ш) #? 0? размер?  // # - 0x
    | вещ +? 0? размер? (‘.’ точность)? (e | E)?

Флаги:
    # - модификация формата
    + - обязательный знак числа
    0 - выравнивание нулями слева

ограничение: число | *
размер: число | *
точность: число | *

поле: (заполнитель?выравнивание)? ширина?
выравнивание:= '<' | '^' | '>'
ширина: число | '*'
*/

//тип Символы = []Символ 

// отладка
фн __с(с: Строка) {
    строка("!")
    строка(с)
    кс()
}
фн __ц(с: Строка, ц: Цел64) {
    строка("!")
    строка(с)
    строка("=")
    цел64(ц)
    кс()
}

//

конст (
    _неоп = 0
    _умолчание
    _тип
    _стр 
    _сим
    _адр
    _ш
    _Ш
    _вещ
)

тип Разборщик2 = класс {
    сб: Сборщик = позже
    формат: Символы = позже 
    №-сим := 0
    кол-во := 0
    
    // формат аргумента:
    ошибка := ложь
    сообщение := ""
    вид := _неоп
}

фн ф2*(формат: Строка, аргументы: ...*): Строка {
    пусть сб = Сборщик{}
    сб.ф2(формат, аргументы...)
    вернуть сб.строка()
}


фн (сб: Сборщик) ф2*(фс: Строка, список: ...*) {

    пусть р = Разборщик2{сб: сб, формат: фс(:Символы) }  
    р.кол-во := длина(р.формат)
    пусть №-арг := 0
    
    пока р.следующий формат() {
        надо №-арг < длина(список) иначе {
            р.ошибка := истина
            р.сообщение := "не достаточно аргументов"
            прервать
        }

        // учесть ширину и точность из аргументов
        р.добавить аргумент(тег(список[№-арг]), нечто(список[№-арг]))
        №-арг++
    }
    если №-арг < длина(список) {
        р.ошибка := истина
        р.сообщение := "слишком много аргументов"
    }
    
    если р.ошибка {
        р.сб.добавить символ('*')
        р.сб.добавить строку(р.сообщение)
        р.сб.добавить символ('*')
    }    
}

//=== разбор форматной строки

фн (р: Разборщик2) следующий формат(): Лог {
    надо ~ р.ошибка иначе вернуть ложь

    пока р.№-сим < р.кол-во {
    
        надо р.формат[р.№-сим] # 0(:Символ) иначе авария("0x0 в форматной строке") 
        //строка("'"); символ(р.формат[р.№-сим]); кс()
    
        если р.формат[р.№-сим] = '$' {
            если р.разобрать формат() { вернуть истина }
        } 
        р.сб.добавить символ(р.формат[р.№-сим])
        
        р.№-сим++
    }
    вернуть ложь
}

фн (р: Разборщик2) разобрать формат(): Лог {

    р.№-сим++
    если р.формат[р.№-сим] = '$' {  вернуть ложь  }
    
    р.ошибка := ложь
    р.извлечь форму()
    
    //! проверить выход - сделать, как в сканере - проверять "след" символ = EOL
    
    надо ~ р.ошибка иначе вернуть ложь
    
    если р.формат[р.№-сим] = ';' {
        р.№-сим++
        вернуть истина
    }     

    если р.формат[р.№-сим] = ':' {
        р.№-сим++
        р.поле()
    }     
  
// проверить на ';'    
  
    вернуть ~ р.ошибка
}

фн (р: Разборщик2) извлечь форму() {

    надо р.№-сим < р.кол-во иначе {
        р.сообщение := "формат оборван"
        р.ошибка := истина
        вернуть 
    }

    пусть символы = Символы[]
    пусть № := 0
    пока р.№-сим < р.кол-во & юникод.буква?(р.формат[р.№-сим]) {
        символы.добавить(р.формат[р.№-сим])
        №++
        р.№-сим++
    }
    пусть имя = символы(:Строка)
    
//    __ц("длина", длина(символы))
//    __с(имя)

    выбор имя {
    когда "": р.вид := _умолчание
    когда "тип": р.вид := _тип
    когда "стр": р.извлечь стр()
    когда "сим": р.извлечь сим()
    когда "адр": р.извлечь адр()
    когда "цел": р.извлечь цел()
    когда "вещ": р.извлечь вещ()
    когда "ш": р.извлечь шест(ложь)
    когда "Ш": р.извлечь шест(истина)
    другое
        р.сообщение := "неизвестный формат"
        р.ошибка := ложь
    }
}

фн  (р: Разборщик2) извлечь стр() {
    р.вид := _стр
//     авария("не сделано")
}

фн  (р: Разборщик2) извлечь сим() {
     авария("не сделано")
}

фн  (р: Разборщик2) извлечь адр() {
    р.вид := _адр
//     авария("не сделано")
}

фн  (р: Разборщик2) извлечь цел() {
     авария("не сделано")
}

фн  (р: Разборщик2) извлечь шест(заглавные: Лог ) {
     авария("не сделано")
}


фн  (р: Разборщик2) извлечь вещ() {
     авария("не сделано")
}

фн (р: Разборщик2) поле() {
     авария("не сделано")
}

//=== добавление аргументов

фн (р: Разборщик2) добавить аргумент(аргТ: Слово64, арг: Слово64) {

    выбор р.вид {
    когда _умолчание: р.добавить по умолчанию(аргТ, арг)
    когда _стр: р.добавить по строковому формату(аргТ, арг)
    когда _адр: р.добавить адр(аргТ, арг)
    другое
        авария("форма не сделана")
    }
}

//=== добавление по формату

// Формат по умолчанию
фн (р: Разборщик2) добавить по умолчанию(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Цел64): 
        р.добавить целое10(арг(:осторожно Цел64))
    когда тег(Слово64): 
        р.добавить число10(арг, ложь)
    когда тег(Символ), тег(Байт):
        р.добавить строку("0x"); р.добавить число16(арг)
    когда тег(Лог): 
        если арг = 0x0 { р.добавить строку("ложь") }
        иначе { р.добавить строку("истина") }
    когда тег(Строка): 
        р.добавить строку(арг(:осторожно Строка))
    другое
        р.сб.добавить строку(" *не сделано: тег "); р.добавить число16(аргТ)
    }
}

// Формат "стр"
фн (р: Разборщик2) добавить по строковому формату(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Строка): 
        р.добавить строку(арг(:осторожно Строка))
    другое
        р.сб.добавить строку(" *нельзя по строковому формату: тег "); р.добавить число16(аргТ)
    }
}

// Формат "адр"
фн (р: Разборщик2) добавить адр(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Строка): 
        р.добавить число16(арг)
    другое
        р.ошибка := истина
        р.сообщение := "неверный тип для формата адр"
        // TODO: добавить название типа - рефлексия?
    }
}

//=== добавление по данным

фн (р: Разборщик2) добавить строку(ст: Строка) {
    // TODO: обработать уточнение
    р.сб.добавить строку(ст)
}

фн (р: Разборщик2) добавить целое10(ц: Цел64) {
    р.добавить число10(ц(:осторожно Слово64), ц < 0)
}

фн (р: Разборщик2) добавить число10(к: Слово64, нег: Лог) {

    если нег { к := -к }

    пусть б := Байты[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,] //21 шт, достаточно для Max(Слово64) + знак
    пусть № := длина(б)
    пока истина {
         пусть ост := к % 10(:Слово64)
         к := к  / 10(:Слово64)

         №--
         б[№] := ( ост + '0'(:Слово64))(:Байт)

         если к = 0(:Слово64) { прервать }
    }

    // TODO: обработать уточнение
    если нег {
         №--
         б[№] := '-'(:Байт)
    }

    // все символы однобайтовые
    р.сб.число-символов := р.сб.число-символов + длина(б) - №
    пока № < длина(б) {
        //TODO: не оптимально, сделать slice или что-то еще, чтобы добавить все сразу
        р.сб.байты.добавить(б[№])
        №++
    }
}

// маска, сдвиги?
фн (р: Разборщик2) добавить число16(к: Слово64) {

    пусть б := Байты[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,] //17 шт, достаточно для Max(Слово64) 
    пусть № := длина(б)
    пока истина {
         пусть ост := к % 16(:Слово64)
         к := к  / 16(:Слово64)

         №--
         если ост < 0xA {
            б[№] := ( ост + '0'(:Слово64))(:Байт)
         } иначе {
            б[№] := ( ост - 0xA + 'A'(:Слово64))(:Байт)
         }
         если к = 0(:Слово64) { прервать }
    }

    // TODO: обработать уточнение

    // все символы однобайтовые
    р.сб.число-символов := р.сб.число-символов + длина(б) - №
    пока № < длина(б) {
        //TODO: не оптимально, сделать slice или что-то еще, чтобы добавить все сразу
        р.сб.байты.добавить(б[№])
        №++
    }
}

