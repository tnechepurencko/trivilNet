модуль комстрока
осторожно

импорт "стд::вывод"
//импорт "стд/строки"

фн сравнить-байты(с1: Строка8, инд1: Цел64, с2: Строка8, инд2: Цел64, число: Цел64): Цел64 @внеш("имя":"tri_equalBytes")

конст начало-допа: Байт =  '-'

//==== основа

тип Доп = класс {
    имя: Строка = позже
    описание: Строка = позже
}

//==== виды Допов

тип Логический = класс (Доп) {
    значение = ложь
    умолчание = ложь
}

тип Строковый = класс (Доп) {
    значение = ""
    умолчание = ""
}

//==== операции

//тип Допы = []Доп

пусть словарь = Словарь{}

фн определить логический*(имя: Строка, описание: Строка, умолчание: Лог) {
    пусть доп = Логический{имя: имя, описание: описание, умолчание: умолчание}
    словарь.добавить(имя, доп)
}

// Возвращает ложь, если это не Доп или если Доп не определен
фн разобрать аргумент(а: Строка): Лог {
/*
    пусть б = а(:осторожно Строка8)
    надо длина(б) >=2 & б[0] = начало-допа иначе вернуть ложь

    пусть № := 1
    если б[1] = начало-допа {
        № := 2
        надо длина(б) >= 3 иначе вернуть ложь
    }

    пусть длина-имени = длина(б) - №
                    вывод.ф("длина-имени %v\n", длина-имени)
    
    пусть №-пар := 0
    пока №-пар < длина(список) {
    
        пусть д = список[№-пар]
        пусть и = д.имя(:осторожно Строка8)
                    вывод.ф("длина %v\n", длина(и))
        
        если длина(и) = длина-имени {
            если сравнить-байты(б, №, и, 0, длина-имени) = 0 {
                вывод.ф("найден %v\n", д.имя)
                вернуть истина
            }
        }
        №-пар++   
    }
*/
    вернуть ложь
}

фн показать допы*() {

    пусть итератор = словарь.начать()
    пока итератор.элемент? # пусто {
        пусть эл = итератор.элемент?^
        пусть доп = эл.значение
        вывод.ф("%v: %v\n", доп.имя, доп.описание)
        итератор.следующий()
    }

/*
    пусть № := 0
    пока № < длина(список) {
        вывод.ф("%v: %v\n", список[№].имя, список[№].описание)
        №++
    }
*/    
}



