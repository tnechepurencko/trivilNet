модуль комстрока
осторожно

импорт "стд::вывод"
//импорт "стд/строки"

фн сравнить-байты(с1: Строка8, инд1: Цел64, с2: Строка8, инд2: Цел64, число: Цел64): Цел64 @внеш("имя":"tri_equalBytes")

конст начало-допа: Байт =  '-'

//==== основа

тип Доп = класс {
    имя*: Строка = позже
    описание*: Строка = позже
}

//==== виды Допов

тип Логический* = класс (Доп) {
    значение* = ложь
    умолчание* = ложь
}

тип Строковый* = класс (Доп) {
    значение* = ""
    умолчание* = ""
}

//==== операции

тип Допы = []Доп

пусть список = Допы[]

фн (д: Доп) определить*(){
    список.добавить(д)
}

// Возвращает ложь, если это не Доп или если Доп не определен
фн разобрать аргумент(а: Строка): Лог {

    пусть б = а(:осторожно Строка8)
    надо длина(б) >=2 & б[0] = начало-допа иначе вернуть ложь

    пусть № := 1
    если б[1] = начало-допа {
        № := 2
        надо длина(б) >= 3 иначе вернуть ложь
    }

    пусть длина-имени = длина(б) - №
                    вывод.ф("длина-имени %v\n", длина-имени)
    
    пусть №-пар := 0
    пока №-пар < длина(список) {
    
        пусть д = список[№-пар]
        пусть и = д.имя(:осторожно Строка8)
                    вывод.ф("длина %v\n", длина(и))
        
        если длина(и) = длина-имени {
            если сравнить-байты(б, №, и, 0, длина-имени) = 0 {
                вывод.ф("найден %v\n", д.имя)
                вернуть истина
            }
        }
        №-пар++   
    }

    вернуть ложь
}

фн подсказка*() {
    пусть № := 0
    пока № < длина(список) {
        вывод.ф("%v: %v\n", список[№].имя, список[№].описание)
        №++
    }
}



