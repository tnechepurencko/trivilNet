модуль комстрока
осторожно

импорт "стд::вывод"
импорт "стд::строки"

фн сравнить-байты(с1: Строка8, инд1: Цел64, с2: Строка8, инд2: Цел64, число: Цел64): Цел64 @внеш("имя":"tri_equalBytes")

конст признак-настройки =  '-'(: Байт)

//==== основа

тип Настройка = класс {
    имя: Строка = позже
    описание: Строка = позже
}

//==== виды настроек

тип Логическая = класс (Настройка) {
    значение = ложь
    умолчание = ложь
}

тип Строковая = класс (Настройка) {
    значение = ""
    умолчание = ""
}

//==== операции

пусть словарь = Словарь{}

фн логическая настройка*(имя: Строка, описание: Строка, умолчание: Лог) {
    пусть доп = Логическая{имя: имя, описание: описание, умолчание: умолчание}
    словарь.добавить(имя, доп)
}

// Возвращает ложь, если это не настройка или если настройка с таким именем не определена
фн разобрать аргумент(а: Строка): Лог {
    вывод.ф("разобрать аргумент '%v'\n", а)
    
    пусть а8 = а(:осторожно Строка8)
    надо длина(а8) >=2 & а8[0] = признак-настройки иначе вернуть ложь

    пусть №-старт := 1
    если а8[1] = признак-настройки {
        №-старт := 2
        надо длина(а8) >= 3 иначе вернуть ложь
    }

    пусть №-равно := строки.индекс(а, №-старт, "=")
    если №-равно < 0 {
        №-равно := длина(а8)
    }

    пусть имя = строки.извлечь(а, №-старт, №-равно - №-старт)
    вывод.ф("поиск имени '%v'\n", имя)

    пусть эл? = словарь.найти(имя)
    надо эл? # пусто иначе вернуть ложь
    
    вернуть истина
}

фн показать настройки*() {
    пусть итератор = словарь.начать()

    пока итератор.элемент? # пусто {
        пусть эл = итератор.элемент?^
        пусть доп = эл.значение
        вывод.ф("%v: %v\n", доп.имя, доп.описание)
        итератор.следующий()
    }
}



