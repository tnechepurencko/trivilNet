модуль utf8


конст Ош-символ = '\uFFFD'

тип Байты = []Байт

тип Декодер = класс {
    байты: Байты = позже
    №* := 0
    //==== результаты декодирования
    //последний* := Ош-символ
    число-байтов* := 0
}

фн декодер*(б: Байты): Декодер {
    вернуть Декодер{байты: б}
}

фн (д: Декодер) символ*(): Символ {

    д.число-байтов := 0

    надо д.№ < длина(д.байты) иначе вернуть Ош-символ
    
    пусть тек = д.байты[д.№](:Слово64)
    д.№++
        
    если тек < 0x80 {
        д.число-байтов := 1
        вернуть тек(:Символ)
    }
    
    // Первый байт должен быть в диапазоне [0xc2..0xf4]
    надо тек >=  0xc2 | тек <= 0xf4 иначе вернуть Ош-символ
    
    если тек < 0xe0 { // 2-х байтовая последовательность
        надо д.№ < длина(д.байты) иначе вернуть Ош-символ
        пусть тек1 = д.байты[д.№](:Слово64)
        д.№++       
        надо тек1 :& 0xc0 = 0x80 иначе вернуть Ош-символ
        
        д.число-байтов := 2
        вернуть ((тек :& 0x1f) << 6 :| тек1 :& 0x3f)(:Символ)
    }
    
    если тек < 0xf0 { // 3-х байтовая последовательность
        надо д.№ + 1 < длина(д.байты) иначе вернуть Ош-символ
        пусть тек1 = д.байты[д.№](:Слово64)
        пусть тек2 = д.байты[д.№+1](:Слово64)
        д.№ := д.№ +2  

        надо тек1 :& 0xc0 = 0x80 иначе вернуть Ош-символ
        надо тек2 :& 0xc0 = 0x80 иначе вернуть Ош-символ    

        // Проверка суррогатов
        если тек = 0xed & тек1 > 0x9f { вернуть Ош-символ  }     

        пусть код =  (тек :& 0xf) << 12 :| (тек1 :& 0x3f) << 6 :| тек2 :& 0x3f
        надо код >= 0x800 иначе вернуть Ош-символ 
        
        д.число-байтов := 3
        вернуть код(:Символ)       
    }    
        
    
    вернуть Ош-символ
}
