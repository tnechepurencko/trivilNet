/* тесты 
    пусть ю = Байты[0xd1, 0x84]     0x444
    пусть ю = Байты[0xe0, 0xa6, 0x80]   0x980   
    пусть ю = Байты[0xf0, 0x90, 0x8a, 0x80]       0x10280
*/

модуль utf8

конст Недоп-символ* = '\uFFFD'

тип Байты = []Байт

тип Декодер* = класс {
    байты: Байты = позже
    №* := 0
    //==== результаты декодирования
    //последний* := Недоп-символ
    число-байтов* := 0
}

фн декодер*(б: Байты): Декодер {
    вернуть Декодер{байты: б}
}

// Выдает следующий символ, длина его в "число-байтов"
фн (д: Декодер) символ*(): Символ {

    д.число-байтов := 0

    надо д.№ < длина(д.байты) иначе вернуть Недоп-символ
    
    пусть тек = д.байты[д.№](:Слово64)
    д.№++
        
    если тек < 0x80 {
        д.число-байтов := 1
        вернуть тек(:Символ)
    }
    
    // Первый байт должен быть в диапазоне [0xc2..0xf4]
    надо тек >=  0xc2 | тек <= 0xf4 иначе вернуть Недоп-символ
    
    если тек < 0xe0 { // 2-х байтовая последовательность
        надо д.№ < длина(д.байты) иначе вернуть Недоп-символ
        пусть тек1 = д.байты[д.№](:Слово64)
        д.№++       
        надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
        
        д.число-байтов := 2
        вернуть ((тек :& 0x1f) << 6 :| тек1 :& 0x3f)(:Символ)
    }
    
    если тек < 0xf0 { // 3-х байтовая последовательность
        надо д.№ + 1 < длина(д.байты) иначе вернуть Недоп-символ
        пусть тек1 = д.байты[д.№](:Слово64)
        пусть тек2 = д.байты[д.№+1](:Слово64)
        д.№ := д.№ +2  

        надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
        надо тек2 :& 0xc0 = 0x80 иначе вернуть Недоп-символ    

        // Проверка суррогатов
        если тек = 0xed & тек1 > 0x9f { вернуть Недоп-символ  }     

        пусть код =  (тек :& 0xf) << 12 :| (тек1 :& 0x3f) << 6 :| тек2 :& 0x3f
        надо код >= 0x800 иначе вернуть Недоп-символ 
        
        д.число-байтов := 3
        вернуть код(:Символ)       
    }    
        
    // 4-х байтовая последовательность      
     надо д.№ + 2 < длина(д.байты) иначе вернуть Недоп-символ
     пусть тек1 = д.байты[д.№](:Слово64)
     пусть тек2 = д.байты[д.№+1](:Слово64)
     пусть тек3 = д.байты[д.№+2](:Слово64)
     д.№ := д.№ +3  

    надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
    надо тек2 :& 0xc0 = 0x80 иначе вернуть Недоп-символ    
    надо тек3 :& 0xc0 = 0x80 иначе вернуть Недоп-символ

    // проверка диапазона: (0x10000 .. 0x10ffff
    если тек = 0xf0 {
        надо тек1 >= 0x90 иначе вернуть Недоп-символ
    } иначе если тек = 0xf4 {
         надо тек1 <= 0x8f иначе вернуть Недоп-символ   
    }
    
    пусть код =  (тек :& 0x7) << 18 :| (тек1 :& 0x3f) << 12  :| (тек2 :& 0x3f) << 6 :| тек3 :& 0x3f    
        
    д.число-байтов := 4
    вернуть код(:Символ)    
}

// Пропуская один символ, считая его длину. 
// Не проверяет символы на некорректность
фн (д: Декодер) пропустить*() {

    д.число-байтов := 0

    надо д.№ < длина(д.байты) иначе вернуть
    
    пусть тек = д.байты[д.№](:Слово64)
    д.№++

    если тек < 0x80 {
        д.число-байтов := 1
        вернуть 
    }
    
    // Первый байт должен быть в диапазоне [0xc2..0xf4]
    надо тек >=  0xc2 | тек <= 0xf4 иначе вернуть
    
    если тек < 0xe0 { // 2-х байтовая последовательность
        надо д.№ < длина(д.байты) иначе вернуть 
        д.№++       
        д.число-байтов := 2
        вернуть 
    }
    
    если тек < 0xf0 { // 3-х байтовая последовательность
        надо д.№ + 1 < длина(д.байты) иначе вернуть
        д.№ := д.№ +2  
        д.число-байтов := 3
        вернуть 
    }    
        
    // 4-х байтовая последовательность      
     надо д.№ + 2 < длина(д.байты) иначе вернуть
     д.№ := д.№ +3  
    д.число-байтов := 4
}
