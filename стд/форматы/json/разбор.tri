модуль json

импорт "стд::юникод"
импорт "стд::юникод/utf8"

// ошибки
конст (
    лишние-символы = "лишние символы"
    неожиданное-завершение = "неожиданное завершение строки"
    недопустимый-символ = "недопустимый Unicode символ"
)


пусть заглушка = Узел{}

тип Разборщик = класс {
    с8: Строка8 = позже
    № := 0
    сим := utf8.Недоп-символ
    
    // обработка ошибок
    ошибка := ложь
    сообщение := ""
}

фн разобрать*(с: Строка): Узел {

    пусть р = Разборщик{с8: с(:Строка8)}
    
    р.взять символ()
    пусть узел = р.разобрать узел()
    
    надо ~ р.ошибка иначе вернуть Ошибка{позиция: р.№, сообщение: р.сообщение}
    
    если р.№ < длина(р.с8) {
        вернуть Ошибка{позиция: р.№, сообщение: лишние-символы}
    }

    вернуть узел
}

фн (р: Разборщик) взять символ() {
    пусть число-байтов := 0
    р.сим := utf8.декодировать символ-строка8(р.с8, р.№, число-байтов)
    надо р.сим # utf8.Недоп-символ 
    иначе {
        р.ошибка := истина
        если р.№ >= длина(р.с8) {
            р.сообщение := неожиданное-завершение
        } иначе {
            р.сообщение := недопустимый-символ
        }
        вернуть
    }
    р.№ := р.№ + число-байтов
}

фн (р: Разборщик) беда(сообщение: Строка): Узел {
    р.ошибка := истина
    р.сообщение := сообщение
    вернуть заглушка
}

фн (р: Разборщик) разобрать узел(): Узел {
    надо ~ р.ошибка иначе вернуть заглушка

    выбор р.сим {
    //когда '"': вернуть разобрать строку(с, №) 
    
    другое
        если юникод.цифра?(р.сим) { вернуть р.разобрать число() }
        вернуть р.беда("не верный символ")
    }
}

/*
фн разобрать строку(с: Строка, № := Цел64): Стр {
    вернуть Ошибка{позиция: №, сообщение: "строка - не сделано"}
}
*/

фн (р: Разборщик) разобрать число(): Узел {
    вернуть Цел{значение: р.сим(:Цел64) - '0'(:Цел64)}
}

