/*
https://restfulapi.net/json-data-types/
https://nlohmann.github.io/json/features/types/number_handling/

Не сделано: 
    - вещественные числы
    - boolean
    - null
*/
модуль json

импорт "стд::вывод"

импорт "стд::строки"
импорт "стд::юникод"
импорт "стд::юникод/utf8"

// ошибки
конст (
    лишние-символы = "лишние символы"
    неожиданное-завершение = "неожиданное завершение json строки"
    недопустимый-символ = "недопустимый Unicode символ"
    синтаксическая-ошибка = "синтаксическая ошибка"
    хотя-бы-одна-цифра = "в числе должна быть хотя бы одна цифра"
    нет-завершающей-кавычки = "нет завершающей кавычки"
    недопустимый-escape = "недопустимая escape последовательность" 
    нет-завершающей-скобки = "нет завершающей скобки: $;"    
    ключ-не-строка = "ключ в записи должен быть строкой"
)

конст макс-Цел64 = 0x7FFFFFFFFFFFFFFF(:Цел64)

конст КОН-СТР = 0(:Символ)

пусть заглушка = Узел{}

тип Разборщик = класс {
    с8: Строка8 = позже
    № := 0
    
    сим := utf8.Недоп-символ
    №-сим := 1 // для позиции ошибки
    
    // обработка ошибок
    ошибка := ложь
    позиция := 0
    сообщение := ""
}

фн разобрать*(с: Строка): Узел {

    пусть р = Разборщик{с8: с(:Строка8)}
    
    р.взять символ()
    надо р.сим # КОН-СТР иначе вернуть Ошибка{позиция: р.№-сим, сообщение: неожиданное-завершение}
    
    пусть узел = р.разобрать узел()
 
    надо ~ р.ошибка иначе вернуть Ошибка{позиция: р.позиция, сообщение: р.сообщение}
    
    р.пропустить пробелы()
    
    если р.№ < длина(р.с8) {
        вернуть Ошибка{позиция: р.№-сим, сообщение: лишние-символы}
    }

    вернуть узел
}

фн (р: Разборщик) взять символ() {
    пусть число-байтов := 0
    р.сим := utf8.декодировать символ-строка8(р.с8, р.№, число-байтов)

    если р.сим = utf8.Недоп-символ {
        если р.№ >= длина(р.с8) {
            р.сим := КОН-СТР
            вернуть
        } 
        р.ошибка := истина
        р.сообщение := недопустимый-символ
    }
    р.№-сим++
}

фн (р: Разборщик) пропустить пробелы() {
    пока р.сим = ' ' | р.сим = '\t' | р.сим = '\n' | р.сим = '\r' {
        р.взять символ()
    }
}

фн (р: Разборщик) беда(сообщение: Строка, аргументы: ...*): Узел {
    р.ошибка := истина
    р.позиция := р.№-сим
    р.сообщение := строки.ф(сообщение, аргументы...)
    вернуть заглушка
}

фн (р: Разборщик) разобрать узел(): Узел {
    надо ~ р.ошибка иначе вернуть заглушка
    
    р.пропустить пробелы()

    выбор р.сим {
    когда '-': вернуть р.разобрать число()
    когда '"': вернуть р.разобрать строку() 
    когда '[': вернуть р.разобрать массив() 
    когда '{': вернуть р.разобрать запись() 
   
    другое
        если юникод.цифра?(р.сим) { вернуть р.разобрать число() }
        вернуть р.беда(синтаксическая-ошибка)
    }
}

//==== массивы

фн (р: Разборщик) разобрать массив(): Узел {
    р.взять символ()
    
    пусть м = Массив{}
    пока р.сим # ']' & р.сим # КОН-СТР {
        пусть узел = р.разобрать узел()
//вывод.ф("$тип;", узел)        
        надо ~ р.ошибка иначе вернуть м
        
        м.узлы.добавить(узел)
        
//вывод.ф("$сим;", р.сим)        
        р.пропустить пробелы()
        если р.сим = ',' { р.взять символ() }
        р.пропустить пробелы()
    }

    если р.сим = КОН-СТР { вернуть р.беда(нет-завершающей-скобки, ']') }
    
    р.взять символ()
    вернуть м
}

//==== записи

фн (р: Разборщик) разобрать запись(): Узел {
    р.взять символ()
    
    пусть з = Запись{}
    пока р.сим # '}' & р.сим # КОН-СТР {
        
        р.разобрать пару(з)
        надо ~ р.ошибка иначе вернуть з
        
        р.пропустить пробелы()
        если р.сим = ',' { р.взять символ() }
        р.пропустить пробелы()
    }

    если р.сим = КОН-СТР { вернуть р.беда(нет-завершающей-скобки, ']') }
    
    р.взять символ()
    вернуть з
}

фн (р: Разборщик) разобрать пару(з: Запись) {

    р.пропустить пробелы()
    надо р.сим = '"' иначе { р.беда(ключ-не-строка); вернуть }
    
    пусть ключ = р.разобрать строку()
    надо ~ р.ошибка иначе вернуть

    р.пропустить пробелы()
    надо р.сим = ':' иначе { р.беда(синтаксическая-ошибка); вернуть }
    р.взять символ()
    
    пусть пара = Пара{имя: ключ(:Стр).строка, значение: р.разобрать узел()}
    з.пары.добавить(пара)
}

//==== строки

фн (р: Разборщик) разобрать строку(): Узел {
    пусть сб = строки.Сборщик{}
    р.взять символ()
    пока р.сим #  '"' & р.сим # КОН-СТР {
        если р.сим = '\\' {
            надо р.escape(сб) иначе {
                если р.сим = КОН-СТР {
                    вернуть р.беда(неожиданное-завершение)
                } иначе {
                    вернуть р.беда(недопустимый-escape)
                }            
            }
        } иначе {
            сб.добавить символ(р.сим)
            р.взять символ()
        }
    }
    если р.сим = КОН-СТР { вернуть р.беда(нет-завершающей-кавычки) }
    р.взять символ()

    вернуть Стр{строка: сб.строка()}
}

фн (р: Разборщик) escape(сб: строки.Сборщик): Лог {
    р.взять символ()
    выбор р.сим {
    когда '"': сб.добавить символ('"'); р.взять символ()
    когда '\\': сб.добавить символ('\\'); р.взять символ()
    когда '/': сб.добавить символ('/'); р.взять символ()
    когда 'b': сб.добавить символ('\u0008'); р.взять символ()
    когда 'f': сб.добавить символ('\u000C'); р.взять символ()
    когда 'n': сб.добавить символ('\u000A'); р.взять символ()
    когда 'r': сб.добавить символ('\u000D'); р.взять символ()
    когда 't': сб.добавить символ('\u0009'); р.взять символ()
    когда 'u': 
        р.взять символ()
        пусть сим := 0x0
        пусть № := 4
        пока № > 0 {
            пусть цифра = значение цифры(р.сим)
            надо цифра < 0x10 иначе вернуть ложь
            сим := сим * 0x10 + цифра
            №--    
            р.взять символ()
        }
        сб.добавить символ(сим(:Символ))
        вернуть истина
    другое 
        вернуть ложь
    }
    вернуть истина
}

фн значение цифры(сим: Символ): Слово64 {
	выбор {
	когда '0' <= сим & сим <= '9':
		вернуть сим(:Слово64) - '0'(:Слово64)
	когда 'a' <= сим & сим <= 'f':
		вернуть сим(:Слово64) - 'a'(:Слово64) + 0xA
	когда 'A' <= сим & сим <= 'F':
		вернуть сим(:Слово64) - 'A'(:Слово64) + 0xA
	}
	вернуть 0x10 // больше чем значение любой цифры
}

//==== числа

// Разбирает число - выдает узел Число или Ошибка
// Предусловие: сим = минус или цифра
фн (р: Разборщик) разобрать число(): Узел {
    пусть №-старт = р.№
    
    пусть рез  = р.разобрать целое()
    надо рез типа Число иначе вернуть рез
    
    пусть число = рез(:Число)    
    если число.целое? { вернуть число }

    вернуть Ошибка{позиция: №-старт, сообщение: "вещ числа - не сделано"}
}


// Разбирает число - выдает узел Число или Ошибка
// Если Число.целое? = ложь, то надо разбирать вещественное: выход за диапазон или 
// Предусловие: сим = минус или цифра
фн (р: Разборщик) разобрать целое(): Узел {
    пусть нег := ложь

    если р.сим = '-' {
        р.взять символ()
        надо юникод.цифра?(р.сим) иначе { 
            вернуть Ошибка{позиция: р.№, сообщение: хотя-бы-одна-цифра}
        }
        нег := истина
    }
    
    пусть число := 0
    пока юникод.цифра?(р.сим) {
    
    
        пусть цифра = р.сим(:Цел64) - '0'(:Цел64)
        
        // проверка выхода за границу
        надо число <= (макс-Цел64 - цифра) / 10 иначе вернуть Число{целое?: ложь}
        
        число := число*10 + цифра
        
        р.взять символ()
    }   
        
    если нег {
        число := - число
    }

    вернуть Число{целое?: истина, цел: число}
}