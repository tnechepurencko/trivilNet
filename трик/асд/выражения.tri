модуль асд

импорт "трик/лексер"

тип ОшВыражение* = класс (Выражение) {}

//==== литералы

конст * (
    Лит-НЕОП = 0
    Лит-Цел
    Лит-Слово
    Лит-Вещ
    Лит-Символ
    Лит-Строка 
    Лит-Пусто
)

тип Символы* = []Символ

тип Литерал* = класс (Выражение) {
    вид* := Лит-НЕОП
    цел*: Цел64 := 0 
    слово*: Слово64 := 0
    вещ*: Строка := ""  // чтобы не терять точность
    стр*: мб Символы := пусто // чтобы не выделять всегда
}

тип ЛогЛитерал* = класс (Выражение) {
	значение* := ложь
}

//==== 

тип БинарнаяОперация* = класс (Выражение) {
	Л*: Выражение = позже
	операция*: лексер.Лексема := лексер.НЕОП
	П*: Выражение = позже
}

тип УнарнаяОперация* = класс (Выражение) {
	Л*: Выражение = позже
	операция*: лексер.Лексема  := лексер.НЕОП
}

// х типа Т
тип ПроверкаТипа* = класс (Выражение) {
	Л*: Выражение = позже
	цель*: Тип = позже
}

тип ОперандИдент* = класс (Выражение) {
	имя*: Строка = позже
    объект*: мб Узел := пусто // Описание (переменная, константа, функция) или Тип (УказТипа)
}

тип Доступ* = класс (Выражение) {
	Л*: мб Выражение := пусто // пусто, если импортированный объект
	имя*: Строка = позже
    объект*: мб Узел := пусто // импортированный объект или поле или метод
	стд-метод*: мб СтдФункция := пусто
}

тип Вызов* = класс (Выражение) {
	Л*: Выражение = позже
    аргументы* = Выражения[]
    стд-функция*: мб СтдФункция := пусто // внимание: не стирает Л! - посмотреть на что влияет
    стд-метод-Л*: мб Выражение := пусто // левый операнд для стандартного метода
}

тип Развернуть* = класс (Выражение) {
	Л*: Выражение = позже
}

// х(:Т)
тип Преобразовать* = класс (Выражение) {
	Л*: Выражение = позже
	цель*: Тип = позже
	осторожное*: Лог = позже
	сделано* := ложь // Л уже преобразовано к целевому типу
}

// Если тип передается, как параметр, например, в функции 'тег'
тип ОперандТип* = класс (Выражение) {}

// х^
тип ПодтверждениеТипа* = класс (Выражение) {
	Л*: Выражение = позже
}

//==== индексация и композит вектора

тип ИндексацияИлиКонструктор* = класс (Выражение) {
	Л*: Выражение = позже
    индекс*: мб Выражение := пусто // если не пусто, индексация, иначе - композит
    композит*: КонструкторВектора = позже
}

тип КонструкторВектора* = класс (Выражение) {
	индексы* = Выражения[]
	значения* = Выражения[]

    // настройка композита
	размер*:  мб Выражение := пусто
	резерв*:  мб Выражение := пусто
    умолчание*: мб Выражение := пусто
	
    // вычисляемые по значениям
    число-элементов*: Цел64 := -1  // >= 0, если вычислено
    макс-индекс*: Цел64 := -1 // >= 0, если вычислено
}

//==== композит класса

тип ЗначениеПоля* = класс {
	поз*: Цел64 = позже
	имя-поля*: Строка = позже
	В*: Выражение = позже
    поле*: мб Поле := пусто
}
тип ЗначенияПолей = []ЗначениеПоля

тип КонструкторКласса* = класс (Выражение) {
	Л*: Выражение = позже
	значения* = ЗначенияПолей[]
}


