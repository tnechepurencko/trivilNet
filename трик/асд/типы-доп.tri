// функции обработки типов
модуль асд

// Снимает все УказТипа, их может быть несколько, например, два в коде: тип А = Б
фн основа*(мбт: мб Тип): мб Тип {
    надо мбт # пусто иначе вернуть пусто
    пусть т := мбт^
    
	пока истина {
		если т типа УказТипа {
			пусть т? = т(:УказТипа).Т
            надо т? # пусто иначе вернуть пусто
            т := т?^
		} иначе {
			вернуть т
		}
	}
    вернуть т
}

фн основы равны*(т1: мб Тип, т2: мб Тип): Лог {
    пусть о1 = основа(т1^)
    пусть о2 = основа(т2^)
    надо о1 # пусто & о2 # пусто иначе вернуть ложь
    вернуть о1^ = о2^
}

фн проверить(т: Тип, нужен: Тип): Лог {
    пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ = нужен
}

// Выдает УказТипа, непосредственно указывающий на сам тип
фн непосредственное указание-типа*(т: Тип): УказТипа {
    пусть указ := т(:УказТипа)
    пока истина {
        если указ.Т # пусто & указ.Т^ типа УказТипа {
            указ := указ.Т^(:УказТипа)
        } иначе {
            прервать 
        }
	}
    вернуть указ
}

//==== предикаты для типов

фн целочисленный тип?*(т: Тип): Лог {
    пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^
	вернуть от = тЦел64 | от = тБайт | от = тСлово64
}


фн байт?*(т: Тип): Лог { вернуть проверить(т, тБайт) }
фн цел64?*(т: Тип): Лог {	вернуть проверить(т, тЦел64) }
фн вещ64?*(т: Тип): Лог { вернуть проверить(т, тВещ64) }
фн слово64?*(т: Тип): Лог { вернуть проверить(т, тСлово64) }

фн лог?*(т: Тип): Лог { вернуть проверить(т, тЛог) }
фн символ?*(т: Тип): Лог {	вернуть проверить(т, тСимвол) }
фн строка?*(т: Тип): Лог {	вернуть проверить(т, тСтрока) }
фн строка8?*(т: Тип): Лог {	вернуть проверить(т, тСтрока8) }

фн полиморфный тип?*(т: Тип): Лог { вернуть проверить(т, тТегСлово) }
фн тип-нет значения?*(т: Тип): Лог { 	вернуть проверить(т, тНетЗначения) }
фн тип-пусто?*(т: Тип): Лог { 	вернуть проверить(т, тПусто) }

фн тип-вектора?*(т: Тип): Лог {	
    вернуть основа(т) типа ТипВектор 
}

фн вариативный тип?*(т: Тип): Лог {
    вернуть основа(т) типа ТипВариативный
}

фн тип-функции?*(т: Тип): Лог { 
    вернуть основа(т) типа ТипФункция
}

фн тип-класса?*(т: Тип): Лог {
    вернуть основа(т) типа ТипКласс
}

фн тип-мб?*(т: Тип): Лог {
    вернуть основа(т) типа ТипМБ 
}

фн ошибочный тип?*(т: Тип): Лог {
    вернуть основа(т) типа ТипОшибочный
}

//==== категории

фн ссылочный тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^

	выбор тип от {
	когда ТипВектор, ТипКласс:
		вернуть истина
	когда ТипОшибочный:
		вернуть истина
	другое
		вернуть от = тСтрока
	}
}

фн индексируемый тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^

	выбор тип от {
	когда ТипВектор, ТипВариативный:
		вернуть истина
	другое
		вернуть от = тСтрока8
	}
}

фн тип-элемента*(т: Тип): Тип {
	т := основа(т)^

	выбор пусть х: тип т {
	когда ТипВектор:
		вернуть х.Т-элемента
	когда ТипВариативный:
		вернуть х.Т-элемента
	другое
		если т = тСтрока8 {
			вернуть тБайт
		}
		авария("assert - должен быть индексируемый тип")
	}
}

//== вариативный параметр

фн ВариативныйПараметр*(тф: ТипФункция): мб Параметр {
	если длина(тф.параметры) = 0 {
		вернуть пусто
	}
	пусть последний = тф.параметры[длина(тф.параметры) - 1]
	если вариативный тип?(последний.Т^) {
		вернуть последний
	}
	вернуть пусто
}

//== теги

// Объекты каких типов имеют тег
фн есть тег*(т: Тип): Лог {
	вернуть ~ вариативный тип?(т) //пока так, можно разрешить для всех, но потом
}


