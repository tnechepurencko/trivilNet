// функции обработки типов
модуль асд

// Снимает все УказТипа, их может быть несколько, например, два в коде: тип А = Б
фн основа(т: Тип): Тип {
	пока истина {
		если т типа УказТипа {
			т := т(:УказТипа).Т^
		} иначе {
			вернуть т
		}
	}
    вернуть т
}

//==== предикаты для типов

/*
фн IsIntegerType(t Type) Лог {
	t = UnderType(t)
	вернуть t = Int64 | t = Byte | t = Word64
}

фн IsByte(t Type) Лог {
	вернуть UnderType(t) = Byte
}

фн IsInt64(t Type) Лог {
	вернуть UnderType(t) = Int64
}

фн IsFloatType(t Type) Лог {
	вернуть UnderType(t) = Float64
}

фн IsWord64(t Type) Лог {
	вернуть UnderType(t) = Word64
}

фн IsBoolType(t Type) Лог {
	вернуть UnderType(t) = Bool
}

фн IsStringType(t Type) Лог {
	вернуть UnderType(t) = String
}

фн IsVoidType(t Type) Лог {
	вернуть UnderType(t) = VoidType
}

фн IsIndexableType(t Type) Лог {
	t = UnderType(t)

	выбор t.(тип) {
	когда *VectorType, *VariadicType:
		вернуть истина
	другое
		вернуть t = String8
	}
}

фн ElementType(t Type) Type {
	t = UnderType(t)

	выбор x := t.(тип) {
	когда *VectorType:
		вернуть x.ElementTyp
	когда *VariadicType:
		вернуть x.ElementTyp
	другое
		если t = String8 {
			вернуть Byte
		}
		panic("assert - должен быть индексируемый тип")
	}
}

фн IsVectorType(t Type) Лог {
	_, ok := UnderType(t).(*VectorType)
	вернуть ok
}

фн IsVariadicType(t Type) Лог {
	_, ok := UnderType(t).(*VariadicType)
	вернуть ok
}

фн IsFuncType(t Type) Лог {
	_, ok := UnderType(t).(*FuncType)
	вернуть ok
}

фн IsClassType(t Type) Лог {
	_, ok := UnderType(t).(*ClassType)

	вернуть ok
}

фн IsMayBeType(t Type) Лог {
	_, ok := UnderType(t).(*MayBeType)

	вернуть ok
}

фн IsTagPairType(t Type) Лог {
	t = UnderType(t)
	вернуть t = TagPairType
}

фн IsReferenceType(t Type) Лог {
	t = UnderType(t)
	выбор t.(тип) {
	когда *VectorType, *ClassType:
		вернуть истина
	когда *InvalidType:
		вернуть истина
	другое
		вернуть t = String
	}
}

//== вариативный

фн VariadicParam(ft *FuncType) *Param {
	если len(ft.Params) = 0 {
		вернуть nil
	}
	пусть last = ft.Params[len(ft.Params)-1]
	если IsVariadicType(last.Typ) {
		вернуть last
	}
	вернуть nil
}

//== invalid тип

фн IsInvalidType(t Type) Лог {
	_, ok := UnderType(t).(*InvalidType)
	вернуть ok
}

фн MakeInvalidType(pos int) *InvalidType {
	вернуть &InvalidType{TypeBase: TypeBase{Pos: pos}}
}

//== теги

// Объекты каких типов имеют тег
фн HasTag(t Type) Лог {
	вернуть ~IsVariadicType(t) //пока так, можно разрешить для всех, но потом

}
*/

//==== обработка ошибок

/*
// Используется для улучшения сообщений об ошибках, см. TypeName
пусть CurHost *Module

фн TypeString(t Type) Строка {

	t = UnderType(t)

	выбор x := t.(тип) {
	когда nil:
		вернуть "*nil*"
	когда *InvalidType:
		вернуть "*invalid*"
	когда *PredefinedType:
		вернуть x.Name
	когда *VectorType:
		вернуть "[]" + TypeName(x.ElementTyp)
	когда *VariadicType:
		вернуть "..." + TypeName(x.ElementTyp)
	когда *MayBeType:
		вернуть "мб " + TypeName(x.Typ)
	другое
		вернуть fmt.Sprintf("TypeString ni: %T", t)
	}
}

фн TypeName(t Type) Строка {

	если tr, ok := t.(*TypeRef); ok {
		если tr.ModuleName # "" {
			вернуть tr.ModuleName + "." + tr.TypeName
		} иначе если tr.TypeDecl # nil & tr.TypeDecl.Host # nil & tr.TypeDecl.Host # CurHost {
			вернуть tr.TypeDecl.Host.Name + "." + tr.TypeName
		} иначе {
			вернуть tr.TypeName
		}
	} иначе {
		вернуть TypeString(t)
	}
}
*/

