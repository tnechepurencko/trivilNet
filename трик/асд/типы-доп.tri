// функции обработки типов
модуль асд

// Снимает все УказТипа, их может быть несколько, например, два в коде: тип А = Б
фн основа(т: Тип): Тип {
	пока истина {
		если т типа УказТипа {
			т := т(:УказТипа).Т^
		} иначе {
			вернуть т
		}
	}
    вернуть т
}

//==== предикаты для типов

фн целочисленный тип?*(т: Тип): Лог {
    т := основа(т)
	вернуть т = тЦел64 | т = тБайт | т = тСлово64
}

фн байт?*(т: Тип): Лог { вернуть основа(т) = тБайт }
фн цел64?*(т: Тип): Лог {	вернуть основа(т) = тЦел64 }
фн вещ64?*(т: Тип): Лог { вернуть основа(т) = тВещ64 }
фн слово64?(т: Тип): Лог { вернуть основа(т) = тСлово64 }

фн лог?*(т: Тип): Лог { вернуть основа(т) = тЛог }
фн строковый тип?*(т: Тип): Лог {	вернуть основа(т) = тСтрока }

фн тип-нет значения?*(т: Тип): Лог { 	вернуть основа(т) = тНетЗначения }

фн индексируемый тип?*(т: Тип): Лог {
	т := основа(т)

	выбор тип т {
	когда ТипВектор, ТипВариативный:
		вернуть истина
	другое
		вернуть т = тСтрока8
	}
}

фн тип-элемента*(т: Тип): Тип {
	т := основа(т)

	выбор пусть х: тип т {
	когда ТипВектор:
		вернуть х.Т-элемента
	когда ТипВариативный:
		вернуть х.Т-элемента
	другое
		если т = тСтрока8 {
			вернуть тБайт
		}
		авария("assert - должен быть индексируемый тип")
	}
}

фн тип-вектора?*(т: Тип): Лог {	вернуть основа(т) типа ТипВектор }
фн вариативный тип?*(т: Тип): Лог {	вернуть основа(т) типа ТипВариативный }
фн тип-функции?*(т: Тип): Лог { вернуть основа(т) типа ТипФункция }
фн тип-класса?*(т: Тип): Лог { вернуть основа(т) типа ТипКласс }
фн тип-мб?*(т: Тип): Лог {	вернуть основа(т) типа ТипМБ }
фн полиморфный тип?*(т: Тип): Лог { вернуть основа(т) = тТегСлово }
фн ошибочный тип?*(т: Тип): Лог { вернуть основа(т) типа ТипОшибочный }

фн ссылочный тип?*(т: Тип): Лог {
	т := основа(т)
	выбор тип т {
	когда ТипВектор, ТипКласс:
		вернуть истина
	когда ТипОшибочный:
		вернуть истина
	другое
		вернуть т = тСтрока
	}
}

/*

//== вариативный

фн VariadicParam(ft *FuncType) *Param {
	если len(ft.Params) = 0 {
		вернуть nil
	}
	пусть last = ft.Params[len(ft.Params)-1]
	если IsVariadicType(last.Typ) {
		вернуть last
	}
	вернуть nil
}

//== теги

// Объекты каких типов имеют тег
фн HasTag(т: Тип): Лог {
	вернуть ~IsVariadicType(t) //пока так, можно разрешить для всех, но потом

}
*/

//==== обработка ошибок

/*
// Используется для улучшения сообщений об ошибках, см. TypeName
пусть CurHost *Module

фн TypeString(t Type) Строка {

	t = основа(т)

	выбор x := t.(тип) {
	когда nil:
		вернуть "*nil*"
	когда *InvalidType:
		вернуть "*invalid*"
	когда *PredefinedType:
		вернуть x.Name
	когда *VectorType:
		вернуть "[]" + TypeName(x.ElementTyp)
	когда *VariadicType:
		вернуть "..." + TypeName(x.ElementTyp)
	когда *MayBeType:
		вернуть "мб " + TypeName(x.Typ)
	другое
		вернуть fmt.Sprintf("TypeString ni: %T", t)
	}
}

фн TypeName(t Type) Строка {

	если tr, ok := t.(*TypeRef); ok {
		если tr.ModuleName # "" {
			вернуть tr.ModuleName + "." + tr.TypeName
		} иначе если tr.TypeDecl # nil & tr.TypeDecl.Host # nil & tr.TypeDecl.Host # CurHost {
			вернуть tr.TypeDecl.Host.Name + "." + tr.TypeName
		} иначе {
			вернуть tr.TypeName
		}
	} иначе {
		вернуть TypeString(t)
	}
}
*/

