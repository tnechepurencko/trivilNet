// функции обработки типов
модуль асд

// Снимает все УказТипа, их может быть несколько, например, два в коде: тип А = Б
фн основа(т: Тип): мб Тип {
	пока истина {
		если т типа УказТипа {
			пусть т? = т(:УказТипа).Т
            надо т? # пусто иначе вернуть пусто
            т := т?^
		} иначе {
			вернуть т
		}
	}
    вернуть т
}

фн проверить(т: Тип, нужен: Тип): Лог {
    пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ = нужен
}

//==== предикаты для типов

фн целочисленный тип?*(т: Тип): Лог {
    пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^
	вернуть от = тЦел64 | от = тБайт | от = тСлово64
}


фн байт?*(т: Тип): Лог { вернуть проверить(т, тБайт) }
фн цел64?*(т: Тип): Лог {	вернуть проверить(т, тЦел64) }
фн вещ64?*(т: Тип): Лог { вернуть проверить(т, тВещ64) }
фн слово64?(т: Тип): Лог { вернуть проверить(т, тСлово64) }

фн лог?*(т: Тип): Лог { вернуть проверить(т, тЛог) }
фн строковый тип?*(т: Тип): Лог {	вернуть проверить(т, тСтрока) }

фн полиморфный тип?*(т: Тип): Лог { вернуть проверить(т, тТегСлово) }
фн тип-нет значения?*(т: Тип): Лог { 	вернуть проверить(т, тНетЗначения) }

фн тип-вектора?*(т: Тип): Лог {	
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипВектор 
}

фн вариативный тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипВариативный
}

фн тип-функции?*(т: Тип): Лог { 
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипФункция
}

фн тип-класса?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипКласс
}

фн тип-мб?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипМБ 
}

фн ошибочный тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    вернуть т?^ типа ТипОшибочный
}

//==== категории

фн ссылочный тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^

	выбор тип от {
	когда ТипВектор, ТипКласс:
		вернуть истина
	когда ТипОшибочный:
		вернуть истина
	другое
		вернуть от = тСтрока
	}
}

фн индексируемый тип?*(т: Тип): Лог {
	пусть т? = основа(т)
    надо т? # пусто иначе вернуть ложь
    пусть от = т?^

	выбор тип от {
	когда ТипВектор, ТипВариативный:
		вернуть истина
	другое
		вернуть от = тСтрока8
	}
}

фн тип-элемента*(т: Тип): Тип {
	т := основа(т)^

	выбор пусть х: тип т {
	когда ТипВектор:
		вернуть х.Т-элемента
	когда ТипВариативный:
		вернуть х.Т-элемента
	другое
		если т = тСтрока8 {
			вернуть тБайт
		}
		авария("assert - должен быть индексируемый тип")
	}
}

/*
//== вариативный

фн VariadicParam(ft *FuncType) *Param {
	если len(ft.Params) = 0 {
		вернуть nil
	}
	пусть last = ft.Params[len(ft.Params)-1]
	если IsVariadicType(last.Typ) {
		вернуть last
	}
	вернуть nil
}

//== теги

// Объекты каких типов имеют тег
фн HasTag(т: Тип): Лог {
	вернуть ~IsVariadicType(t) //пока так, можно разрешить для всех, но потом

}
*/

//==== обработка ошибок

/*
// Используется для улучшения сообщений об ошибках, см. TypeName
пусть CurHost *Module

фн TypeString(t Type) Строка {

	t = основа(т)

	выбор x := t.(тип) {
	когда nil:
		вернуть "*nil*"
	когда *InvalidType:
		вернуть "*invalid*"
	когда *PredefinedType:
		вернуть x.Name
	когда *VectorType:
		вернуть "[]" + TypeName(x.ElementTyp)
	когда *VariadicType:
		вернуть "..." + TypeName(x.ElementTyp)
	когда *MayBeType:
		вернуть "мб " + TypeName(x.Typ)
	другое
		вернуть fmt.Sprintf("TypeString ni: %T", t)
	}
}

фн TypeName(t Type) Строка {

	если tr, ok := t.(*TypeRef); ok {
		если tr.ModuleName # "" {
			вернуть tr.ModuleName + "." + tr.TypeName
		} иначе если tr.TypeDecl # nil & tr.TypeDecl.Host # nil & tr.TypeDecl.Host # CurHost {
			вернуть tr.TypeDecl.Host.Name + "." + tr.TypeName
		} иначе {
			вернуть tr.TypeName
		}
	} иначе {
		вернуть TypeString(t)
	}
}
*/

