модуль асд-показ

//импорт "стд::вывод"

импорт "стд::строки"
импорт "трик/асд"

// Краткое: обычно имя
фн с-указ-типа(т?: мб асд.Тип): Строка {
    надо т? # пусто иначе вернуть "(НетТипа)"
    
    пусть т = т?^
   
    выбор пусть тек: тип т {
    когда асд.ТипВстроенный:
        вернуть тек.имя
    когда асд.УказТипа:
        если тек.имя-модуля # "" {
             вернуть строки.ф("\"$;.$;\"", тек.имя-модуля, тек.имя-типа)
        } иначе {
            вернуть строки.ф("\"$;\"", тек.имя-типа)
        }
    когда асд.ТипМБ:
        вернуть строки.ф("\"мб $;\"", с-указ-типа(тек.Т))
    }
   
    вернуть строки.ф("(тип $тип;)", т)
}

// Определение класса или вектора или указ-типа
фн с-определение-типа(т?: мб асд.Тип): Строка {
    надо т? # пусто иначе вернуть "(НетТипа)"

    пусть т = т?^
    выбор пусть тек: тип т {
    когда асд.ТипВектор:
            вернуть строки.ф("(Вектор $;)",  с-указ-типа(тек.Т-элемента))
    когда асд.ТипКласс:
        вернуть с-тип-класса(тек)
    }   
   
    вернуть с-указ-типа(т?)
}

фн с-тип-класса(кл: асд.ТипКласс): Строка {
    пусть базовый := ""
    если кл.Т-базовый # пусто {
        базовый := строки.ф("($;)", с-указ-типа(кл.Т-базовый))
    }
    
    пусть поля = Строки[длина: длина(кл.поля), *: ""]
    
    цикл [№]поле среди кл.поля {
        поля[№] := с-поле(поле)
    }
    
    вернуть строки.ф("(Класс $;[$;])",  базовый, строки.соединить("", поля...))
}

фн с-поле(тек: асд.Поле): Строка {
    пусть иниц := ""
    если тек.задать-позже {
        иниц := "позже"
    } иначе {
        иниц := с-выражение(тек.значение^)
    }
    пусть не-изм := ""
    если тек.одно-присваивание {
        не-изм := " НеИзм"
    }

    вернуть строки.ф("(\"$;$;\"$; $;  $;)", тек.имя, экспорт(тек), не-изм, с-указ-типа(тек.Т), иниц)
}