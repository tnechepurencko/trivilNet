модуль основа

импорт "стд::вывод"
импорт "стд::строки"

тип Байты* = []Байт
тип Целые = []Цел64

тип Исходник* = класс {
    байты*: Байты = позже
    №: Цел64 = позже  // номер в векторе исходников
    начала* = Целые[]
}

тип Исходники = []Исходник

пусть исходники = Исходники[]

фн исходник из строки*(текст: Строка): Исходник {
    пусть и = Исходник{
        байты: текст(:Байты),
        №: длина(исходники) + 1,
    }

    исходники.добавить(и)

    вернуть и
}

//==== работа с позицией 

конст (
    маска = 0xFFFF(:Цел64)
    сдвиг = 16
  )

// Запоминает начало новой строки. Смещение - от начала исходного текста в символах
фн (и: Исходник) начало строки*(смещение: Цел64) {
    и.начала.добавить(смещение)
}

// Собирает позицию для смещения в исходном тексте
фн (и: Исходник) позиция*(смещение: Цел64): Цел64 {
    вернуть смещение << сдвиг + и.№
}

//==== распаковка позиции

тип Позиция = класс {
    исходник*: Исходник = позже
    №-строки*: Цел64 := 0
    №-символа*: Цел64 := 0
}

// Заполняет поля позиции, если позиция неправильная, то авария
фн распаковать*(позиция: Цел64): Позиция {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника %v (%v). Должен быть [1..%v[", №, позиция(:Слово64), длина(исходники)-1))
  
    пусть п = Позиция{исходник: исходники[№ - 1]}
    
    п.вычислить(позиция >> сдвиг)
    
    вернуть п
}

фн (поз: Позиция) вычислить(смещение: Цел64) {

    пусть и = поз.исходник

    надо длина(и.начала) > 0 иначе {
        поз.№-строки := 0
        поз.№-символа := 0
        вернуть // TODO: авария?
    }

    // бинарный поиск
    пусть л := 0
    пусть п := длина(и.начала) - 1

    пока истина {
        надо л < п иначе прервать
    
        пусть между = (л + п) / 2
        пусть начало-стр = и.начала[между]
        
        выбор {
        когда смещение > начало-стр: л := между + 1
        когда смещение < начало-стр: п := между - 1
        другое 
            л := между
            прервать
        }
    }

    если смещение < и.начала[л] & л > 0 {
        л--
    }

	поз.№-строки := л + 1
    поз.№-символа := смещение - и.начала[л]
}

/*

func calcTextPos(src *Source, ofs int) (int, int) {

	if len(src.Lines) == 0 {
		return 0, ofs
	}

	//fmt.Printf("%d in %v\n", ofs, src.Lines)

	var l = 0
	var r = len(src.Lines) - 1

	for {
		if l >= r {
			break
		}
		var x = (l + r) / 2
		var lofs = src.Lines[x]

		//fmt.Printf("%d.%d %d.%d => %d.%d\n", l, src.Lines[l], r, src.Lines[r], x, src.Lines[x])

		if ofs > lofs {
			l = x + 1
		} else if ofs < lofs {
			r = x - 1
		} else {
			l = x
			break
		}
	}

	if ofs < src.Lines[l] && l > 0 {
		l--
	}

	return l + 1, ofs - src.Lines[l]
}
*/