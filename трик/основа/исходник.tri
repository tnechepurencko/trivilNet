модуль основа

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::файлы"

тип Байты* = []Байт
тип Целые = []Цел64

конст расширение-исходного = ".tri"

тип Исходник* = класс {
    исходный-путь* := ""
    путь-папки* := ""
    имя-файла* := ""
    путь-файла* := "" // путь, используемый для чтения файла (нормализованный?)
    
    ошибка*: мб файлы.Ошибка = пусто
    байты*: Байты := позже

    №: Цел64 = позже  // номер в векторе исходников
    начала = Целые[]
}

тип Исходники* = []Исходник

пусть исходники = Исходники[]

//==== исходник из файла

// Если параметр - папка, читает все исходники из папки
// Иначе, читает файл, заданный параметром, и добавляет остальные файлы из папки с нужным расширением
// В случае любой ошибки при чтении, возвращает список из одного исходника с ошибкой
фн подготовить исходники по пути*(исходный-путь: Строка): Исходники {

    пусть ф = файлы.новый файл(исходный-путь)
    если ф.это папка?() {
        вернуть подготовить исходники в папке(исходный-путь, исходный-путь)
    }

	пусть путь-папки := файлы.извлечь путь(исходный-путь)
    пусть имя-файла = файлы.извлечь последнее имя(исходный-путь)
	если путь-папки = "" {
		путь-папки := "."
	}

	если ~ строки.есть суффикс(имя-файла, расширение-исходного) {
        добавить общую ошибку("ОКР-ОШ-РАСШИРЕНИЕ", исходный-путь, расширение-исходного)
		вернуть Исходники[]
	}

   пусть остальные = прочитать исходники(исходный-путь, путь-папки, имя-файла)
   если длина(остальные) > 0 & остальные[0].ошибка # пусто {
        вернуть остальные
   }

    пусть исх = прочитать(исходный-путь, путь-папки,  имя-файла)
    пусть список = Исходники[исх]
    список.добавить(остальные...)

	вернуть список
}

// Выдает список прочитанных исходников из папки
// В случае любой ошибки при чтении, возвращает список из одного исходника с ошибкой
фн подготовить исходники в папке*(исходный-путь: Строка, путь-папки: Строка): Исходники {

    пусть список = прочитать исходники(исходный-путь, путь-папки, "")
    
    если длина(список) = 0 {
    	добавить общую ошибку("ОКР-ОШ-НЕТ-ИСХОДНИКОВ", исходный-путь)
    }

    вернуть список   
}

//==== чтение исходников

// В случае любой ошибки при чтении, возвращает список из одного исходника с ошибкой
фн прочитать исходники(исходный-путь: Строка, путь-папки: Строка, кроме-имени: Строка): Исходники {

    пусть список = Исходники[]

    пусть папка = файлы.новый файл(путь-папки)

    пусть имена = папка.имена в папке()
    надо папка.ошибка?() = пусто
    иначе {
        добавить общую ошибку("ОКР-НЕ-ПАПКА", путь-папки, папка.ошибка?()^.сообщение())
        вернуть список
    }

    пусть № := 0
    пока № < длина(имена)  {
        пусть имя = имена[№]
        если имя # кроме-имени & строки.есть суффикс(имя, расширение-исходного) {
            пусть исх = прочитать(исходный-путь, путь-папки,  имя)

            если исх.ошибка # пусто {
                вернуть Исходники[исх]
            }
           
            список.добавить(исх)
        }
        №++
    }

    вернуть список
}

фн прочитать(исходный-путь: Строка, путь-папки: Строка,  имя-файла: Строка): Исходник {

    пусть путь = файлы.собрать путь(путь-папки, имя-файла)
    пусть файл = файлы.новый файл(путь)
    пусть байты = файл.прочитать()
 
    пусть исх = Исходник{
        исходный-путь: исходный-путь,
        путь-папки: путь-папки,
        имя-файла: имя-файла,
        путь-файла: путь,
    
        ошибка: файл.ошибка?(), 
        байты: байты,
        №: длина(исходники) + 1,
    }

    исходники.добавить(исх)

    вернуть исх
}

фн (исх: Исходник) имя папки*(): Строка {
    вернуть файлы.извлечь последнее имя(исх.путь-папки)
}

//==== исходник из строки - для тестирования

фн исходник из строки*(текст: Строка): Исходник {
    пусть и = Исходник{
        исходный-путь: "из строки",
        байты: текст(:Байты),
        №: длина(исходники) + 1,
    }

    исходники.добавить(и)

    вернуть и
}

//==== работа с позицией 

конст (
    маска = 0xFFFF(:Цел64)
    сдвиг = 16
  )

// Запоминает начало новой строки. Смещение - от начала исходного текста в символах
фн (и: Исходник) начало строки*(смещение: Цел64) {
    и.начала.добавить(смещение)
}

// Собирает позицию для смещения в исходном тексте
фн (и: Исходник) позиция*(смещение: Цел64): Цел64 {
    вернуть смещение << сдвиг + и.№
}

фн номер исходника*(позиция: Цел64): Цел64 {
    вернуть позиция :& маска
}

фн исходник по позиции*(позиция: Цел64): Исходник {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника $; ($;). Должен быть [1..$;[", №, позиция(:Слово64), длина(исходники)-1))

    вернуть исходники[№ - 1]
}


//==== распаковка позиции

// Распаковывает позицию, если позиция неправильная, то авария
фн распаковать позицию*(позиция: Цел64,  №-строки := Цел64,  №-символа := Цел64): Исходник {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника $; ($;). Должен быть [1..$;[", №, позиция(:Слово64), длина(исходники)-1))
  
    пусть исх = исходники[№ - 1]
    вычислить(исх, позиция >> сдвиг, №-строки, №-символа)
    
    вернуть исх
}

фн вычислить(исх: Исходник, смещение: Цел64,  №-строки := Цел64,  №-символа := Цел64) {

    надо длина(исх.начала) > 0 иначе {
        №-строки := 0
        №-символа := 0
        вернуть // TODO: авария?
    }

    // бинарный поиск
    пусть л := 0
    пусть п := длина(исх.начала) - 1

    пока истина {
        надо л < п иначе прервать
    
        пусть между = (л + п) / 2
        пусть начало-стр = исх.начала[между]
        
        выбор {
        когда смещение > начало-стр: л := между + 1
        когда смещение < начало-стр: п := между - 1
        другое 
            л := между
            прервать
        }
    }

    если смещение < исх.начала[л] & л > 0 {
        л--
    }

	№-строки := л + 1
    №-символа := смещение - исх.начала[л]
}

