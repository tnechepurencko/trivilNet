модуль основа

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::файлы"

тип Байты* = []Байт
тип Целые = []Цел64

конст расширение-исходного = ".tri"

тип Исходник* = класс {
    байты*: Байты = позже
    №: Цел64 = позже  // номер в векторе исходников
    начала* = Целые[]
}

тип Исходники = []Исходник

пусть исходники = Исходники[]

//==== исходник из файла

// Если параметр - папка, читает все исходники из папки
// Иначе, читает файл, заданный параметром, и добавляет остальные файлы из папки с нужным расширением
фн подготовить исходники по пути(исходный-путь: Строка): Исходники {

/*
	если EnsureFolder(spath) = nil {
		вернуть GetFolderSources(spath, spath)
	}
*/

	пусть путь-папки := файлы.извлечь путь(исходный-путь)
    пусть имя-файла = файлы.извлечь последнее имя(исходный-путь)
	если путь-папки = "" {
		путь-папки := "."
	}
	//fmt.Printf("GetSources: '%v' '%v'\n", folder, filename)

/*
	пусть src = &Source{
		OriginPath: spath,
		FilePath:   spath,

		FolderPath: folder,
		FileName:   filename,

		Lines: make([]int, 0),
	}
*/
	пусть список = Исходники[]

	если ~ строки.есть суффикс(имя-файла, расширение-исходного) {
		авария("сделать ошибку")
        //src.Err = er.New("неверное расширение файла " + filepath.Ext(filename))
		вернуть список
	}

/*
	buf, err := os.ReadFile(src.FilePath)
	если err # nil {
		src.Err = err
		вернуть list
	}
	src.Bytes = buf
*/
    //прочитать первый
    //список.добавить(первый)

	вернуть список
}

фн прочитать исходники(путь-папки: Строка, кроме-файла: Строка): Исходники {

/*
	f, err := os.Open(folder)
	если err # nil {
		panic(fmt.Sprintf("panic GetSources(%s): %s", folder, err.Error()))
	}

	names, err := f.Readdirnames(0)
	пока _, name := range names {
		если name # filename & strings.HasSuffix(name, file_extension) {
			пусть src = readSource(spath, folder, name)
			если src.Err # nil {
				list = make([]*Source, 1)
				list[0] = src
				вернуть list
			}
			list = append(list, src)
		}
	}
	f.Close()

	пока _, s := range list {
		sources = append(sources, s)
		s.No = len(sources)
	}
*/
    вернуть Исходники[]
}

фн прочитать(исходный-путь: Строка, путь-папки: Строка,  имя-файла: Строка): Исходник {
/*
фн readSource(origin, folder, filename string) *Source {

	пусть src = &Source{
		OriginPath: origin,
		FilePath:   filepath.Join(folder, filename),

		FolderPath: folder,
		FileName:   filename,

		Lines: make([]int, 0),
	}

	buf, err := os.ReadFile(src.FilePath)
	если err # nil {
		src.Err = err
		вернуть src
	}

	src.Bytes = buf

	вернуть src
}
*/
    пусть исх = Исходник{
        байты: Байты[],
        №: длина(исходники) + 1,
    }

    исходники.добавить(исх)

    вернуть исх
}

//==== исходник из строки - для тестирования

фн исходник из строки*(текст: Строка): Исходник {
    пусть и = Исходник{
        байты: текст(:Байты),
        №: длина(исходники) + 1,
    }

    исходники.добавить(и)

    вернуть и
}

//==== работа с позицией 

конст (
    маска = 0xFFFF(:Цел64)
    сдвиг = 16
  )

// Запоминает начало новой строки. Смещение - от начала исходного текста в символах
фн (и: Исходник) начало строки*(смещение: Цел64) {
    и.начала.добавить(смещение)
}

// Собирает позицию для смещения в исходном тексте
фн (и: Исходник) позиция*(смещение: Цел64): Цел64 {
    вернуть смещение << сдвиг + и.№
}

//==== распаковка позиции

тип Позиция* = класс {
    исходник*: Исходник = позже
    №-строки*: Цел64 := 0
    №-символа*: Цел64 := 0
}

// Заполняет поля позиции, если позиция неправильная, то авария
фн распаковать*(позиция: Цел64): Позиция {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника %v (%v). Должен быть [1..%v[", №, позиция(:Слово64), длина(исходники)-1))
  
    пусть п = Позиция{исходник: исходники[№ - 1]}
    п.вычислить(позиция >> сдвиг)
    
    вернуть п
}

фн (поз: Позиция) вычислить(смещение: Цел64) {

    пусть и = поз.исходник

    надо длина(и.начала) > 0 иначе {
        поз.№-строки := 0
        поз.№-символа := 0
        вернуть // TODO: авария?
    }

    // бинарный поиск
    пусть л := 0
    пусть п := длина(и.начала) - 1

    пока истина {
        надо л < п иначе прервать
    
        пусть между = (л + п) / 2
        пусть начало-стр = и.начала[между]
        
        выбор {
        когда смещение > начало-стр: л := между + 1
        когда смещение < начало-стр: п := между - 1
        другое 
            л := между
            прервать
        }
    }

    если смещение < и.начала[л] & л > 0 {
        л--
    }

	поз.№-строки := л + 1
    поз.№-символа := смещение - и.начала[л]
}

