модуль основа

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::файлы"

тип Байты* = []Байт
тип Целые = []Цел64

конст расширение-исходного = ".tri"

тип Исходник* = класс {
    исходный-путь* := ""
    путь-папки* := ""
    имя-файла* := ""
    путь-файла* := "" // путь, используемый для чтения файла (нормализованный?)
    
    ошибка*: мб файлы.Ошибка = пусто
    байты*: Байты = позже

    №: Цел64 = позже  // номер в векторе исходников
    начала = Целые[]
}

тип Исходники = []Исходник

пусть исходники = Исходники[]

//==== исходник из файла

// Если параметр - папка, читает все исходники из папки
// Иначе, читает файл, заданный параметром, и добавляет остальные файлы из папки с нужным расширением
фн подготовить исходники по пути*(исходный-путь: Строка): Исходники {

/*!
	если EnsureFolder(spath) = nil {
		вернуть GetFolderSources(spath, spath)
	}
*/

	пусть путь-папки := файлы.извлечь путь(исходный-путь)
    пусть имя-файла = файлы.извлечь последнее имя(исходный-путь)
	если путь-папки = "" {
		путь-папки := "."
	}

	если ~ строки.есть суффикс(имя-файла, расширение-исходного) {
        добавить общую ошибку("ОКР-ОШ-РАСШИРЕНИЕ", исходный-путь, расширение-исходного)
		вернуть Исходники[]
	}

   пусть остальные = прочитать исходники(исходный-путь, путь-папки, имя-файла)

    пусть исх = прочитать(исходный-путь, путь-папки,  имя-файла)
    пусть список = Исходники[исх]
    список.добавить(остальные...)

	вернуть список
}

фн прочитать исходники(исходный-путь: Строка, путь-папки: Строка, кроме-имени: Строка): Исходники {

    пусть список = Исходники[]

    пусть папка = файлы.новый файл(путь-папки)

    пусть имена = папка.имена в папке()
    надо папка.ошибка?() = пусто
    иначе {
        добавить общую ошибку("ОКР-НЕ-ПАПКА", путь-папки, папка.ошибка?()^.сообщение())
        вернуть список
    }

    пусть № := 0
    пока № < длина(имена)  {
        пусть имя = имена[№]
        если имя # кроме-имени & строки.есть суффикс(имя, расширение-исходного) {
            пусть исх = прочитать(исходный-путь, путь-папки,  имя)
            список.добавить(исх)
        }
        №++
    }

    вернуть список
}

фн прочитать(исходный-путь: Строка, путь-папки: Строка,  имя-файла: Строка): Исходник {

    пусть путь = файлы.собрать путь(путь-папки, имя-файла)
    пусть файл = файлы.новый файл(путь)
    пусть байты = файл.прочитать()
 
    пусть исх = Исходник{
        исходный-путь: исходный-путь,
        путь-папки: путь-папки,
        имя-файла: имя-файла,
        путь-файла: путь,
    
        ошибка: файл.ошибка?(), 
        байты: байты,
        №: длина(исходники) + 1,
    }

    исходники.добавить(исх)

    вернуть исх
}

фн (исх: Исходник) имя папки*(): Строка {
    вернуть файлы.извлечь последнее имя(исх.путь-папки)
}

//==== исходник из строки - для тестирования

фн исходник из строки*(текст: Строка): Исходник {
    пусть и = Исходник{
        исходный-путь: "из строки",
        байты: текст(:Байты),
        №: длина(исходники) + 1,
    }

    исходники.добавить(и)

    вернуть и
}

//==== работа с позицией 

конст (
    маска = 0xFFFF(:Цел64)
    сдвиг = 16
  )

// Запоминает начало новой строки. Смещение - от начала исходного текста в символах
фн (и: Исходник) начало строки*(смещение: Цел64) {
    и.начала.добавить(смещение)
}

// Собирает позицию для смещения в исходном тексте
фн (и: Исходник) позиция*(смещение: Цел64): Цел64 {
    вернуть смещение << сдвиг + и.№
}

фн номер исходника*(позиция: Цел64): Цел64 {
    вернуть позиция :& маска
}

фн исходник по позиции*(позиция: Цел64): Исходник {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника $; ($;). Должен быть [1..$;[", №, позиция(:Слово64), длина(исходники)-1))

    вернуть исходники[№ - 1]
}


//==== распаковка позиции

// TODO: оптимизация - как не выделять память каждый а
тип Позиция* = класс {
    исходник*: Исходник = позже
    №-строки*: Цел64 := 0
    №-символа*: Цел64 := 0
}

// Заполняет поля позиции, если позиция неправильная, то авария
фн распаковать*(позиция: Цел64): Позиция {
    пусть № = позиция :& маска
    
    надо № > 0 & № <= длина(исходники) 
    иначе авария(строки.ф("Неверный номер исходника $; ($;). Должен быть [1..$;[", №, позиция(:Слово64), длина(исходники)-1))
  
    пусть п = Позиция{исходник: исходники[№ - 1]}
    п.вычислить(позиция >> сдвиг)
    
    вернуть п
}

фн (поз: Позиция) вычислить(смещение: Цел64) {

    пусть и = поз.исходник

    надо длина(и.начала) > 0 иначе {
        поз.№-строки := 0
        поз.№-символа := 0
        вернуть // TODO: авария?
    }

    // бинарный поиск
    пусть л := 0
    пусть п := длина(и.начала) - 1

    пока истина {
        надо л < п иначе прервать
    
        пусть между = (л + п) / 2
        пусть начало-стр = и.начала[между]
        
        выбор {
        когда смещение > начало-стр: л := между + 1
        когда смещение < начало-стр: п := между - 1
        другое 
            л := между
            прервать
        }
    }

    если смещение < и.начала[л] & л > 0 {
        л--
    }

	поз.№-строки := л + 1
    поз.№-символа := смещение - и.начала[л]
}

