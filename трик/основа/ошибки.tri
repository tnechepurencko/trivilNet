модуль основа

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::файлы"

импорт "трик/основа/ош-сообщения"


тип Ошибка = класс {
    код-ошибки: Строка = позже
    исходник?: мб Исходник = позже // исходника нет для ошибок уровня программы
    №-строки: Цел64 := 0
    №-символа:  Цел64 = 0
    текст: Строка = позже
}
тип Ошибки = []Ошибка

конст имя-файла-сообщений = "errors.txt"

пусть сообщения = ош-сообщения.Словарь{} 
пусть ошибки := Ошибки[]

//==== Подготовка сообщений

фн подготовить сообщения() {
    //вывод.ф("подготовить сообщения\n")
    
    ошибки := Ошибки[] // можно очистить, когда такое будет
    
    пусть ф = файлы.новый файл(собрать путь настройки(имя-файла-сообщений))
    
    пусть байты = ф.прочитать()
    если ф.ошибка?() # пусто {
        авария(строки.ф("$;", ф.ошибка?()^. сообщение()))
    }

    пусть стр = байты(:Строка)
    пусть список = строки.разобрать(стр, "\n")

    пусть № := 0
    пока № < длина(список) {
        пусть имя := ""
        пусть текст := ""
        если строки.разделить(список[№], ": ", имя, текст) {
            сообщения.добавить(имя, текст)
        }
        №++
    }
    //вывод.ф("число сообщений: $;\n", сообщения.элементов())
}

//==== Добавление ошибок

фн добавить ошибку*(позиция: Цел64, код: Строка, аргументы: ...*): Строка {

    пусть №-строки := 0
    пусть №-символа := 0
    пусть исх = распаковать позицию(позиция, №-строки, №-символа)
    
    пусть элемент? = сообщения.найти(код)
    пусть с-текст := "" 
    
    если элемент? # пусто {
        с-текст := строки.ф(элемент?^.значение, аргументы...)
    } иначе {
        с-текст := строки.ф("сообщение для ошибки '$;' не задано!", код)
    }
    
    пусть текст = строки.ф("$;:$;:$;:$;: $;", исх.путь-файла, №-строки, №-символа, код, с-текст)
    
    пусть ош =Ошибка{
        код-ошибки: код,
        исходник?: исх,
        №-строки: №-строки,
        №-символа:  №-символа,
        текст: текст,
    }

    ошибки.добавить(ош)

    вернуть текст
}

фн добавить общую ошибку*(код: Строка, аргументы: ...*): Строка {

    пусть элемент? = сообщения.найти(код)
    пусть с-текст := "" 
    
    если элемент? # пусто {
        с-текст := строки.ф(элемент?^.значение, аргументы...)
    } иначе {
        с-текст := строки.ф("сообщение для ошибки '$;' не задано!", код)
    }
    
    пусть текст = строки.ф("$;: $;", код, с-текст)
    
    пусть ош =Ошибка{
        код-ошибки: код,
        исходник?: пусто,
        текст: текст,
    }

    ошибки.добавить(ош)

    вернуть текст
}

//==== Показ ошибок

фн позиция для показа*(позиция: Цел64): Строка {

    если номер исходника(позиция) = 0 {
        вернуть "*универсум*"
    }

    пусть №-строки := 0
    пусть №-символа := 0
    пусть исх = распаковать позицию(позиция, №-строки, №-символа)
    
    вернуть строки.ф("$;:$;:$;", исх.исходный-путь, №-строки, №-символа)
}

фн число ошибок*(): Цел64 {
    вернуть длина(ошибки)
}

фн показать ошибки*() {
    пусть № := 0
    пока № < длина(ошибки) {
        вывод.строка(ошибки[№].текст)
        вывод.кс()
        №++
    }
 }