модуль основа

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::файлы"

импорт "трик/основа/ош-сообщения"


тип Ошибка = класс {
    код-ошибки: Строка = позже
    исходник?: мб Исходник = позже // исходника нет для ошибок уровня программы
    №-строки: Цел64 := 0
    №-символа:  Цел64 = 0
    текст: Строка = позже
}
тип Ошибки = []Ошибка

конст имя-файла-сообщений = "errors.txt"

пусть сообщения = ош-сообщения.Словарь{} 
пусть ошибки := Ошибки[]

//==== Подготовка сообщений

фн подготовить сообщения() {
    //вывод.ф("подготовить сообщения\n")
    
    ошибки := Ошибки[] // можно очистить, когда такое будет
    
    пусть ф = файлы.новый файл(собрать путь настройки(имя-файла-сообщений))
    
    пусть байты = ф.прочитать()
    если ф.ошибка?() # пусто {
        авария(строки.ф("$;", ф.ошибка?()^. сообщение()))
    }

    пусть стр = байты(:Строка)
    пусть список = строки.разобрать(стр, "\n")

    пусть № := 0
    пока № < длина(список) {
        пусть пара = строки.разделить(список[№], ": ")
        если длина(пара) = 2 {
            сообщения.добавить(пара[0], пара[1])
        }
        №++
    }
    //вывод.ф("число сообщений: $;\n", сообщения.элементов())
}

//==== Добавление ошибок

фн добавить ошибку*(позиция: Цел64, код: Строка, аргументы: ...*): Строка {

    пусть поз = распаковать(позиция)
    
    пусть элемент? = сообщения.найти(код)
    пусть с-текст := "" 
    
    если элемент? # пусто {
        с-текст := строки.ф(элемент?^.значение, аргументы...)
    } иначе {
        с-текст := строки.ф("сообщение для ошибки '$;' не задано!", код)
    }
    
    пусть текст = строки.ф("$;:$;:$;:$;: $;", поз.исходник.исходный-путь, поз.№-строки, поз.№-символа, код, с-текст)
    
    пусть ош =Ошибка{
        код-ошибки: код,
        исходник?: поз.исходник,
        №-строки: поз.№-строки,
        №-символа:  поз.№-символа,
        текст: текст,
    }

    ошибки.добавить(ош)

    вернуть текст
}

фн добавить общую ошибку*(код: Строка, аргументы: ...*): Строка {

    пусть элемент? = сообщения.найти(код)
    пусть с-текст := "" 
    
    если элемент? # пусто {
        с-текст := строки.ф(элемент?^.значение, аргументы...)
    } иначе {
        с-текст := строки.ф("сообщение для ошибки '$;' не задано!", код)
    }
    
    пусть текст = строки.ф("$;: $;", код, с-текст)
    
    пусть ош =Ошибка{
        код-ошибки: код,
        исходник?: пусто,
        текст: текст,
    }

    ошибки.добавить(ош)

    вернуть текст
}

//==== Показ ошибок


фн позиция для показа*(позиция: Цел64): Строка {
    пусть поз = распаковать(позиция)
    вернуть строки.ф("$;:$;:$;", поз.исходник.исходный-путь, поз.№-строки, поз.№-символа)
}

фн число ошибок*(): Цел64 {
    вернуть длина(ошибки)
}

фн показать ошибки*() {
    пусть № := 0
    пока № < длина(ошибки) {
        вывод.строка(ошибки[№].текст)
        вывод.кс()
        №++
    }
 }