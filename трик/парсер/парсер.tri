модуль парсер

импорт "стд::вывод"
импорт "трик/асд"
импорт "трик/лексер"
импорт "трик/основа"

тип Парсер = класс {
    ле: лексер.Лексер = позже
    мод: асд.Модуль = позже
    
    лек: Цел64 := лексер.НЕОП 
    
    послеКС := ложь
    
    отладка :=ложь
    отл-сдвиг := 0
}

фн разобрать*(исходник: основа.Исходник): асд.Модуль {
    пусть п = Парсер{
        ле: лексер.начать(исходник),
        мод: асд.новый Модуль()
    }
 
    п.взять()
    п.исходный файл()
    
    вернуть п.мод
}

фн (п: Парсер) взять() {
	п.послеКС := ложь
	пока истина {
		п.ле.лексема()
        п.лек := п.ле.лек
		
        выбор п.лек {
		когда лексер.КОН-ФАЙЛ:
			п.послеКС := истина
			вернуть
		когда лексер.КОН-СТР:
			п.послеКС := истина            
		когда лексер.КОММЕНТ-БЛОК:
            // ничего
		когда лексер.КОММЕНТ-СТРОКА:
			п.послеКС := истина
		другое
			вернуть
		}
	}
}

фн (п: Парсер) исходный файл() {

	п.мод.поз := п.ле.поз

	если п.лек = лексер.ИДЕНТ & п.ле.изо = "настройка" {
		п.настройка обобщенного()
	}

	если п.лек # лексер.МОДУЛЬ {
        п.ошибка("ПАР-ОЖИДАЛСЯ", лексер.для показа(лексер.МОДУЛЬ))
		вернуть
	}
	п.взять()
	п.мод.имя := п.идент()
	п.разделитель()

	если п.лек = лексер.ОСТОРОЖНО {
		п.взять()
		п.мод.осторожно? := истина
		п.разделитель()
	}

	п.список импорта()
	п.список описаний()
}

фн (п: Парсер) настройка обобщенного() {
	п.взять()

    пусть поз = п.ле.поз
    пусть путь := ""

	если п.лек = лексер.СТРОКА {
		путь := п.ле.изо
		п.взять()
	} иначе {
        п.нужна лексема(лексер.СТРОКА)
	}

	п.мод.настройка? := асд.Настройка{
		поз: поз,
        путь-импорта: путь
	}

	п.разделитель()
}

фн (п: Парсер) список импорта() {

	пока п.лек = лексер.ИМПОРТ {

		п.взять()
        пусть путь := ""

		если п.лек = лексер.СТРОКА {
			путь := п.ле.изо
			п.взять()
		} иначе {
			п.нужна лексема(лексер.СТРОКА)
		}

		пусть имп = асд.Импорт{
            поз: п.ле.поз,
            путь-импорта: путь,
         }
		п.мод.импорты.добавить(имп)

		п.разделитель()
	}
}

//==== описания


пусть начала-описаний = собрать множество(
    лексер.КОН-ФАЙЛ, 
    лексер.ТИП, лексер.ПУСТЬ, лексер.КОНСТ, лексер.ФН, лексер.ВХОД,
)

фн (п: Парсер) список описаний() {

	пока п.лек # лексер.КОН-ФАЙЛ {
        
        пусть ош := ложь
		выбор п.лек {
/*
		когда лексер.ТИП:
			пусть d = п.parseTypeDecl()
			d.Host = п.мод
			п.мод.Decls = append(п.мод.Decls, d)
		когда лексер.CONST:
			пусть cs = п.parseConstDecls()
			пока _, c := range cs {
				c.Host = п.мод
				п.мод.Decls = append(п.мод.Decls, c)
			}
		когда лексер.ПУСТЬ:
			пусть d = п.parseVarDecl()
			d.Host = п.мод
			п.мод.Decls = append(п.мод.Decls, d)
		когда лексер.FN:
			пусть d = п.parseFn()
			d.Host = п.мод
			п.мод.Decls = append(п.мод.Decls, d)
*/            
		когда лексер.ВХОД:
			п.вход!()
		другое
			п.ошибка("ПАР-ОШ-ОПИСАНИЕ", лексер.для показа(п.лек))
            п.пропустить до(начала-описаний)
            ош := истина
		}

        если ~ ош { п.разделитель() }
	}
}

//==== константы

/*
фн (п: Парсер) описание констант() []*асд.ConstDecl {
	если п.отладка {
		defer un(trace(p, "Описание констант"))
	}

	п.взять()

	если п.лек = ExportMark | п.лек = лексер.LPAR {
		вернуть п.parseConstGroup()
	}

	пусть c = п.parseSingleConst()

	пусть cs = make([]*асд.ConstDecl, 1)
	cs[0] = c

	вернуть cs
}

фн (п: Парсер) parseSingleConst() *асд.ConstDecl {

	пусть n = &асд.ConstDecl{
		DeclBase: асд.DeclBase{Pos: п.ле.поз},
	}

	n.Name = п.идент()
	если п.parseExportMark() {
		n.Exported = истина
	}

	если п.лек = лексер.COLON {
		п.взять()
		n.Typ = п.parseTypeRef()
	}

	п.нужна лексема(лексер.EQ)
	n.Value = п.parseExpression() //~ конст expression

	вернуть n
}

фн (п: Парсер) parseNextConst() *асд.ConstDecl {

	пусть n = &асд.ConstDecl{
		DeclBase: асд.DeclBase{Pos: п.ле.поз},
	}

	n.Name = п.идент()
	если п.parseExportMark() {
		n.Exported = истина
	}

	если п.лек = лексер.COLON {
		п.взять()
		n.Typ = п.parseTypeRef()

		п.нужна лексема(лексер.EQ)
		n.Value = п.parseExpression()

	} иначе если п.лек = лексер.EQ {
		п.взять()
		n.Value = п.parseExpression()
	}

	вернуть n
}

фн (п: Парсер) parseConstGroup() []*асд.ConstDecl {

	пусть exported = ложь
	если п.лек = ExportMark {
		exported = истина
		п.взять()
	}

	п.нужна лексема(лексер.LPAR)

	пусть cs = make([]*асд.ConstDecl, 0)
	пусть c = п.parseSingleConst()

	c.Exported = exported
	cs = append(cs, c)

	пока п.лек # лексер.RPAR & п.лек # лексер.EOF {
		п.разделитель()

		c = п.parseNextConst()
		если exported {
			c.Exported = истина
		}
		cs = append(cs, c)
	}

	п.нужна лексема(лексер.RPAR)

	p.completeConstGroup(cs)

	вернуть cs
}

фн (п: Парсер) completeConstGroup(cs []*асд.ConstDecl) {

	пусть base *асд.ConstDecl
	пусть first = истина
	пусть val Цел64

	пока _, c := range cs {
		если c.Value # nil {
			base = c
			first = истина
		} иначе {
			если first { // первая авто константа

				literal, ok := base.Value.(*асд.LiteralExpr)

				если ok & literal.Kind = асд.Lit_Int {
					val = literal.IntVal
				} иначе {
					п.ошибка(base.Pos, "ПАР-ОШ-КОНСТ-БАЗА")
					val = 0
				}
				first = ложь
			}

			c.Typ = base.Typ

			val++
			c.Value = &асд.LiteralExpr{
				ExprBase: асд.ExprBase{Pos: c.Pos},
				Kind:     асд.Lit_Int,
				IntVal:   val,
			}
		}
	}

}
*/

//==== переменные

/*
фн (п: Парсер) описание переменной() *асд.VarDecl {
	если п.отладка {
		defer un(trace(p, "Описание переменной"))
	}

	п.взять()

	пусть n = &асд.VarDecl{
		DeclBase: асд.DeclBase{Pos: п.ле.поз},
	}

	n.Name = п.идент()
	если п.parseExportMark() {
		n.Exported = истина
	}

	если п.лек = лексер.COLON {
		п.взять()
		n.Typ = п.parseTypeRef()
	}

	если п.лек = лексер.EQ {
		n.AssignOnce = истина
		п.взять()
	} иначе если п.лек = лексер.ASSIGN {
		п.взять()
	} иначе {
		env.AddError(п.ле.поз, "ПАР-ПЕРЕМ-ИНИТ")
		вернуть n
	}

	если п.лек = лексер.LATER {
		n.Later = истина
		п.взять()
	} иначе {
		n.Init = п.parseExpression()
	}

	вернуть n
}
*/

//==== вход

фн (п: Парсер) вход!() {

	пусть о = асд.Вход{
		поз: п.ле.поз,
	}

	п.взять()
	п.список операторов(о.операторы)

	если п.мод.вход? # пусто {
		п.ошибка("ПАР-ДУБЛЬ-ВХОД", основа.позиция для показа(п.мод.вход?^.поз))
		вернуть
	}

	п.мод.вход? := о
}

//==== простые

фн (п: Парсер) идент(): Строка {
	надо п.лек = лексер.ИДЕНТ 
    иначе {
    		п.нужна лексема(лексер.ИДЕНТ)
            вернуть "_"
    }
    пусть имя = п.ле.изо
    п.взять()
	вернуть имя
}

фн (п: Парсер) разделитель() {
	если п.лек = лексер.ТОЧКА-ЗАП {
		п.взять()
	} иначе если п.послеКС {
		// есть
	} иначе {
		п.ошибка("ПАР-ОШ-РАЗД", лексер.для показа(п.лек))
	}
}
