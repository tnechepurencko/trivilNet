модуль парсер

импорт "стд::вывод"
импорт "трик/асд"
импорт "трик/лексер"
импорт "трик/основа"

тип Парсер = класс {
    ле: лексер.Лексер = позже
    мод: асд.Модуль = позже
    
    лек: Цел64 := лексер.НЕОП 
    поз: Цел64 := 0
    
    послеКС := ложь
    
    осторожно? := ложь
    число-осторожно := 0
    
    отладка :=ложь
    отл-уровень := 0
}

фн разобрать*(исходник: основа.Исходник): асд.Модуль {

    пусть ле = лексер.начать(исходник)

    пусть п = Парсер{
        ле: ле,
        мод: асд.новый Модуль(ле.поз),
        отладка: основа.отладка парсера(),
    }
 
    п.взять()
    п.исходный файл()
    
    вернуть п.мод
}

фн (п: Парсер) взять() {
	п.послеКС := ложь
	пока истина {
		п.ле.лексема()
        п.лек := п.ле.лек
        п.поз := п.ле.поз
		
        выбор п.лек {
		когда лексер.КОН-ФАЙЛ:
			п.послеКС := истина
			вернуть
		когда лексер.КОН-СТР:
			п.послеКС := истина            
		когда лексер.КОММЕНТ-БЛОК:
            // ничего
		когда лексер.КОММЕНТ-СТРОКА:
			п.послеКС := истина
		другое
//            /*
            если п.отладка {
                пусть №-строки := 0
                пусть №-символа := 0
                пусть исх = основа.распаковать позицию(п.поз, №-строки, №-символа)
                
                если п.лек = лексер.ИДЕНТ {
                    вывод.ф("$;:$; идент '$;'\n", №-строки, №-символа, п.ле.изо)
                } иначе {
                    вывод.ф("$;:$; $;\n", №-строки, №-символа, лексер.для показа(п.лек))
                }
            }
//            */    
			вернуть
		}
	}
}

фн (п: Парсер) исходный файл() {

	если п.лек = лексер.ИДЕНТ & п.ле.изо = "настройка" {
		п.настройка обобщенного()
	}

	если п.лек # лексер.МОДУЛЬ {
        п.ошибка("ПАР-ОЖИДАЛСЯ", лексер.для показа(лексер.МОДУЛЬ))
		вернуть
	}
	п.взять()
	п.мод.имя := п.идент()
	п.разделитель()

	если п.лек = лексер.ОСТОРОЖНО {
		п.взять()
		п.осторожно? := истина
		п.разделитель()
	}

	п.список импорта()
	п.список описаний()
    
	если п .осторожно? & п.число-осторожно = 0 {
		п.ошибка в позиции(п.мод.поз, "ПАР-ОШ-ОСТОРОЖНО-НЕ-ИСП")
	}    
}

фн (п: Парсер) настройка обобщенного() {
	п.взять()

    пусть поз = п.поз
    пусть путь := ""

	если п.лек = лексер.СТРОКА {
		путь := п.ле.изо
		п.взять()
	} иначе {
        п.нужна лексема(лексер.СТРОКА)
	}

	п.мод.настройка := асд.Настройка{
		поз: поз,
        путь-импорта: путь
	}

	п.разделитель()
}

фн (п: Парсер) список импорта() {

	пока п.лек = лексер.ИМПОРТ {

		п.взять()
        пусть путь := ""

		если п.лек = лексер.СТРОКА {
			путь := п.ле.изо
			п.взять()
		} иначе {
			п.нужна лексема(лексер.СТРОКА)
		}

		пусть имп = асд.Импорт{
            поз: п.поз,
            путь-импорта: путь,
         }
		п.мод.импорты.добавить(имп)

		п.разделитель()
	}
}

//==== описания

пусть начало-описаний = собрать множество(
    лексер.КОН-ФАЙЛ, 
    лексер.ТИП, лексер.ПУСТЬ, лексер.КОНСТ, лексер.ФН, лексер.ВХОД,
)

фн (п: Парсер) список описаний() {

	пока п.лек # лексер.КОН-ФАЙЛ {
        
        пусть ош := ложь
		выбор п.лек {
		когда лексер.ТИП:
			пусть оп = п.описание-типа()
            п.мод.описания.добавить(оп)
		когда лексер.КОНСТ:
			пусть список = п.описание констант()
            цикл к среди список {
                п.мод.описания.добавить(к)       
			}
		когда лексер.ПУСТЬ:
			пусть оп = п.описание-переменной()
            п.мод.описания.добавить(оп)
		когда лексер.ФН:
			пусть оп = п.описание функции()
            п.мод.описания.добавить(оп)
		когда лексер.ВХОД:
			п.вход!()
		другое
			п.ошибка("ПАР-ОШ-ОПИСАНИЕ", лексер.для показа(п.лек))
            п.пропустить до(начало-описаний)
            ош := истина
		}

        если ~ ош { п.разделитель() }
	}
}

//==== константы

тип Константы = []асд.ОписаниеКонстанты

фн (п: Парсер) описание констант(): Константы {

	п.взять()

	если п.лек = лексер.ЭКСПОРТ | п.лек = лексер.КРУГ-Л {
		вернуть п.описание группы констант()
	}

	пусть кон = п.описание константы()

    вернуть Константы[кон]
}

фн (п: Парсер) описание константы(): асд.ОписаниеКонстанты {

    пусть кон = асд.ОписаниеКонстанты{
        поз: п.поз,
        имя: п.идент(),
        экспорт: п.экспорт(),
    }

    если п.лек = лексер.ДВОЕТОЧИЕ {
		п.взять()
		кон.Т := п.указание-типа()
	}

	п.нужна лексема(лексер.РАВНО)
    
    кон.значение := п.выражение()
    
	вернуть кон
}

фн (п: Парсер) описание группы констант(): Константы {

	пусть экспорт := ложь
	если п.лек = лексер.ЭКСПОРТ {
		экспорт := истина
		п.взять()
	}

	п.нужна лексема(лексер.КРУГ-Л)

	пусть список  = Константы[]
    
	пусть кон := п.описание константы()
    если экспорт { // может быть выставлено для отдельных констант
        кон.экспорт := истина 
    }
    список.добавить(кон)

	пока п.лек # лексер.КРУГ-П & п.лек # лексер.КОН-ФАЙЛ {
		п.разделитель()

		кон := п.следующая константа()
		если экспорт {
			 кон.экспорт := истина
		}
        список.добавить(кон)
	}

	п.нужна лексема(лексер.КРУГ-П)

    п.обработать группу констант(список)

	вернуть список
}

фн (п: Парсер) следующая константа(): асд.ОписаниеКонстанты {

	пусть кон = асд.ОписаниеКонстанты{
        поз: п.поз,
	}

	кон.имя := п.идент()
    кон.экспорт := п.экспорт()

	если п.лек = лексер.ДВОЕТОЧИЕ {
		п.взять()
   		кон.Т := п.указание-типа()

		п.нужна лексема(лексер.РАВНО)
        кон.значение := п.выражение()

	} иначе если п.лек = лексер.РАВНО {
		п.взять()
        кон.значение := п.выражение()
	}

	вернуть кон
}

фн (п: Парсер) обработать группу констант(список: Константы) {

    надо длина(список) > 0 иначе вернуть

	пусть база := список[0]
	пусть первая := истина
	пусть значение := 0

    пусть № := 1
	пока № < длина(список)  {
        пусть кон = список[№]
		если кон.значение # пусто {
			база := кон
			первая := истина
		} иначе {
			если первая { // первая авто константа
            
                пусть ош := истина
                если база.значение типа асд.Литерал {
                    пусть лит = база.значение(:асд.Литерал)
                    если лит.вид = асд.Лит-Цел {
                        значение := лит.цел
                        ош := ложь
                    }
                }
                если ош {
					п.ошибка в позиции(база.поз, "ПАР-ОШ-КОНСТ-БАЗА")
                }
				первая := ложь
			}

			кон.Т := база.Т

			значение++
            кон.значение := асд.Литерал{
                поз: кон.поз,
                вид: асд.Лит-Цел,
                цел: значение,
            }
		}
        №++
	}
}

//==== переменные

фн (п: Парсер) описание-переменной(): асд.ОписаниеПеременной {

	п.взять()

	пусть пер = асд.ОписаниеПеременной{
        поз: п.поз,
	}

	пер.имя := п.идент()
    пер.экспорт := п.экспорт()

	если п.лек = лексер.ДВОЕТОЧИЕ {
		п.взять()
		пер.Т := п.указание-типа()
	}

	если п.лек = лексер.РАВНО {
		пер.одно-присваивание := истина
		п.взять()
	} иначе если п.лек = лексер.ПРИСВОИТЬ {
		п.взять()
	} иначе {
		п.ошибка("ПАР-ПЕРЕМ-ИНИТ")
		вернуть пер
	}

	если п.лек = лексер.ПОЗЖЕ {
		пер.задать-позже := истина
		п.взять()
	} иначе {
		пер.значение := п.выражение()
	}

	вернуть пер
}

//==== вход

фн (п: Парсер) вход!() {
    если п.отладка { п.войти("вход") }
    
    пусть поз = п.поз

	п.взять()
	пусть о = асд.Вход{
		поз: поз,
        тело: п.блок(),
	}

    если п.отладка { п.выйти() }

	если п.мод.вход? # пусто {
		п.ошибка("ПАР-ДУБЛЬ-ВХОД", основа.позиция для показа(п.мод.вход?^.поз))
		вернуть
	}

	п.мод.вход? := о
}

//==== общие

фн (п: Парсер) идент(): Строка {
	надо п.лек = лексер.ИДЕНТ 
    иначе {
    		п.нужна лексема(лексер.ИДЕНТ)
            вернуть "_"
    }
    пусть имя = п.ле.изо
    п.взять()
	вернуть имя
}

фн (п: Парсер) разделитель() {
	если п.лек = лексер.ТОЧКА-ЗАП {
		п.взять()
	} иначе если п.послеКС {
		// есть
	} иначе {
		п.ошибка("ПАР-ОШ-РАЗД", лексер.для показа(п.лек))
	}
}

фн (п: Парсер) экспорт(): Лог {
	если п.лек = лексер.ЭКСПОРТ {
		п.взять()
		вернуть истина
	}
	вернуть ложь
}

фн (п: Парсер) модификатор(): асд.Модификатор {

	пусть мф = асд.Модификатор{
		имя:  п.ле.изо,
	}
	п.взять()

	если п.лек # лексер.КРУГ-Л {
		вернуть мф
	}

	п.взять()

	пока п.лек # лексер.КРУГ-П & п.лек # лексер.КОН-ФАЙЛ {
	
        пусть имя := ""
		пусть значение := ""

		если п.лек = лексер.СТРОКА {
			имя := п.ле.изо
			п.взять()
		} иначе {
			п.нужна лексема(лексер.СТРОКА)
		}

		п.нужна лексема(лексер.ДВОЕТОЧИЕ)

		если п.лек = лексер.СТРОКА {
			значение := п.ле.изо
			п.взять()
		} иначе {
			п.нужна лексема(лексер.СТРОКА)
		}

        мф.атрибуты.добавить(асд.Атрибут{имя: имя, значение: значение})

		если п.лек = лексер.КРУГ-П {
			прервать
		}
		п.нужна лексема(лексер.ЗАПЯТАЯ)
	}
	п.нужна лексема(лексер.КРУГ-П)

	вернуть мф
}
