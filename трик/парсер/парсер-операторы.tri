модуль парсер

импорт "стд::вывод"
импорт "трик/асд"
импорт "трик/лексер"
//импорт "трик/основа"

пусть начало-простого-оператора = собрать множество(
    лексер.ИДЕНТ, лексер.КРУГ-Л,

    // литералы
    лексер.ЦЕЛ, лексер.ВЕЩ, лексер.СТРОКА, лексер.СИМВОЛ,

    // унарные операции
    лексер.СЛОЖИТЬ, лексер.ВЫЧЕСТЬ, лексер.НЕ, лексер.БИТ-НЕ
)

пусть начало-оператора = собрать множество(
    лексер.КОН-ФАЙЛ,
    лексер.ФИГ-П,

    лексер.ЕСЛИ, лексер.НАДО, лексер.ВЫБОР, лексер.ПОКА,
    лексер.ВЕРНУТЬ, лексер.ПРЕРВАТЬ, лексер.АВАРИЯ
)

пусть конец-блока = собрать множество(
    лексер.КОН-ФАЙЛ,
    лексер.ФИГ-П
)

пусть конец-варианта-выбора = собрать множество(
    лексер.КОН-ФАЙЛ,  лексер.ФИГ-П,

    лексер.КОГДА, лексер.ДРУГОЕ
)

фн (п: Парсер) блок(): асд.СписокОператоров {

    если п.лек # лексер.ФИГ-Л {
        п.нужна лексема(лексер.ФИГ-Л)
        
        вернуть  асд.СписокОператоров{
            поз: п.поз,
        }
    }
    п.взять()

    пусть тек = п.список операторов(конец-блока)

    п.нужна лексема(лексер.ФИГ-П)

    вернуть тек
}

фн (п: Парсер) список операторов(стоп: Словарь): асд.СписокОператоров {

    пусть тек = асд.СписокОператоров{
            поз: п.поз,
    }

    пока стоп.найти(п.лек) = пусто {
        пусть оп = п.оператор()
        тек.операторы.добавить(оп)

        надо стоп.найти(п.лек) = пусто иначе  прервать
        п.разделитель()
    }

    вернуть тек
}


//==== оператор

фн (п: Парсер) оператор(): асд.Оператор {

    выбор п.лек {
    когда лексер.ПУСТЬ:
        вернуть асд.ОператорОписание{
            поз: п.поз,
            описание: п.описание-переменной(),
        }
    когда лексер.ЕСЛИ:
        вернуть п.оператор-если()
    когда лексер.НАДО:
        вернуть п.оператор-надо()
    когда лексер.ПОКА:
        вернуть п.оператор-пока()
/*        
    когда лексер.ВЫБОР:
        вернуть п.parseSelect()
*/        
    когда лексер.ВЕРНУТЬ:
        вернуть п.оператор-вернуть()
    когда лексер.ПРЕРВАТЬ:
        вернуть п.оператор-прервать()
    когда лексер.АВАРИЯ:
        вернуть п.оператор-авария()
    другое
        если начало-простого-оператора.найти(п.лек) # пусто {
            вернуть п.простой оператор()
        }
        п.ошибка("ПАР-ОШ-ОПЕРАТОР", лексер.для показа(п.лек))
        п.пропустить до(начало-оператора)
        вернуть асд.ОшОператор{поз: п.поз}
    }

//    вернуть асд.Оператор{поз: 0}
}

фн (п: Парсер) простой оператор(): асд.Оператор {

    пусть выр = п.выражение()

    выбор п.лек {
    когда лексер.ПРИСВОИТЬ:
        вернуть п.присвоить(выр)
    когда лексер.УВЕЛИЧИТЬ:
        пусть тек = асд.ОператорУвеличить{
            поз: п.поз,
            Л: выр,
        }
        п.взять()
        вернуть тек
    когда лексер.УМЕНЬШИТЬ:
        пусть тек = асд.ОператорУменьшить{
            поз: п.поз,
            Л: выр,
        }
        п.взять()
        вернуть тек
    другое
        вернуть асд.ОператорВыражение{
            поз: п.поз,
            выражение: выр,
        }
    }
}

фн (п: Парсер) присвоить(левое: асд.Выражение): асд.Оператор {
    п.взять()
    пусть правое = п.выражение()

    вернуть асд.ОператорПрисвоить{
        поз: п.поз,
        Л: левое,
        П: правое,
    }
}

//==== управление

фн (п: Парсер) оператор-если(): асд.Оператор {

    пусть поз = п.поз
    п.взять()
    
    пусть условие = п.выражение()
    пусть если-да = п.блок()

    пусть тек = асд.ОператорЕсли{
        поз: поз,
        условие: условие,
        если-да: если-да,
    }

    если п.лек # лексер.ИНАЧЕ {
        вернуть тек
    }

    п.взять()

    если п.лек = лексер.ЕСЛИ {
        тек.если-нет := п.оператор-если()
    } иначе {
        тек.если-нет := п.блок()
    }

    вернуть тек
}

фн (п: Парсер) оператор-надо(): асд.Оператор {

    пусть поз = п.поз
    п.взять()

    пусть условие = п.выражение()
    п.нужна лексема(лексер.ИНАЧЕ)

    вернуть асд.ОператорНадо{
        поз: поз,
        условие: условие,
        если-нет: п.завершающий оператор(),
    }
}

фн (п: Парсер) завершающий оператор(): асд.Оператор {
    выбор п.лек {
    когда лексер.ВЕРНУТЬ:
        вернуть п.оператор-вернуть()
    когда лексер.ПРЕРВАТЬ:
        вернуть п.оператор-прервать()
    когда лексер.АВАРИЯ:
        вернуть п.оператор-авария()
    другое
        вернуть п.блок()
    }
}

фн (п: Парсер) оператор-пока(): асд.Оператор {

    пусть поз = п.поз
    п.взять()

    пусть условие = п.выражение()
    пусть блок = п.блок()

    вернуть асд.ОператорПока{
        поз: поз,
        условие: условие,
        тело: блок,
    }
}

/*
//== оператор выбора

фн (п: Парсер) parseSelect(): асд.Оператор {
    п.взять()
    если п.лек = лексер.VAR | п.лек = лексер.TYPE {
        вернуть п.parseSelectType()
    }
    вернуть п.parseSelectExpr()
}

//== оператор выбора по выражению

фн (п: Парсер) parseSelectExpr(): асд.Оператор {
    если п.отладка {
        defer un(trace(p, "Оператор выбора по выражению"))
    }
    пусть n = &асд.Select{
        поз: п.поз,
    }

    если п.лек = лексер.ФИГ-Л {
        п.взять()
    } иначе {
        n.X = п.выражение()
        п.нужна лексема(лексер.ФИГ-Л)
    }

    пока п.лек = лексер.WHEN {
        пусть c = п.parseCaseExpr()
        n.Cases = append(n.Cases, c)
    }

    если п.лек = лексер.OTHER {
        п.взять()
        n.Else = п.parseStatementList(endStatementSeq)
    }
    п.нужна лексема(лексер.ФИГ-П)

    вернуть n
}

фн (п: Парсер) parseCaseExpr(): асд.Case {
    если п.отладка {
        defer un(trace(p, "выбор когда"))
    }

    пусть c = &асд.Case{
        поз: п.поз,
        Exprs:         make([]асд.Выражение, 0),
    }
    п.взять()

    пока {
        пусть x = п.выражение()
        c.Exprs = append(c.Exprs, x)
        если п.лек # лексер.ЗАПЯТАЯ {
            прервать
        }
        п.взять()
    }
    п.нужна лексема(лексер.ДВОЕТОЧИЕ)

    c.Seq = п.parseStatementList(endWhenCase)

    вернуть c
}

//== оператор выбора по типу

фн (п: Парсер) parseSelectType(): асд.Оператор {
    если п.отладка {
        defer un(trace(p, "Оператор выбора по типу"))
    }

    пусть n = &асд.SelectType{
        поз: п.поз,
    }

    пусть пустьPos = 0

    если п.лек = лексер.VAR {
        п.взять()
        пустьPos = п.поз
        n.VarIdent = п.идент()
        п.нужна лексема(лексер.ДВОЕТОЧИЕ)
    }
    п.нужна лексема(лексер.TYPE)

    n.X = п.выражение()
    п.нужна лексема(лексер.ФИГ-Л)

    пока п.лек = лексер.WHEN {
        пусть c = п.parseCaseType()
        если n.VarIdent # "" {
            c.Var = &асд.VarDecl{
                DeclBase: асд.ОписаниеBase{
                    Pos:  пустьPos,
                    Name: n.VarIdent,
                },
                AssignOnce: истина,
            }
        }

        n.Cases = append(n.Cases, c)
    }

    если п.лек = лексер.OTHER {
        п.взять()
        n.Else = п.parseStatementList(endStatementSeq)
    }
    п.нужна лексема(лексер.ФИГ-П)

    вернуть n
}

фн (п: Парсер) parseCaseType(): асд.CaseType {
    если п.отладка {
        defer un(trace(p, "выбор когда по типу"))
    }

    пусть c = &асд.CaseType{
        поз: п.поз,
        Types:         make([]асд.Тип, 0),
    }
    п.взять()

    пока {
        пусть x = п.указание-типа()
        c.Types = append(c.Types, x)
        если п.лек # лексер.ЗАПЯТАЯ {
            прервать
        }
        п.взять()
    }
    п.нужна лексема(лексер.ДВОЕТОЧИЕ)

    c.Seq = п.parseStatementList(endWhenCase)

    вернуть c
}
*/

фн (п: Парсер) оператор-вернуть(): асд.Оператор {

    пусть тек = асд.ОператорВернуть{
        поз: п.поз,
    }
    п.взять()

    если п.послеКС | п.лек = лексер.ТОЧКА-ЗАП | п.лек = лексер.ФИГ-П {
        вернуть тек
    }

    тек.В := п.выражение()

    вернуть тек
}

фн (п: Парсер) оператор-прервать(): асд.Оператор {

    пусть тек = асд.ОператорПрервать{
        поз: п.поз,
    }
    п.взять()

    вернуть тек
}

фн (п: Парсер) оператор-авария(): асд.Оператор {

    п.взять()
    п.нужна лексема(лексер.КРУГ-Л)
    пусть выр = п.выражение()
    п.нужна лексема(лексер.КРУГ-П)

    вернуть асд.ОператорАвария{
        поз: п.поз,
        В: выр,
    }
}


