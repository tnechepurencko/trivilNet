модуль парсер

импорт "стд::вывод"
импорт "трик/асд"
импорт "трик/лексер"
//импорт "трик/основа"

пусть начало-простого-оператора = собрать множество(
    лексер.ИДЕНТ, лексер.КРУГ-Л,

    // литералы
    лексер.ЦЕЛ, лексер.ВЕЩ, лексер.СТРОКА, лексер.СИМВОЛ,

    // унарные операции
    лексер.СЛОЖИТЬ, лексер.ВЫЧЕСТЬ, лексер.НЕ, лексер.БИТ-НЕ
)

пусть начало-оператора = собрать множество(
    лексер.КОН-ФАЙЛ,
    лексер.ФИГ-П,

    лексер.ЕСЛИ, лексер.НАДО, лексер.ВЫБОР, лексер.ПОКА,
    лексер.ВЕРНУТЬ, лексер.ПРЕРВАТЬ, лексер.АВАРИЯ
)

пусть конец-блока = собрать множество(
    лексер.КОН-ФАЙЛ,
    лексер.ФИГ-П
)

пусть конец-варианта-выбора = собрать множество(
    лексер.КОН-ФАЙЛ,  лексер.ФИГ-П,

    лексер.КОГДА, лексер.ДРУГОЕ
)

фн (п: Парсер) блок(): асд.СписокОператоров {

    если п.лек # лексер.ФИГ-Л {
        п.нужна лексема(лексер.ФИГ-Л)
        
        вернуть  асд.СписокОператоров{
            поз: п.поз,
        }
    }
    п.взять()

    пусть тек = п.список операторов(конец-блока)

    п.нужна лексема(лексер.ФИГ-П)

    вернуть тек
}

фн (п: Парсер) список операторов(стоп: Словарь): асд.СписокОператоров {

    пусть тек = асд.СписокОператоров{
            поз: п.поз,
    }

    пока стоп.найти(п.лек) = пусто {
        пусть оп = п.оператор()
        тек.операторы.добавить(оп)

        надо стоп.найти(п.лек) = пусто иначе  прервать
        п.разделитель()
    }

    вернуть тек
}

//==== оператор

фн (п: Парсер) оператор(): асд.Оператор {

    выбор п.лек {
    когда лексер.ПУСТЬ:
        вернуть асд.ОператорОписание{
            поз: п.поз,
            описание: п.описание-переменной(),
        }
    когда лексер.ЕСЛИ:
        вернуть п.оператор-если()
    когда лексер.НАДО:
        вернуть п.оператор-надо()
    когда лексер.ВЫБОР:
        вернуть п.оператор-выбор()
    когда лексер.ПОКА:
        вернуть п.оператор-пока()
    когда лексер.ЦИКЛ:
        вернуть п.оператор-цикл()
    когда лексер.ВЕРНУТЬ:
        вернуть п.оператор-вернуть()
    когда лексер.ПРЕРВАТЬ:
        вернуть п.оператор-прервать()
    когда лексер.АВАРИЯ:
        вернуть п.оператор-авария()
    другое
        если начало-простого-оператора.найти(п.лек) # пусто {
            вернуть п.простой оператор()
        }
        п.ошибка("ПАР-ОШ-ОПЕРАТОР", лексер.для показа(п.лек))
        п.пропустить до(начало-оператора)
        вернуть асд.ОшОператор{поз: п.поз}
    }

//    вернуть асд.Оператор{поз: 0}
}

фн (п: Парсер) простой оператор(): асд.Оператор {

    пусть выр = п.выражение()

    выбор п.лек {
    когда лексер.ПРИСВОИТЬ:
        вернуть п.присвоить(выр)
    когда лексер.УВЕЛИЧИТЬ:
        пусть тек = асд.ОператорУвеличить{
            поз: п.поз,
            Л: выр,
        }
        п.взять()
        вернуть тек
    когда лексер.УМЕНЬШИТЬ:
        пусть тек = асд.ОператорУменьшить{
            поз: п.поз,
            Л: выр,
        }
        п.взять()
        вернуть тек
    другое
        вернуть асд.ОператорВыражение{
            поз: п.поз,
            выражение: выр,
        }
    }
}

фн (п: Парсер) присвоить(левое: асд.Выражение): асд.Оператор {
    п.взять()
    пусть правое = п.выражение()

    вернуть асд.ОператорПрисвоить{
        поз: п.поз,
        Л: левое,
        П: правое,
    }
}

//==== управление

фн (п: Парсер) оператор-если(): асд.Оператор {

    пусть поз = п.поз
    п.взять()
    
    пусть условие = п.выражение()
    пусть если-да = п.блок()

    пусть тек = асд.ОператорЕсли{
        поз: поз,
        условие: условие,
        если-да: если-да,
    }

    если п.лек # лексер.ИНАЧЕ {
        вернуть тек
    }

    п.взять()

    если п.лек = лексер.ЕСЛИ {
        тек.если-нет := п.оператор-если()
    } иначе {
        тек.если-нет := п.блок()
    }

    вернуть тек
}

фн (п: Парсер) оператор-надо(): асд.Оператор {

    пусть поз = п.поз
    п.взять()

    пусть условие = п.выражение()
    п.нужна лексема(лексер.ИНАЧЕ)

    вернуть асд.ОператорНадо{
        поз: поз,
        условие: условие,
        если-нет: п.завершающий оператор(),
    }
}

фн (п: Парсер) завершающий оператор(): асд.Оператор {
    выбор п.лек {
    когда лексер.ВЕРНУТЬ:
        вернуть п.оператор-вернуть()
    когда лексер.ПРЕРВАТЬ:
        вернуть п.оператор-прервать()
    когда лексер.АВАРИЯ:
        вернуть п.оператор-авария()
    другое
        вернуть п.блок()
    }
}

//== оператор выбора

фн (п: Парсер) оператор-выбор(): асд.Оператор {
    п.взять()
    если п.лек = лексер.ПУСТЬ | п.лек = лексер.ТИП {
        вернуть п.выбор-по-типу()
    }
    вернуть п.выбор-по-выражению()
}

//== оператор выбора по выражению

фн (п: Парсер) выбор-по-выражению(): асд.Оператор {

    пусть тек = асд.ОператорВыбор{
        поз: п.поз,
    }

    если п.лек = лексер.ФИГ-Л {
        п.взять()
    } иначе {
        тек.В := п.выражение()
        п.нужна лексема(лексер.ФИГ-Л)
    }

    пока п.лек = лексер.КОГДА {
        пусть вар = п.вариант-выражение()
        тек.варианты.добавить(вар)
    }

    если п.лек = лексер.ДРУГОЕ {
        п.взять()
        тек.если-нет := п.список операторов(конец-блока)
    }
    п.нужна лексема(лексер.ФИГ-П)

    вернуть тек
}

фн (п: Парсер) вариант-выражение(): асд.Вариант {

    пусть поз = п.поз
    п.взять()

    пусть выражения = асд.Выражения[]
    пока истина {
        пусть выр = п.выражение()
        выражения.добавить(выр)
        
        если п.лек # лексер.ЗАПЯТАЯ {
            прервать
        }
        п.взять()
    }
    п.нужна лексема(лексер.ДВОЕТОЧИЕ)

    вернуть асд.Вариант{
        поз: поз,
        выражения: выражения,
        тело: п.список операторов(конец-варианта-выбора)
    }
}

//== оператор выбора по типу

фн (п: Парсер) выбор-по-типу(): асд.Оператор {

    пусть перем-поз := 0
    пусть имя-переменной := ""

    если п.лек = лексер.ПУСТЬ {
        п.взять()
        перем-поз := п.поз
        имя-переменной := п.идент()
        п.нужна лексема(лексер.ДВОЕТОЧИЕ)
    }
    п.нужна лексема(лексер.ТИП)

    пусть тек = асд.ОператорВыборПоТипу{
        поз: п.поз,
        имя-переменной: имя-переменной,
        В: п.выражение(),
    }
    п.нужна лексема(лексер.ФИГ-Л)

    пока п.лек = лексер.КОГДА {
        пусть вар = п.вариант-тип()
        
        если тек.имя-переменной # "" {
            вар.переменная := асд.ОписаниеПеременной{
                поз:  перем-поз,
                имя: тек.имя-переменной,
                одно-присваивание: истина,
            }
        }
        тек.варианты.добавить(вар)
    }

    если п.лек = лексер.ДРУГОЕ {
        п.взять()
        тек.если-нет := п.список операторов(конец-блока)
    }
    п.нужна лексема(лексер.ФИГ-П)

    вернуть тек
}

фн (п: Парсер) вариант-тип(): асд.ВариантТипа {

    пусть поз = п.поз
    п.взять()

    пусть типы = асд.Типы[]
    пока истина {
        пусть т = п.указание-типа()
        типы.добавить(т)
        если п.лек # лексер.ЗАПЯТАЯ {
            прервать
        }
        п.взять()
    }
    п.нужна лексема(лексер.ДВОЕТОЧИЕ)

    вернуть асд.ВариантТипа{
        поз: п.поз,
        типы: типы,
        тело: п.список операторов(конец-варианта-выбора)
    }
}

//==== циклы

фн (п: Парсер) оператор-пока(): асд.Оператор {

    пусть поз = п.поз
    п.взять()

    пусть условие = п.выражение()
    пусть блок = п.блок()

    вернуть асд.ОператорПока{
        поз: поз,
        условие: условие,
        тело: блок,
    }
}

// Не делаю пока возможности задавать тип переменных
фн (п: Парсер) оператор-цикл(): асд.Оператор {

    пусть поз = п.поз
	п.взять()
    
    пусть индекс: мб асд.ОписаниеПеременной := пусто 
    пусть элемент: мб асд.ОписаниеПеременной := пусто 

	если п.лек = лексер.КВАД-Л {
		п.взять()
		индекс := асд.ОписаниеПеременной{
			поз:  п.поз,
			имя: п.идент(),
            одно-присваивание: истина,
		}
		п.нужна лексема(лексер.КВАД-П)
	}

	если п.лек = лексер.ИДЕНТ {
		элемент := асд.ОписаниеПеременной{
			поз:  п.поз,
			имя: п.идент(),
            одно-присваивание: истина,
		}
	} иначе если индекс = пусто {
		п.нужна лексема(лексер.ИДЕНТ)
	}

	п.нужна лексема(лексер.СРЕДИ)

	вернуть асд.ОператорЦикл{
		поз: поз,
        В:  п.выражение(),
        тело: п.блок()
	}
}

//==== завершающие операторы

фн (п: Парсер) оператор-вернуть(): асд.Оператор {

    пусть тек = асд.ОператорВернуть{
        поз: п.поз,
    }
    п.взять()

    если п.послеКС | п.лек = лексер.ТОЧКА-ЗАП | п.лек = лексер.ФИГ-П {
        вернуть тек
    }

    тек.В := п.выражение()

    вернуть тек
}

фн (п: Парсер) оператор-прервать(): асд.Оператор {

    пусть тек = асд.ОператорПрервать{
        поз: п.поз,
    }
    п.взять()

    вернуть тек
}

фн (п: Парсер) оператор-авария(): асд.Оператор {

    п.взять()
    п.нужна лексема(лексер.КРУГ-Л)
    пусть выр = п.выражение()
    п.нужна лексема(лексер.КРУГ-П)

    вернуть асд.ОператорАвария{
        поз: п.поз,
        В: выр,
    }
}


