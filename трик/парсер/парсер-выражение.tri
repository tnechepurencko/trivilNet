модуль парсер

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод/utf8"

импорт "трик/асд"
импорт "трик/лексер"
импорт "трик/основа"

//==== приоритеты

конст мин-приоритет = 0

фн приоритет(лек: лексер.Лексема): Цел64 {
	выбор лек {
	когда лексер.ИЛИ:
		вернуть 1
	когда лексер.И:
		вернуть 2
	когда лексер.РАВНО, лексер.НЕ-РАВНО, лексер.МЕНЬШЕ, лексер.МЕНЬШЕ-РАВНО, лексер.БОЛЬШЕ, лексер.БОЛЬШЕ-РАВНО,
		лексер.ТИПА:
		вернуть 3
	когда лексер.СЛОЖИТЬ, лексер.ВЫЧЕСТЬ, лексер.БИТ-ИЛИ, лексер.БИТ-ИСК-ИЛИ:
		вернуть 4
	когда лексер.УМНОЖИТЬ, лексер.ДЕЛИТЬ, лексер.ОСТАТОК, лексер.БИТ-И, лексер.СДВИГ-Л, лексер.СДВИГ-П:
		вернуть 5
	другое
		вернуть мин-приоритет
	}
}

//==== выражения

фн (п: Парсер) выражение(): асд.Выражение {
    если п.отладка { п.войти("выражение") }

	пусть в = п.бинарное выражение(мин-приоритет + 1)

    если п.отладка { п.выйти() }
    вернуть в
}

фн (п: Парсер) бинарное выражение(прио: Цел64): асд.Выражение {

	пусть тек := п.унарное выражение()
	пока истина {
		пусть операция = п.лек
		пусть поз = п.поз
		пусть приоритет-операции = приоритет(операция)

		если приоритет-операции < прио {
			вернуть тек
		}

		если операция = лексер.ТИПА {
			тек := п.проверка-типа(тек)
		} иначе {
			п.взять()
			тек := асд.БинарнаяОперация{
				поз: поз,
				Л: тек,
				операция:  операция,
				П: п.бинарное выражение(приоритет-операции + 1),
			}
		}
	}
    вернуть тек
}

фн (п: Парсер) унарное выражение(): асд.Выражение {

	выбор п.лек {
	когда лексер.ВЫЧЕСТЬ, лексер.НЕ, лексер.БИТ-НЕ:
		пусть поз = п.поз
		пусть операция = п.лек
		п.взять()

		вернуть асд.УнарнаяОперация{
			поз: поз, 
			операция: операция,
			Л: п.унарное выражение(),
		}
	когда лексер.СЛОЖИТЬ:
    	п.взять()
		вернуть п.унарное выражение()
	}

    если п.отладка { п.войти("первичное выражение") }
	пусть тек = п.первичное выражение()
    если п.отладка { п.выйти() }
    
    вернуть тек
}

фн (п: Парсер) проверка-типа(выр: асд.Выражение): асд.Выражение {

	пусть поз = п.поз
	п.взять()

	вернуть асд.ПроверкаТипа{
		поз: поз,
		Л:  выр,
		цель: п.указание-типа(),
	}
}

фн (п: Парсер) первичное выражение(): асд.Выражение {

    пусть тек := п.операнд()
    
	пока истина {
		выбор п.лек {
		когда лексер.ТОЧКА:
			тек := п.доступ(тек)
		когда лексер.КРУГ-Л:
			тек := п.аргументы(тек)
		когда лексер.КОНВЕРСИЯ:
			тек := п.конверсия(тек)
		когда лексер.КВАД-Л:
			тек := п.индексация(тек)
		когда лексер.ФИГ-Л:
			если п.ле.есть пробел перед символом?('{'(:Байт)) {
				вернуть тек
			}
			тек := п.композит класса(тек)
		когда лексер.НЕ-ПУСТО:
			тек := п.подтверждение-типа(тек)
		другое
			вернуть тек
		}
	}
    вернуть тек
}

тип Символы = []Символ

фн (п: Парсер) операнд(): асд.Выражение {

	выбор п.лек {
	когда лексер.ЦЕЛ:
		пусть лит = асд.Литерал{
            поз: п.поз,
		}
		если строки. есть префикс(п.ле.изо, "0x") {
			лит.вид := асд.Лит-Слово
            пусть рез = строки.строка в слово(п.ле.изо, лит.слово)
			если ~ рез  {
				п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверный шестнадцатеричный литерал")
			}
		} иначе {
			лит.вид := асд.Лит-Цел
            пусть рез = строки.строка в цел(п.ле.изо, лит.цел)
			если ~ рез  {
				п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверный десятичный литерал")
			}
		}
		п.взять()
		вернуть лит
	когда лексер.СИМВОЛ:
		пусть лит = асд.Литерал{
            поз: п.поз,
			вид: асд.Лит-Символ,
		}    
		если ~ utf8.корректная строка(п.ле.изо) {
			п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверная кодировка символа")
		} иначе {
            пусть симы = подготовить строковый литерал(п.ле.изо)
            лит.слово := симы[0](:Слово64)
		}
		п.взять()
		вернуть лит
	когда лексер.ВЕЩ:
    	пусть лит = асд.Литерал{
            поз: п.поз,
			вид: асд.Лит-Вещ,
		}
        пусть в := 1.0
        пусть рез = строки.строка в вещ(п.ле.изо, в)
		если ~ рез  {
			п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверный вещественный литерал")
			лит.вещ := "1.0"
		} иначе {
            лит.вещ := п.ле.изо
		}
		п.взять()
		вернуть лит
	когда лексер.СТРОКА:
    	пусть лит = асд.Литерал{
            поз: п.поз,
			вид: асд.Лит-Строка,
		}    
		если ~ utf8.корректная строка(п.ле.изо) {
			п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверная кодировка строки")
		} иначе {
            лит.стр := подготовить строковый литерал(п.ле.изо)
		}
		п.взять()
		вернуть лит
	когда лексер.МУЛЬТИ-СТРОКА:
    	пусть лит = асд.Литерал{
            поз: п.поз,
			вид: асд.Лит-Строка,
		}    
		если ~ utf8.корректная строка(п.ле.изо) {
			п.ошибка("ПАР-ОШ-ЛИТЕРАЛ", "неверная кодировка строки")
		} иначе {
            лит.стр := п.ле.изо(:асд.Символы)
		}
		п.взять()
		вернуть лит        
	когда лексер.ИДЕНТ:
		пусть ид = асд.ОперандИдент{
			поз: п.поз,
			имя:  п.ле.изо,
		}
		п.взять()
        вернуть ид
	когда лексер.КРУГ-Л:
		п.взять()
		пусть выр = п.выражение()
		п.нужна лексема(лексер.КРУГ-П)
        вернуть выр
	другое
		п.ошибка("ПАР-ОШ-ОПЕРАНД", лексер.для показа(п.лек))
		вернуть асд.ОшВыражение{поз: п.поз}
	}
}

фн (п: Парсер) доступ(Л: асд.Выражение): асд.Выражение {
    если п.отладка { п.войти("доступ") }
    
	п.взять()

	пусть тек = асд.Доступ{
		поз: п.поз,
		Л: Л,
        имя: п.идент()
	}
    
    если п.отладка { п.выйти() }
    вернуть тек
}

фн (п: Парсер) аргументы(Л: асд.Выражение): асд.Выражение {

	пусть вызов = асд.Вызов{
		поз: п.поз,
		Л:   Л,
	}

	п.нужна лексема(лексер.КРУГ-Л)

	пока п.лек # лексер.КРУГ-П & п.лек # лексер.КОН-ФАЙЛ {

		пусть арг := п.выражение()

		если п.лек = лексер.ТРОЕТОЧИЕ {
			пусть развернуть = асд.Развернуть{
				поз: п.поз,
				Л: арг,
			}
			арг := развернуть
			п.взять()
		}

        вызов.аргументы.добавить(арг)
        
		если п.лек = лексер.КРУГ-П {
			прервать
		}
		п.нужна лексема(лексер.ЗАПЯТАЯ)
	}

	п.нужна лексема(лексер.КРУГ-П)

	вернуть вызов
}

фн (п: Парсер) конверсия(Л: асд.Выражение): асд.Выражение {
    п.взять()

    пусть осторожное := п.лек = лексер.ОСТОРОЖНО
	если осторожное {
		п.взять()
		п.число-осторожно++
		если ~ п.осторожно? {
			п.ошибка("ПАР-ОШ-ИСП-ОСТОРОЖНО")
		}
	}

	пусть тек = асд.Преобразовать{
		поз: п.поз,
		Л: Л,
        осторожное: осторожное,
        цель: п.указание-типа()
	}

	п.нужна лексема(лексер.КРУГ-П)

	вернуть тек
}

фн (п: Парсер) индексация(Л: асд.Выражение): асд.Выражение {

	пусть тек = асд.ИндексацияИлиКонструктор{
		поз: п.поз,
		Л:  Л,
        композит:  асд.КонструкторВектора{
            поз: п.поз,
        }
	}

	п.нужна лексема(лексер.КВАД-Л)

	пока п.лек # лексер.КВАД-П & п.лек # лексер.КОН-ФАЙЛ {

		если п.лек = лексер.УМНОЖИТЬ {
			п.взять()
			п.нужна лексема(лексер.ДВОЕТОЧИЕ)
			тек.композит.умолчание := п.выражение()
		} иначе {
            пусть индекс := п.выражение()

			если п.лек = лексер.ДВОЕТОЧИЕ {
				п.взять()
				пусть значение = п.выражение()

				если это настройка вектора?(индекс, асд.СтдДлина) {
					тек.композит.размер := значение
				} иначе если это настройка вектора?(индекс, асд.ВекторВыделить) {
					тек.композит.резерв := значение
				} иначе {
                    // это пара: индекс: значеие
					тек.композит.индексы.добавить(индекс)
					тек.композит.значения.добавить(значение)
			}
			} иначе {
				тек.композит.значения.добавить(индекс)
			}
		}

		если п.лек = лексер.КВАД-П {
			прервать
		}
		п.нужна лексема(лексер.ЗАПЯТАЯ)
	}

	п.нужна лексема(лексер.КВАД-П)

	п.проверить элементы(тек.композит)

	вернуть тек
}

фн это настройка вектора?(выр: асд.Выражение, имя: Строка): Лог {
    надо выр типа асд.ОперандИдент иначе вернуть ложь

	вернуть выр(:асд.ОперандИдент).имя = имя
}

фн (п: Парсер) проверить элементы(тек: асд.КонструкторВектора) {

	// если все элементы - это пары
	если длина(тек.индексы) = длина(тек.значения) {
		вернуть
	}

	// если ни одной пары
	если длина(тек.индексы) = 0 & тек.размер = пусто & тек.резерв = пусто & тек.умолчание = пусто {
		вернуть
	}

	п.ошибка в позиции(тек.поз, "ПАР-СМЕСЬ-МАССИВ")
}

//==== композит класса

фн (п: Парсер) композит класса(Л: асд.Выражение): асд.Выражение {

	пусть тек = асд.КонструкторКласса{
		поз: п.поз,
		Л: Л,
	}

	п.нужна лексема(лексер.ФИГ-Л)

	пока п.лек # лексер.ФИГ-П & п.лек # лексер.КОН-ФАЙЛ {

        пусть поз = п.поз
        пусть имя = п.идент()
		п.нужна лексема(лексер.ДВОЕТОЧИЕ)
        пусть значение = п.выражение()

		пусть пара = асд.ЗначениеПоля{
            поз: поз,
            имя-поля: имя,
            В: значение,
        }
        тек.значения.добавить(пара)

		если п.лек = лексер.ФИГ-П {
			прервать
		}
		п.нужна лексема(лексер.ЗАПЯТАЯ)
	}

	п.нужна лексема(лексер.ФИГ-П)

	вернуть тек
}

фн (п: Парсер) подтверждение-типа(Л: асд.Выражение): асд.Выражение {

	пусть тек = асд.ПодтверждениеТипа{
		поз: п.поз,
		Л: Л,
	}
	п.взять()

	вернуть тек
}
