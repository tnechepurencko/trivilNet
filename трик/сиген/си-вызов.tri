модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"

//==== вызов

фн (си: СиГен) вызов(тек: асд.Вызов): Строка {
	если тек. стд-функция # пусто {
		вернуть си.стандартная функция(тек)
	}

	если это вызов метода?(тек.Л) {
		вернуть си.вызов метода(тек)
	}

	пусть л = си.выражение(тек.Л)

	пусть аргументы = си.аргументы(тек)

	вернуть строки.ф("$;($;)", л, аргументы)
}

фн (си: СиГен) аргументы(тек: асд.Вызов): Строка {

	пусть тф = тек.Л.Т(:асд.ТипФункция)

	пусть аргументы = Строки[]
    пусть число-нормальных := длина(тф.параметры)

	пусть вар-пар = асд.ВариативныйПараметр(тф)
	если вар-пар # пусто {
		число-нормальных--
	}

	// не вариативные параметры
    пусть № := 0
	пока № < число-нормальных {
		пусть пар = тф.параметры[№]
		пусть арг = тек.аргументы[№]
        если асд.полиморфный тип?(пар.Т^) {
            аргументы.добавить(си.аргумент полиморфного(пар, арг))
        } иначе если пар.выходной {
            аргументы.добавить(строки.ф("&($;)", си.выражение(арг)))
		} иначе {
			пусть конверсия = си.конверсия при присваивании(пар.Т^, арг.Т^)
			аргументы.добавить(строки.ф("$;$;", конверсия, си.выражение(арг)))
		}
        №++
	}

	если вар-пар # пусто {
    	пусть вар-Т = вар-пар^.Т(:асд.ТипВариативный)

		если асд.полиморфный тип?(вар-Т.Т-элемента) {
			аргументы.добавить(си.аргументы вариативного полиморфного(тек, вар-пар^, число-нормальных))
		} иначе {
			аргументы.добавить(си.аргументы вариативного(тек, вар-пар^, вар-Т, число-нормальных))
		}
	}
	вернуть строки.соединить(", ", аргументы...)
}

фн (си: СиГен) аргумент полиморфного(пар: асд.Параметр, арг: асд.Выражение): Строка {
    пусть си-арг := ""
    если асд.полиморфный тип?(арг.Т^) {
        си-арг := си.выражение(арг)
    } иначе {
        си-арг := си.новое локальное имя("")
        пусть тег := ""
        пусть значение := ""
        си.пара тег-значение(арг, тег, значение)
        си.к("$; $; = {$;, $;};", 
            имя встроенного-типа(асд.ТипПолиморфный()), 
            си-арг, 
            тег,
            значение
        )
    }

    если пар.выходной {
        си-арг := строки.ф("&($;)", си-арг)
    }
    вернуть си-арг
}

фн найти развернуть(тек: асд.Вызов): мб асд.Развернуть {
	если длина(тек.аргументы) = 0 {
		вернуть пусто
	}
	пусть последний = тек.аргументы[длина(тек.аргументы)-1]
	если последний типа асд.Развернуть {
		вернуть последний(:асд.Развернуть) 
	}
	вернуть пусто
}

//TODO: нужно ли выдержать какой-то порядок вычисления аргументов?
фн (си: СиГен) аргументы вариативного(тек: асд.Вызов, вар-пар: асд.Параметр, вар-Т: асд.ТипВариативный, число-нормальных: Цел64): Строка {

	пусть развернуть? = найти развернуть(тек)
	если развернуть? # пусто {
        пусть развернуть = развернуть?^

		если асд.вариативный тип?(развернуть.Л.Т^) {
			пусть vr = си.выражение(развернуть.Л)
			вернуть строки.ф("$;$;, $;", vr, суффикс-длины-вариативного, vr)
		} иначе {
			пусть лок = си.новое локальное имя("")
			си.к("$; $; = $;;", си.указание-типа(развернуть.Л.Т^), лок, си.выражение(развернуть.Л))
			вернуть строки.ф("$;->len, $;->body", лок, лок)
		}
	} иначе {
		пусть лок = си.новое локальное имя("")
		пусть т-эл = си.указание-типа(вар-Т.Т-элемента)
		пусть вар-длина = длина(тек.аргументы) - число-нормальных

		пусть список = Строки[выделить: вар-длина]
		пусть № := число-нормальных
		пока № < длина(тек.аргументы) {
			список.добавить(си.выражение(тек.аргументы[№]))
			№++
		}
		си.к("$; $;[$;] ={$;};", т-эл, лок, вар-длина, строки.соединить(", ", список...))

		вернуть строки.ф("$;, &$;", вар-длина, лок)
	}
}

фн (си: СиГен) аргументы вариативного полиморфного(тек: асд.Вызов, вар-пар: асд.Параметр, число-нормальных: Цел64): Строка {

	пусть развернуть? = найти развернуть(тек)
	если развернуть? # пусто {
        пусть развернуть = развернуть?^
    
		пусть левое = си.выражение(развернуть.Л)
		вернуть строки.ф("$;$;, $;", левое, суффикс-длины-вариативного, левое)
	} иначе {
		пусть лок = си.новое локальное имя("")
		пусть вар-длина = длина(тек.аргументы) - число-нормальных

		пусть список = Строки[выделить: вар-длина*2]
		пусть № := число-нормальных
		пока № < длина(тек.аргументы) {
            пусть арг = тек.аргументы[№]
            пусть тег := ""
            пусть значение := ""
            си.пара тег-значение(арг, тег, значение)            
			список.добавить(тег)
			список.добавить(значение)
			№++
		}
		си.к("TWord64 $;[$;] = {$;};", лок, вар-длина*2, строки.соединить(", ", список...))

		вернуть строки.ф("$;, &$;", вар-длина, лок)
	}
}

//==== вызов метода

фн это вызов метода?(тек: асд.Выражение): Лог {

    надо тек типа асд.Доступ иначе вернуть ложь

    пусть доступ = тек(:асд.Доступ)
    надо доступ.объект типа асд.Функция иначе вернуть ложь

	вернуть доступ.объект(:асд.Функция).получатель # пусто
}

фн (си: СиГен) вызов метода(тек: асд.Вызов): Строка {

    пусть доступ = тек.Л(:асд.Доступ)
    пусть ф = доступ.объект(:асд.Функция)

	пусть имя := ""

	если доступ.Л типа асд.ОперандИдент {
		имя := си.идентификатор(доступ.Л(:асд.ОперандИдент))
	} иначе {
		имя := си.новое локальное имя("")

		си.к("$; $; = $;;",
			си.указание-типа(доступ.Л^.Т^),
			имя,
			си.выражение(доступ.Л^))
	}

	// TODO - можно убрать каст, если лишний
	пусть получатель := строки.ф("($;)$;", си.указание-типа(ф.получатель^.Т^), имя)

    пусть аргументы := ""
	если длина(тек.аргументы) > 0 {
        аргументы := строки.ф(", $;",   си.аргументы(тек))
	}

	вернуть строки.ф("$;->$;->$;($;$;)", имя, имя-поля-ВТ, перевести имя(ф.имя), получатель, аргументы)
}

//==== стандартные функции

фн (си: СиГен) стандартная функция(тек: асд.Вызов): Строка {
	выбор тек.стд-функция^.имя {
	когда асд.СтдДлина:
		вернуть си.стд длина(тек)
	когда асд.СтдТег:
		вернуть си.стд тег(тек)
	когда асд.СтдНечто:
		вернуть си.стд нечто(тек)

	когда асд.ВекторДобавить:
		вернуть си.вектор-добавить(тек)

	другое
		авария(строки.ф("assert: не реализована стандартная функция $;", тек.стд-функция^.имя))
	}
}

фн (си: СиГен) стд длина(тек: асд.Вызов): Строка {
	пусть aрг = тек.аргументы[0]

	пусть т = асд.основа(aрг.Т)^
	если асд.строка?(т) {
		вернуть строки.ф("$;($;)", rt_lenString, си.выражение(aрг))
	} иначе если асд.строка8?(т) {
		вернуть строки.ф("($;)->bytes", си.выражение(aрг))
	}

	выбор тип т {
	когда асд.ТипВектор:
		вернуть строки.ф("($;)->len", си.выражение(aрг))
	когда асд.ТипВариативный:
		вернуть строки.ф("$;$;", си.выражение(aрг), суффикс-длины-вариативного)
	другое
		авария("ni")
	}
}

// Запрос длины по выражению типа т
фн (си: СиГен) взять длину(си-выр: Строка, т: асд.Тип): Строка {

    т := асд.основа(т)^
	если асд.строка?(т) {
		вернуть строки.ф("$;($;)", rt_lenString, си-выр)
	} иначе если асд.строка8?(т) {
		вернуть строки.ф("($;)->bytes", си-выр)
	}

	выбор тип т {
	когда асд.ТипВектор:
		вернуть строки.ф("($;)->len", си-выр)
	когда асд.ТипВариативный:
		вернуть строки.ф("$;$;", си-выр, суффикс-длины-вариативного)
	другое
		авария("ni")
	}
}

фн (си: СиГен) стд тег(тек: асд.Вызов): Строка {

	пусть арг = тек.аргументы[0]

	если арг типа асд.ОперандТип {
		вернуть си.тег по типу( арг(:асд.ОперандТип).Т^)
	} иначе {
		вернуть си.тег полиморфного выражения(арг)
	}
}

// Выдает тег по статическому типу
фн (си: СиГен) тег по типу(т: асд.Тип): Строка {
	
	выбор пусть тек: тип асд.основа(т)^ {
	когда асд.ТипВстроенный:
		вернуть строки.ф("$;$;()", rt_tag, имя встроенного-типа(тек))
	когда асд.ТипКласс:
		пусть указ = асд.непосредственное указание-типа(т)
		вернуть строки.ф("(($;)$;$;).w",
			rt_cast_union,
			си.имя описания(указ.оп-типа^),
            суффикс-адрес-дескриптора)
	когда асд.ТипВектор:
		авария("ni")
	когда асд.ТипМБ:
		вернуть си.тег по типу(тек.Т)
	другое
		авария(строки.ф("ni тег для типа: $тип;", асд.основа(т)^))
	}
}

// Тег по выражению полиморфного типа
фн (си: СиГен) тег полиморфного выражения(выр: асд.Выражение): Строка {
	выбор пусть тек: тип выр {
	когда асд.ИндексацияИлиКонструктор:
		если тек.индекс = пусто {
			авария("assert - не может быть композита")
		}

		пусть левое = си.выражение(тек.Л)

		вернуть строки.ф("(($;*)($;))[$;($;, $;$;, $;) << 1]",
			имя встроенного-типа(асд.ТСлово64()),
			левое,
			rt_indexcheck,
			си.выражение(тек.индекс^),
			левое,
			суффикс-длины-вариативного,
			позиция в строку(тек.поз))

	когда асд.ОперандИдент:
		//авария("ni - полиморфный, но не вариативный параметр '*'")
        вернуть строки.ф("$;.tag", си.выражение(тек))
	другое 
        авария("assert")
    }
}

фн (си: СиГен) пара тег-значение(арг: асд.Выражение, тег := Строка, значение := Строка) {
    если асд.полиморфный тип?(арг.Т^) {
        си.пара тег-значение полиморфного выражения(арг, тег, значение)
        вернуть
    }
    // динамический тип
    выбор {
	когда асд.тип-класса?(арг.Т^):
        пусть лок := си.новое локальное имя("")
        си.к("$; $; = $;;", си.указание-типа(арг.Т^), лок, си.выражение(арг))
        значение := си.привести к слово64(лок, арг.Т^)
        тег := строки.ф("$;($;)",  rt_objectTag, лок)
        вернуть
	когда асд.тип-вектора?(арг.Т^):
		авария("ni")    
    }
    
    тег := си.тег по типу(арг.Т^)
    значение := си.привести к слово64(си.выражение(арг), арг.Т^)
}

фн (си: СиГен) пара тег-значение полиморфного выражения(выр: асд.Выражение, тег := Строка, значение := Строка) {
	выбор пусть тек: тип выр {
	когда асд.ИндексацияИлиКонструктор:
		если тек.индекс = пусто {
			авария("assert - не может быть композита")
		}

        пусть левое = си.выражение(тек.Л)

		пусть индекс = си.новое локальное имя("inx")
        си.к("$; $; = $;($;, $;$;, $;);", 
            имя встроенного-типа(асд.ТЦел64()),
            индекс,
            rt_indexcheck,
			си.выражение(тек.индекс^),
			левое,
			суффикс-длины-вариативного,
			позиция в строку(тек.поз)
        )    

		тег := строки.ф("(($;*)($;))[$; << 1]",
			имя встроенного-типа(асд.ТСлово64()),
			левое,
            индекс
        )
            
		значение := строки.ф("(($;*)($;))[($; << 1)+1]",
			имя встроенного-типа(асд.ТСлово64()),
			левое,
            индекс
        )

	когда асд.ОперандИдент:
        пусть лок = си.новое локальное имя("")
        си.к("$; $; = $;;", си.указание-типа(выр.Т^), лок, си.выражение(выр))

        тег := строки.ф("$;.tag", лок)
        значение := строки.ф("$;.value", лок)        
	другое 
        авария("assert")
    }
}

фн (си: СиГен) стд нечто(тек: асд.Вызов): Строка {

	пусть арг = тек.аргументы[0]

	пусть т = арг.Т^
    
	если ~ асд.полиморфный тип?(т) {
		авария("assert")
	}

	выбор пусть тек: тип арг {
	когда асд.ИндексацияИлиКонструктор:
		если тек.индекс = пусто {
			авария("assert")
		}

		пусть левое = си.выражение(тек.Л)

		вернуть строки.ф("(($;*)($;))[($;($;, $;$;, $;) << 1)+1]",
			имя встроенного-типа(асд.ТСлово64()),
			левое,
			rt_indexcheck,
			си.выражение(тек.индекс^),
			левое,
			суффикс-длины-вариативного,
			позиция в строку(тек.поз))

	когда асд.ОперандИдент:
        вернуть строки.ф("$;.value", си.выражение(тек))
	}
	авария("assert")
}

//== векторные

фн (си: СиГен) вектор-добавить(тек: асд.Вызов): Строка {

    // Внимание - левое выражение в тек.стд-метод-Л, а не в тек.Л
    пусть Л = тек.стд-метод-Л^

	пусть тв = асд.основа(Л.Т^)(:асд.ТипВектор)
	пусть т-эл = си.указание-типа(тв.Т-элемента)

	пусть развернуть? = найти развернуть(тек)
	если развернуть? # пусто {
        пусть развернуть = развернуть?^

		если асд.вариативный тип?(развернуть.Л.Т^) {

			вернуть строки.ф("$;($;, sizeof($;), $;$;, $;)",
				rt_vectorAppend,
				си.выражение(Л),
				т-эл,
				развернуть, 
                суффикс-длины-вариативного,
				развернуть)

		} иначе {
			пусть лок = си.новое локальное имя("")
			си.к("$; $; = $;;", си.указание-типа(развернуть.Л.Т^), лок, си.выражение(развернуть.Л))

			пусть имя-длины := "len"
			если асд.строка8?(развернуть.Л.Т^) {
				имя-длины := "bytes"
			}

			вернуть строки.ф("$;($;, sizeof($;), $;->$;, $;->body)",
				rt_vectorAppend,
				си.выражение(Л),
				т-эл,
				лок,
				имя-длины,
				лок)
		}
	} иначе {
		пусть лок = си.новое локальное имя("")

		пусть список = Строки[*: "", длина: длина(тек.аргументы)]
		цикл [№]арг среди тек.аргументы {
			пусть конверсия = си.конверсия при присваивании(тв.Т-элемента, арг.Т^)
			список[№] := строки.ф("$;$;", конверсия, си.выражение(арг))
		}

		си.к("$; $;[$;] = {$;};", т-эл, лок, длина(тек.аргументы), строки.соединить(", ", список...))

		вернуть строки.ф("$;($;, sizeof($;), $;, $;)",
			rt_vectorAppend,
			си.выражение(Л),
			т-эл,
			длина(тек.аргументы),
			лок)
	}
}
