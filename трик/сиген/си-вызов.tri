модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"

//== call

фн (си: СиГен) вызов(тек: асд.Вызов): Строка {
	если тек. стд-функция # пусто {
		вернуть си.стандартная функция(тек)
	}

/*
	если isMethodCall(тек.Л) {
		вернуть си.вызов метода(call)
	}
*/
	пусть л = си.выражение(тек.Л)

	пусть аргументы = си.аргументы(тек)

	вернуть строки.ф("$;($;)", л, аргументы)
}

фн (си: СиГен) аргументы(тек: асд.Вызов): Строка {

	пусть тф = тек.Л.Т^(:асд.ТипФункция)

	пусть аргументы = Строки[]
    пусть число-нормальных := длина(тф.параметры)

	пусть вар-пар = асд.ВариативныйПараметр(тф)
	если вар-пар # пусто {
		число-нормальных--
	}

	// не вариативные параметры
    пусть № := 0
	пока № < число-нормальных {
		пусть пар = тф.параметры[№]
		пусть арг = тек.аргументы[№]
		пусть си-арг = си.выражение(арг)
		если пар.выходной {
            аргументы.добавить(строки.ф("&($;)", си-арг))
		} иначе {
			пусть конверсия = си.конверсия при присваивании(пар.Т^, арг.Т^)
			аргументы.добавить(строки.ф("$;$;", конверсия, си-арг))
		}
        №++
	}

	если вар-пар # пусто {
    	пусть вар-Т = вар-пар^.Т^(:асд.ТипВариативный)

		если асд.полиморфный тип?(вар-Т.Т-элемента) {
//!			cargs[число-нормальных] = си.genVariadicTaggedArgs(call, вар-пар, число-нормальных)
            авария("ni")
		} иначе {
//!			cargs[число-нормальных] = си.genVariadicArgs(call, вар-пар, vTyp, число-нормальных)
            авария("ni")
		}
	}
	вернуть строки.соединить(", ", аргументы...)
}

/*
фн getUnfold(тек: асд.Вызов) асд.Развернуть {
	если длина(call.Args) = 0 {
		вернуть пусто
	}
	пусть last = call.Args[len(call.Args)-1]
	если u, ok := last.(асд.Развернуть); ok {
		вернуть u
	}
	вернуть пусто
}

//TODO: нужно ли выдержать какой-то порядок вычисления аргументов?
фн (си: СиГен) genVariadicArgs(тек: асд.Вызов, вар-пар асд.Параметр, vTyp асд.ТипВариативный, normCount int): Строка {

	пусть unfold = getUnfold(call)
	если unfold # пусто {

		если асд.вариативный тип?(unfold.X.GetType()) {
			пусть vr = си.выражение(unfold.X)
			вернуть строки.ф("$;$;, $;", vr, суффикс-длины-вариативного, vr)
		} иначе {
			пусть loc = си.новое локальное имя("")
			си.к("$; $; = $;;", си.указание-типа(unfold.X.GetType()), loc, си.выражение(unfold.X))
			вернуть строки.ф("$;->len, $;->body", loc, loc)
		}
	} иначе {
		пусть loc = си.новое локальное имя("")
		пусть et = си.указание-типа(vTyp.ElementTyp)
		пусть vLen = длина(call.Args) - normCount

		пусть cargs = make([]Строка, vLen)
		пусть n = 0
		пока i := normCount; i < длина(call.Args); i++ {
			cargs[n] = си.выражение(call.Args[i])
			n++
		}
		си.к("$; $;[$;] ={$;};", et, loc, vLen, Строкаs.Join(cargs, ", "))

		вернуть строки.ф("$;, &$;", vLen, loc)
	}
}

фн (си: СиГен) genVariadicTaggedArgs(тек: асд.Вызов, вар-пар асд.Параметр, normCount int): Строка {

	пусть unfold = getUnfold(call)
	если unfold # пусто {
		пусть vr = си.выражение(unfold.X)
		вернуть строки.ф("$;$;, $;", vr, суффикс-длины-вариативного, vr)
	} иначе {
		пусть loc = си.новое локальное имя("")
		пусть vLen = длина(call.Args) - normCount

		//си.к("= класс { TInt64 len; TInt64 body[$;]; } $;;", vLen*2, loc)

		пусть cargs = make([]Строка, vLen*2)
		пусть n = 0
		пока i := normCount; i < длина(call.Args); i++ {
			cargs[n] = си.genTypeTag(call.Args[i].GetType())
			cargs[n+1] = си.castToWord64(call.Args[i])
			n += 2
		}
		си.к("TWord64 $;[$;] = {$;};", loc, vLen*2, Строкаs.Join(cargs, ", "))

		вернуть строки.ф("$;, &$;", vLen, loc)
	}
}

фн (си: СиГен) castToWord64(e асд.Выражение): Строка {
	пусть s = си.выражение(e)
	выбор асд.основа(e.GetType()) {
	когда асд.ТВещ64():
		вернуть строки.ф("(($;)$;).w", rt_cast_union, s)
	когда асд.ТСлово64():
		вернуть s
	другое
		вернуть строки.ф("($;)$;", имя встроенного-типа(асд.ТСлово64()), s)
	}
}

фн isMethodCall(left асд.Выражение) Лог {
	sel, ok := left.(асд.Доступ)
	если ~ok {
		вернуть ложь
	}

	f, ok := sel.Obj.(асд.Функция)
	если ~ok {
		вернуть ложь
	}

	вернуть f.Recv # пусто
}

фн (си: СиГен) вызов метода(тек: асд.Вызов): Строка {

	sel := тек.Л.(асд.Доступ)
	f := sel.Obj.(асд.Функция)

	пусть name Строка
	если id, ok := sel.X.(асд.ОперандИдент); ok {
		name = си.идентификатор(id)
	} иначе {
		name = си.новое локальное имя("")

		си.к("$; $; = $;;",
			си.указание-типа(sel.X.GetType()),
			name,
			си.выражение(sel.X))
	}

	//TODO - можно убрать каст, если лишний
	пусть args = строки.ф("($;)$;", си.указание-типа(f.Recv.Typ), name)

	если длина(call.Args) > 0 {
		args += ", " + си.аргументы(call)
	}

	вернуть строки.ф("$;->$;->$;($;)", name, имя-поля-ВТ, перевести имя(f.имя), args)
}
*/

фн (си: СиГен) стандартная функция(тек: асд.Вызов): Строка {
    авария("ni")
/*
	выбор call.StdFunc.имя {
	когда ast.StdLen:
		вернуть си.genStdLen(call)
	когда ast.StdTag:
		вернуть си.genStdTag(call)
	когда ast.StdSomething:
		вернуть си.genStdSomething(call)

	когда ast.VectorAppend:
		вернуть си.genVectorAppend(call)

	другое
		авария("assert: не реализована стандартная функция " + call.StdFunc.имя)
	}
*/    
}

/*
фн (си: СиГен) genStdLen(тек: асд.Вызов): Строка {
	пусть a = call.Args[0]

	пусть t = асд.основа(a.GetType())
	если t = асд.ТСтрока() {
		вернуть строки.ф("$;($;)", rt_lenString, си.выражение(a))
	} иначе если t = асд.ТСтрока8() {
		вернуть строки.ф("($;)->bytes", си.выражение(a))
	}

	выбор t.(type) {
	когда асд.ТипВектор:
		вернуть строки.ф("($;)->len", си.выражение(a))
	когда асд.ТипВариативный:
		вернуть строки.ф("$;$;", си.выражение(a), суффикс-длины-вариативного)
	другое
		авария("ni")
	}
}

// Запрос длины по выражению expr тип typ
фн (си: СиГен) genLen(expr Строка, typ асд.Тип): Строка {

	пусть t = асд.основа(typ)
	если t = асд.ТСтрока() {
		вернуть строки.ф("$;($;)", rt_lenString, expr)
	} иначе если t = асд.ТСтрока8() {
		вернуть строки.ф("($;)->bytes", expr)
	}

	выбор t.(type) {
	когда асд.ТипВектор:
		вернуть строки.ф("($;)->len", expr)
	когда асд.ТипВариативный:
		вернуть строки.ф("$;$;", expr, суффикс-длины-вариативного)
	другое
		авария("ni")
	}
}

фн (си: СиГен) genStdTag(тек: асд.Вызов): Строка {

	пусть a = call.Args[0]

	если tExpr, ok := a.(асд.TypeExpr); ok {
		вернуть си.genTypeTag(tExpr.Typ)
	} иначе {
		вернуть си.genTagPairTag(a)
	}
}

// Выдает тег по статическому типу
фн (си: СиГен) genTypeTag(typ асд.Тип): Строка {
	пусть t = асд.основа(typ)
	выбор x := t.(type) {
	когда асд.ТипВстроенный:
		вернуть строки.ф("$;$;()", rt_tag, имя встроенного-типа(тек))
	когда асд.ТипКласс:
		пусть tr = асд.непосредственное указание-типа(typ)
		вернуть строки.ф("(($;)$;).w",
			rt_cast_union,
			си.имя описания(tr.TypeDecl)+суффикс-адрес-дескриптора)
	когда асд.ТипВектор:
		авария("ni")
	когда асд.ТипМБ:
		вернуть си.genTypeTag(x.Typ)
	другое
		авария(строки.ф("ni тип tag $тип;", t))
	}
}

// Тег для TagPair выражения
фн (си: СиГен) genTagPairTag(e асд.Выражение): Строка {
	выбор x := e.(type) {
	когда асд.ИндексацияИлиКомпозит:
		если x.Index = пусто {
			авария("assert - не может быть композита")
		}

		пусть left = си.выражение(x.X)

		вернуть строки.ф("(($;*)($;))[$;($;, $;$;, $;) << 1]",
			имя встроенного-типа(асд.ТСлово64()),
			left,
			rt_indexcheck,
			си.выражение(x.Index),
			left,
			суффикс-длины-вариативного,
			позиция в строку(x.поз))

	когда асд.ОперандИдент:
		авария("ni - не вариадик параметр '*'")
	}
	авария("assert")
}

фн (си: СиГен) genStdSomething(тек: асд.Вызов): Строка {

	пусть a = call.Args[0]

	пусть t = a.GetType()
	если ~асд.полиморфный тип?(t) {
		авария("assert")
	}

	выбор x := a.(type) {
	когда асд.ИндексацияИлиКомпозит:
		если x.Index = пусто {
			авария("assert")
		}

		пусть left = си.выражение(x.X)

		вернуть строки.ф("(($;*)($;))[($;($;, $;$;, $;) << 1)+1]",
			имя встроенного-типа(асд.ТСлово64()),
			left,
			rt_indexcheck,
			си.выражение(x.Index),
			left,
			суффикс-длины-вариативного,
			позиция в строку(x.поз))

	когда асд.ОперандИдент:
		авария("ni")
	}
	авария("assert")
}

//== векторные

фн (си: СиГен) genVectorAppend(тек: асд.Вызов): Строка {

	пусть vt = асд.основа(тек.Л.GetType()).(асд.ТипВектор)
	пусть et = си.указание-типа(vt.ElementTyp)

	пусть unfold = getUnfold(call)
	если unfold # пусто {

		если асд.вариативный тип?(unfold.X.GetType()) {
			пусть vr = си.выражение(unfold.X)

			вернуть строки.ф("$;($;, sizeof($;), $;$;, $;)",
				rt_vectorAppend,
				си.выражение(тек.Л),
				et,
				vr, суффикс-длины-вариативного,
				vr)

		} иначе {
			пусть loc = си.новое локальное имя("")
			си.к("$; $; = $;;", си.указание-типа(unfold.X.GetType()), loc, си.выражение(unfold.X))

			пусть lenName = "len"
			если асд.основа(unfold.X.GetType()) = асд.ТСтрока8() {
				lenName = "bytes"
			}

			вернуть строки.ф("$;($;, sizeof($;), $;->$;, $;->body)",
				rt_vectorAppend,
				си.выражение(тек.Л),
				et,
				loc,
				lenName,
				loc)
		}
	} иначе {
		пусть loc = си.новое локальное имя("")

		пусть cargs = make([]Строка, длина(call.Args))
		пока i, a := range call.Args {
			пусть cast = си.конверсия при присваивании(vt.ElementTyp, a.GetType())
			cargs[i] = строки.ф("$;$;", cast, си.выражение(a))
		}

		си.к("$; $;[$;] = {$;};", et, loc, длина(call.Args), Строкаs.Join(cargs, ", "))

		вернуть строки.ф("$;($;, sizeof($;), $;, $;)",
			rt_vectorAppend,
			си.выражение(тек.Л),
			et,
			len(call.Args),
			loc)
	}
}
*/