модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"

фн (си: СиГен) преобразование(тек: асд.Преобразовать): Строка {
    вернуть ""
/*
	пусть expr = си.выражение(x.X)
	если x.Done {
		вернуть expr
	}

	пусть to = асд.основа(x.TargetTyp)

	пусть from = асд.основа(тек.Л.Т)
	fromPred, _ := from.(асд.ТипВстроенный)

	выбор to {
	когда асд.ТБайт():
		вернуть си.convertPredefined(expr, fromPred, асд.ТБайт())
	когда асд.ТЦел64():
		если fromPred = асд.ТБайт() | fromPred = асд.ТСимвол() {
			вернуть си.castPredefined(expr, асд.ТЦел64())
		} иначе {
			вернуть си.convertPredefined(expr, fromPred, асд.ТЦел64())
		}
	когда асд.ТСлово64():
		если fromPred = асд.ТБайт() | fromPred = асд.ТСимвол() {
			вернуть си.castPredefined(expr, асд.ТСлово64())
		} иначе {
			вернуть си.convertPredefined(expr, fromPred, асд.ТСлово64())
		}
	когда асд.ТВещ64():
		вернуть си.castPredefined(expr, асд.ТВещ64())
	когда асд.ТСимвол():
		если fromPred = асд.ТБайт() | fromPred = асд.ТСимвол() {
			вернуть си.castPredefined(expr, асд.ТСимвол())
		} иначе {
			вернуть си.convertPredefined(expr, fromPred, асд.ТСимвол())
		}
	когда асд.ТСтрока():
		вернуть си.convertToString(expr, асд.основа(тек.Л.Т))
	когда асд.ТСтрока8():
		вернуть expr
	}

	выбор xt := to.(type) {
	когда асд.ТипВектор:
		вернуть си.convertToVector(expr, from, xt)
	когда асд.ТипКласс:
		вернуть си.convertToClass(expr, x.TargetTyp)
	другое
		авария(строки.ф("ni $тип; '$;'", to, асд.ТипString(to)))
	}
*/    
}

/*
фн (си: СиГен) convertPredefined(expr Строка, from, to асд.ТипВстроенный): Строка {
	вернуть строки.ф("$;$;_to_$;($;)", rt_convert, имя встроенного-типа(from), имя встроенного-типа(to), expr)
}

фн (си: СиГен) castPredefined(expr Строка, to асд.ТипВстроенный): Строка {
	вернуть строки.ф("($;)($;)", имя встроенного-типа(to), expr)
}

фн (си: СиГен) convertToString(expr Строка, from асд.Тип): Строка {

	если from = асд.ТСимвол() {
		вернуть си.convertPredefined(expr, асд.ТСимвол(), асд.ТСтрока())
	} иначе если from = асд.ТСтрока8() {
		вернуть expr
	}

	vt, ok := from.(асд.ТипВектор)
	если ~ok {
		авария("ni")
	}

	пусть et = асд.основа(vt.ElementTyp)
	если et = асд.ТБайт() {
		вернуть строки.ф("$;$;_to_$;($;)", rt_convert, "Bytes", имя встроенного-типа(асд.ТСтрока()), expr)
	} иначе если et = асд.ТСимвол() {
		вернуть строки.ф("$;$;_to_$;($;)", rt_convert, "Symbols", имя встроенного-типа(асд.ТСтрока()), expr)
	} иначе {
		авария("ni")
	}

}

фн (си: СиГен) convertToVector(expr Строка, from асд.Тип, to асд.ТипВектор): Строка {

	если from = асд.ТСтрока() {

		пусть et = асд.основа(to.ElementTyp)
		если et = асд.ТБайт() {
			вернуть строки.ф("$;$;_to_$;($;)", rt_convert, имя встроенного-типа(асд.ТСтрока()), "Bytes", expr)
		} иначе если et = асд.ТСимвол() {
			вернуть строки.ф("$;$;_to_$;($;)", rt_convert, имя встроенного-типа(асд.ТСтрока()), "Symbols", expr)
		} иначе {
			авария("ni")
		}
	} иначе если from = асд.ТСимвол() {
		вернуть строки.ф("$;$;_to_$;($;)", rt_convert, имя встроенного-типа(асд.ТСимвол()), "Bytes", expr)
	} иначе {
		авария("ni")
	}
}

фн (си: СиГен) convertToClass(expr Строка, target асд.Тип): Строка {
	пусть tname = си.указание-типа(target)

	вернуть строки.ф("(($;)$;($;, $;))", tname, rt_checkClassType, expr, tname+суффикс-адрес-дескриптора)
}
*/

фн (си: СиГен) осторожное преобразование(тек: асд.Преобразовать): Строка {
    вернуть ""
/*
	пусть expr = си.выражение(x.X)
	если x.Done {
		вернуть expr
	}

	пусть to = асд.основа(x.TargetTyp)
	пусть from = асд.основа(тек.Л.Т)

	выбор to {
	когда асд.ТЦел64():
		вернуть строки.ф("(($;)$;).i", rt_cast_union, expr)
	когда асд.ТВещ64():
		вернуть строки.ф("(($;)$;).f", rt_cast_union, expr)
	когда асд.ТСлово64():
		вернуть си.привести к слово64(expr, from)
	другое
		если from = асд.ТСлово64() & асд.ссылочный тип?(to) {
			//TODO: проверить указатель и тег
			вернуть строки.ф("($;)(($;)$;).a", си.указание-типа(x.TargetTyp), rt_cast_union, expr)
		} иначе {
			авария(строки.ф("ni $тип; '$;'", to, асд.ТипString(to)))
		}
	}
*/    
}

// Приведение без изменение битового представления
фн (си: СиГен) привести к слово64(си-выр: Строка, т: асд.Тип): Строка {

	т := асд.основа(т)^

	выбор {
	когда асд.слово64?(т), асд.байт?(т), асд.символ?(т), асд.лог?(т):
		вернуть си-выр
	когда асд.цел64?(т):
		вернуть строки.ф("(($;)($;)$;).w", rt_cast_union, имя встроенного-типа(асд.ТЦел64()), си-выр)
	когда асд.ссылочный тип?(т):
		вернуть строки.ф("(($;)(void*)$;).w", rt_cast_union, си-выр)
	другое
		вернуть строки.ф("(($;)$;).w", rt_cast_union, си-выр)
	}
}
