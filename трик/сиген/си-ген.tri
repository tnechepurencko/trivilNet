модуль сиген

импорт "стд::вывод"
//импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"
//импорт "трик/лексер"
импорт "трик/сиген/имена-описаний"

тип Строки = []Строка

тип СиГен = класс {
	мод:  асд.Модуль = позже
	мод-си-имя: Строка = позже // си имя модуля
    си-имена = имена-описаний.Словарь{} //  map[асд.Описание]Строка
//	genTypes    Лог
	авто-№ := 0 // для дополнительных имен
	строки-заголовка = Строки[]
    строки-кода = Строки[]
    строки-глобалы = Строки[]
    строки-инициализация = Строки[]
	глобалы-инициализация = асд.Описания[]  // глобалы, которые надо инициализировать во входе
//	sysAPI      map[Строка]Лог // истина - exported
}


фн построить код*(мод: асд.Модуль, главный: Лог) {
    вывод.ф("генерация $;\n", мод.имя)

	пусть си = СиГен{
		мод: мод, 
		мод-си-имя: перевести имя(мод.имя),
//		sysAPI:      make(map[Строка]Лог),
	}

	//== импорт
	цикл имп среди мод.импорты {
		си.з("#include \"$;.h\"", си.имя описания(имп.мод))
	}
	си.з("")

/*
	//== gen types
	си.genTypes = истина
	пока _, d := range си.мод.описания {
		d, ok := d.(асд.ОписаниеТипа)
		если ok {
			си.genTypeDecl(d)
		}
	}
	си.genTypes = ложь

	//== gen vars, consts
	пока _, d := range си.мод.описания {
		выбор x := d.(type) {
		когда асд.ОписаниеКонстанты:
			си.глобальная константа(тек)
		когда асд.ОписаниеПеременной:
			си.глобальная переменная(тек)
		}
	}

	//== gen фнtions
	пока _, d := range си.мод.описания {
		f, ok := d.(асд.Функция)
		если ok {
			си.функция(f)
		}
	}

	//== gen class desc
	пока _, d := range си.мод.описания {
		если td, ok := d.(асд.ОписаниеТипа); ok {
			//			если cl, ok := асд.основа(td.GetType()).(асд.ТипКласс); ok {
			если cl, ok := td.GetType().(асд.ТипКласс); ok {
				си.описание класса(td, cl)
			}
		}
	}

	си.вход!(си.мод.Entry, main)
*/    
	си.завершить()
}

/*
//== функции

фн (си: СиГен) функция(f асд.Функция) {

	если f.External {

		apiName, ok := f.Mod.Attrs["sysapi"]
		если ok {
			exported, exist := си.sysAPI[apiName]
			если ~exist {
				си.sysAPI[apiName] = f.Exported
			} иначе если f.Exported & ~exported {
				си.sysAPI[apiName] = истина
			}
		}
		вернуть
	}

	пусть ft = f.Typ.(асд.ТипФункция)

	пусть receiver Строка
	если f.Recv # пусто {
		receiver = строки.ф("$; $;",
			си.указание-типа(f.Recv.Typ),
			си.имя описания(f.Recv))
		если длина(ft.Params) > 0 {
			receiver += ", "
		}
	}

	пусть fn_header = строки.ф("$; $;($;$;)",
		си.вернутьType(ft),
		си.фнtionName(f),
		receiver,
		си.params(ft))

	си.з("$;;", fn_header)
	си.к("$; {", fn_header)

	си.список операторов(f.Seq)

	си.к("}")
}

фн (си: СиГен) вернутьType(ft асд.ТипФункция) Строка {
	если ft.Т-вернуть = пусто {
		вернуть "void"
	} иначе {
		вернуть си.указание-типа(ft.Т-вернуть)
	}
}

фн (си: СиГен) params(ft асд.ТипФункция) Строка {

	пусть list = make([]Строка, длина(ft.Params))

	пока i, p := range ft.Params {

		если асд.вариативный тип?(p.Typ) {
			list[i] = строки.ф("TInt64 $;$;", си.имя описания(p), nm_variadic_len_suffic)
			list = append(list, строки.ф("void* $;", си.имя описания(p)))
		} иначе {
			пусть out = ""
			если p.Out {
				out = "*"
			}

			list[i] = строки.ф("$;$; $;", си.указание-типа(p.Typ), out, си.имя описания(p))
		}
	}
	вернуть Строкаs.Join(list, ", ")
}

//== глобальные константы и переменные

фн (си: СиГен) глобальная константа(x асд.ОписаниеКонстанты) {

	пусть name = си.имя описания(тек)

	пусть typ Строка
	если асд.тип-функции?(x.Typ) {
		typ = си.тип-функции(x.Value)
	} иначе {
		typ = си.указание-типа(x.Typ)
	}

	пусть def = строки.ф("$; $;", typ, name)

	если инициализация на месте(x.Typ) {
		def = "конст " + def
		си.к("$; = $;;", def, си.выражение(x.Value))
	} иначе {
		си.к("$;;", def)
		си.строки-инициализацияGlobals = append(си.строки-инициализацияGlobals, x)
	}

	если x.Exported {
		си.з("extern $;;", def)
	}
}

// Обработка кода: конст к = функ
фн (си: СиГен) тип-функции(x асд.Выражение) Строка {

	checkFunctionRef(тек)

	пусть ft = асд.основа(x.GetType()).(асд.ТипФункция)

	пусть name = си.localName("FT")

	пусть ps = make([]Строка, длина(ft.Params))

	пока i, p := range ft.Params {
		если асд.вариативный тип?(p.Typ) {
			ps[i] = "TInt64"
			ps = append(ps, "void*")
		} иначе {
			ps[i] = си.указание-типа(p.Typ)
		}
	}

	си.g("typedef $; (*$;)($;);",
		си.вернутьType(ft),
		name,
		Строкаs.Join(ps, ", "))

	вернуть name
}

фн checkFunctionRef(expr асд.Выражение) {

	выбор x := expr.(type) {
	когда асд.ОперандИдент:
		если _, ok := x.Obj.(асд.Функция); ok {
			вернуть
		}
	когда асд.Доступ:
		если _, ok := x.Obj.(асд.Функция); ok {
			вернуть
		}
	}

	panic("assert - должна быть ссылка на функцию")
}

фн инициализация на месте(t асд.Тип) Лог {

	t = асд.основа(t)
	выбор t {
	когда асд.ТБайт(), асд.ТЦел64(), асд.ТВещ64(), асд.ТЛог(), асд.ТСимвол():
		вернуть истина
	}
	вернуть ложь
}

фн (си: СиГен) глобальная переменная(x асд.ОписаниеПеременной) {

	если x.Exported {
		panic("экспортированные глобалы - запретить или сделать")
	}
	если x.задать-позже {
		panic("ni - 'позже' для глобалов")
	}

	пусть name = си.имя описания(тек)

	пусть typ Строка
	если асд.тип-функции?(x.Typ) {
		panic("closure not implemented")
	} иначе {
		typ = си.указание-типа(x.Typ)
	}
	пусть def = строки.ф("static $; $;", typ, name)

	если инициализация на месте(x.Typ) {
		си.к("$; = $;;", def, си.выражение(x.Init))
	} иначе {
		си.к("$;;", def)
		си.строки-инициализацияGlobals = append(си.строки-инициализацияGlobals, x)
	}
}

фн (си: СиГен) локальное описание(d асд.Описание) Строка {
	выбор x := d.(type) {
	когда асд.ОписаниеПеременной:

		вернуть строки.ф("$; $; = $;$;;",
			си.указание-типа(x.Typ),
			си.имя описания(тек),
			си.конверсия при присваивании(x.Typ, x.Init.GetType()),
			си.выражение(x.Init))
	другое
		panic(строки.ф("genDecl: ni %T", d))
	}
}

//== вход - инициализация или головной

конст (
	init_fn  = "init"
	init_пусть = "init_done"
)

фн (си: СиГен) вход!(entry асд.EntryFn, main Лог) {

	если main {
		си.к("int main(int argc, char *argv[]) {")
		си.к("$;(argc, argv);", rt_init)
	} иначе {
		пусть init_header = строки.ф("void $;__$;()", си.outname, init_fn)

		си.з("$;;", init_header)

		си.к("static TBool $; = ложь;", init_var)
		си.к("$; {", init_header)
		си.к("если ($;) вернуть;", init_var)
		си.к("$; = истина;", init_var)
	}

	пока _, i := range си.мод.импорты {
		си.к("$;__$;();", си.имя описания(i.Mod), init_fn)
	}

	си.строки-кода = append(си.строки-кода, си.строки-инициализация...)

	си.genInitGlobals()

	если entry # пусто {
		си.список операторов(entry.Seq)
	}

	если main {
		си.к("  вернуть 0;")
	}
	си.к("}")
}

фн (си: СиГен) genInitGlobals() {
	пока _, g := range си.строки-инициализацияGlobals {
		выбор x := g.(type) {
		когда асд.ОписаниеКонстанты:
			си.к("$; = $;;", си.имя описания(тек), си.выражение(x.Value))
		когда асд.ОписаниеПеременной:
			си.к("$; = $;;", си.имя описания(тек), си.выражение(x.Init))
		другое
			panic(строки.ф("assert %T", g))
		}

	}
}

*/