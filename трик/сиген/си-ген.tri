модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/сиген/имена-описаний"
импорт "трик/сиген/стр-лог"

тип Строки = []Строка

тип СиГен = класс {
	мод:  асд.Модуль = позже
	мод-си-имя: Строка = позже // си имя модуля
    си-имена = имена-описаний.Словарь{} //  map[асд.Описание]Строка
	режим-генерации-типов := ложь // TODO: убрать, всегда генерить типы полей через struct
	авто-№ := 0 // для дополнительных имен
	строки-заголовка = Строки[]
    строки-кода = Строки[]
    строки-глобалы = Строки[]
    строки-инициализация = Строки[]
	инициализация-глобалов = асд.Описания[]  // глобалы, которые надо инициализировать во входе
	sysAPI  = стр-лог.Словарь{} //  map[Строка]Лог // истина, если надо поместить в заголовок
}


фн построить код*(мод: асд.Модуль, главный: Лог) {

	пусть си = СиГен{
		мод: мод, 
		мод-си-имя: перевести имя(мод.имя),
	}

	//== импорт
	цикл имп среди мод.импорты {
		си.з("#include \"$;.h\"", си.имя описания(имп.мод))
	}
	си.з("")

	//== gen types
	си.режим-генерации-типов := истина
	// Для векторов генерируем предварительные описания
	// (без этого нарушается порядок компиляции в С-коде)
	цикл оп среди си.мод.описания {
		если оп типа асд.ОписаниеТипа {
			си.предварительное-описание-типа-вектор(оп(:асд.ОписаниеТипа))
		}
	}

	цикл оп среди си.мод.описания {
		если оп типа асд.ОписаниеТипа {
			си.описание-типа(оп(:асд.ОписаниеТипа))
		}
	}

	си.режим-генерации-типов := ложь

	//==== константы и переменные 
    цикл оп среди си.мод.описания {
		выбор пусть тек: тип оп {
		когда асд.ОписаниеКонстанты:
			си.глобальная константа(тек)
		когда асд.ОписаниеПеременной:
			си.глобальная переменная(тек)
		}
	}

	//==== функции
    цикл оп среди си.мод.описания {
		если оп типа асд.Функция {
			си.функция(оп(:асд.Функция))
		}
	}

	//== дескрипторы классов
    цикл оп среди си.мод.описания {
    
		если оп типа асд.ОписаниеТипа {
            пусть оп-типа = оп(:асд.ОписаниеТипа)
            // Нельзя делать через основу - добавляются алиасы:
			если оп-типа.Т типа асд.ТипКласс {
				си.дескриптор класса(оп-типа, асд.основа(оп.Т)(:асд.ТипКласс))
			}
		}
	}

	си.вход!(си.мод.вход?, главный)
	си.завершить()
}

//== глобальные константы

фн (си: СиГен) глобальная константа(тек: асд.ОписаниеКонстанты) {

	пусть имя = си.имя описания(тек)
    пусть т = тек.Т^

	пусть с-тип := ""
	если асд.тип-функции?(т) {
		с-тип := си.тип-функции(тек.значение^)
	} иначе {
		с-тип := си.указание-типа(т)
	}

	пусть начало := строки.ф("$; $;", с-тип, имя)

	если инициализация на месте(т) {
        начало := строки.собрать( "const ", начало) 
		си.к("$; = $;;", начало, си.выражение(тек.значение^))
	} иначе {
		си.к("$;;", начало)
		си.инициализация-глобалов.добавить(тек)
	}

	если тек.экспорт {
		си.з("extern $;;", начало)
	}
}

// Обработка кода: конст к = функ
фн (си: СиГен) тип-функции(тек: асд.Выражение): Строка {

	проверить ссылку на функцию(тек)

	пусть имя = си.новое локальное имя("FT")
    пусть тф = асд.основа(тек.Т)(:асд.ТипФункция)

	пусть список = Строки[]

	цикл пар среди тф.параметры {
		если асд.вариативный тип?(пар.Т^) {
			список.добавить(имя встроенного-типа(асд.ТЦел64()))
			список.добавить("void*")
		} иначе {
			список.добавить(си.указание-типа(пар.Т^))
		}
	}

	си.глобал("typedef $; (*$;)($;);",
		си.тип-результата(тф),
		имя,
		строки.соединить(", ", список...))

	вернуть имя
}

фн проверить ссылку на функцию(выр: асд.Выражение) {

	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
		если тек.объект типа асд.Функция {
			вернуть
		}
	когда асд.Доступ:
		если тек.объект типа асд.Функция {
			вернуть
		}
	}

	авария("assert - должна быть ссылка на функцию")
}

фн инициализация на месте(т: асд.Тип): Лог {
	т := асд.основа(т)^
    вернуть асд.байт?(т) | асд.цел64?(т) | асд.вещ64?(т) | асд.лог?(т) | асд.символ?(т)
}

//== глобальные переменные

фн (си: СиГен) глобальная переменная(тек: асд.ОписаниеПеременной) {

	если тек.экспорт {
		авария("экспортированные глобалы - запретить или сделать")
	}
	если тек.задать-позже {
		авария("ni - 'позже' для глобалов")
	}

    пусть т = тек.Т^
	пусть имя = си.имя описания(тек)
	пусть с-тип := ""
    
	если асд.тип-функции?(т) {
		авария("ni - переменные типа функция")
	} иначе {
		с-тип := си.указание-типа(т)
	}
	пусть определение = строки.ф("static $; $;", с-тип, имя)

	если инициализация на месте(т) {
		си.к("$; = $;;", определение, си.выражение(тек.значение^))
	} иначе {
		си.к("$;;", определение)
        си.инициализация-глобалов.добавить(тек)
	}
}

//==== локальные описания

фн (си: СиГен) локальное описание(оп: асд.Описание): Строка {

	выбор пусть тек: тип оп {
	когда асд.ОписаниеПеременной:

		вернуть строки.ф("$; $; = $;$;;",
			си.указание-типа(тек.Т^),
			си.имя описания(тек),
			си.конверсия при присваивании(тек.Т^, тек.значение^.Т^),
			си.выражение(тек.значение^))
	другое
		авария(строки.ф("ni - локальное описание: $тип;", оп))
	}
}

//== функции

фн (си: СиГен) функция(ф: асд.Функция) {

	если ф.внешняя {
        пусть имя-заголовка = асд.атрибут модификатора(ф.модификатор, "sysapi")
        надо имя-заголовка # "" иначе вернуть

        пусть эл = си.sysAPI.найти(имя-заголовка)
        если эл = пусто  {
            си.sysAPI.добавить(имя-заголовка, ф.экспорт)
        } иначе если ф.экспорт & ~ эл^.значение {
            си.sysAPI.добавить(имя-заголовка, истина)
		}
		вернуть
	}

	пусть тф = ф.Т(:асд.ТипФункция)

	пусть получатель := ""
    
	если ф.получатель # пусто {
		получатель := строки.ф("$; $;",
			си.указание-типа(ф.получатель^.Т^),
			си.имя описания(ф.получатель^))
		если длина(тф.параметры) > 0 {
            получатель := строки.собрать( получатель, ", ")
		}
	}

	пусть ф-заголовок = строки.ф("$; $;($;$;)",
		си.тип-результата(тф),
		си.имя функции(ф),
		получатель,
		си.параметры(тф))

	си.з("$;;", ф-заголовок)
	си.к("$; {", ф-заголовок)

	си.список операторов(ф.тело^)

	си.к("}")
}

фн (си: СиГен) тип-результата(тф: асд.ТипФункция): Строка {
	если тф.Т-вернуть = пусто {
		вернуть "void"
	} иначе {
		вернуть си.указание-типа(тф.Т-вернуть^)
	}
}

фн (си: СиГен) параметры(тф: асд.ТипФункция): Строка {

	пусть список = Строки[]

	цикл пар среди тф.параметры {

		если асд.вариативный тип?(пар.Т^) {
            список.добавить(строки.ф("$; $;$;", имя встроенного-типа(асд.ТЦел64()), си.имя описания(пар), суффикс-длины-вариативного))
			список.добавить(строки.ф("void* $;", си.имя описания(пар)))
		} иначе {
			пусть выходной := ""
			если пар.выходной {
				выходной := "*"
			}

			список.добавить(строки.ф("$;$; $;", си.указание-типа(пар.Т^), выходной, си.имя описания(пар)))
		}
	}
	вернуть строки.соединить(", ", список...)
}

//== вход - инициализация или головной

конст (
	имя-инит = "init"
	имя-выполнено = "init_done"
)

фн (си: СиГен) вход!(тек: мб асд.Вход, главный: Лог) {

	если главный {
		си.к("int main(int argc, char *argv[]) {")
		си.к("$;(argc, argv);", rt_init)
	} иначе {
		пусть заголовок = строки.ф("void $;__$;()", си.мод-си-имя, имя-инит)

		си.з("$;;", заголовок)

		си.к("static TBool $; = false;", имя-выполнено)
		си.к("$; {", заголовок)
		си.к("if ($;) return;", имя-выполнено)
		си.к("$; = true;", имя-выполнено)
	}

	цикл имп среди си.мод.импорты {
		си.к("$;__$;();", си.имя описания(имп.мод), имя-инит)
	}

	си.строки-кода.добавить(си.строки-инициализация...)

	си.инициализировать глобалы()

	если тек # пусто {
		си.список операторов(тек^.тело)
	}

	если главный {
		си.к("  return 0;")
	}
	си.к("}")
}

фн (си: СиГен) инициализировать глобалы() {
	цикл глобал среди си.инициализация-глобалов {
		выбор пусть тек: тип глобал {
		когда асд.ОписаниеКонстанты:
			си.к("$; = $;;", си.имя описания(тек), си.выражение(тек.значение^))
		когда асд.ОписаниеПеременной:
			си.к("$; = $;;", си.имя описания(тек), си.выражение(тек.значение^))
		другое
			авария(строки.ф("assert $тип;", глобал))
		}

	}
}

