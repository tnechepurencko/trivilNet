модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/сиген/стр-лог"

фн (си: СиГен) описание-типа(оп: асд.ОписаниеТипа) {

	выбор пусть тек: тип оп.Т^ {
	когда асд.ТипВектор:
		пусть имя = си.имя описания(оп)
		пусть эт = си.указание-типа(тек.Т-элемента)
		//TODO meta
		си.з("typedef struct $; {", имя)
		си.з("TInt64 len; TInt64 capacity; $;* body;", эт)
		си.з("} *$;;", имя)
	когда асд.ТипКласс:
		си.тип-класса(оп, тек)
	когда асд.УказТипа:
		// ничего
	когда асд.ТипМБ:
		// ничего
	другое
        авария(строки.ф("необработанный тип: $тип;", оп.Т^)) 
	}    
}

фн (си: СиГен) указание-типа(т: асд.Тип): Строка {
	выбор пусть тек: тип т {
	когда асд.ТипВстроенный:
		вернуть имя встроенного-типа(тек)
	когда асд.УказТипа:
		// Пропускаю указание тип до последнего
		пусть указ = асд.непосредственное указание-типа(тек)
		выбор пусть тт: тип указ.Т^ {
		когда асд.ТипВстроенный:
			вернуть имя встроенного-типа(тт)
		когда асд.ТипМБ:
			вернуть си.указание-типа(тт.Т)
		когда асд.ТипКласс:
        //! внимание - переписано по сравнению с Го
            пусть оп = указ.оп-типа^
            пусть имя =си.имя описания(оп)
            // TODO: убрать режим-генерации-типов и всегда использовать struct Т*
            если си.режим-генерации-типов & оп.владелец^ = си.мод {
            		вернуть строки.ф("struct $;*", имя)
            }
            вернуть имя
		другое
			вернуть си.имя описания(указ.оп-типа^)
		}
	когда асд.ТипМБ:
		вернуть си.указание-типа(тек.Т)
	другое
        авария(строки.ф("необработанный тип: $тип;", т))     
	}
}

фн имя встроенного-типа(т: асд.ТипВстроенный): Строка {
	выбор т.имя {
	когда "Байт":
		вернуть "TByte"
	когда "Цел64":
		вернуть "TInt64"
	когда "Вещ64":
		вернуть "TFloat64"
	когда "Слово64":
		вернуть "TWord64"
	когда "Лог":
		вернуть "TBool"
	когда "Символ":
		вернуть "TSymbol"
	когда "Строка":
		вернуть "TString"
	когда "Строка8":
		вернуть "TString"
	когда "ТегСлово":
		вернуть "TTagPair"
	другое
        авария(строки.ф("необработанный встроенный тип: $;", т.имя)) 
	}
}

// === класс

// Пропускает все алиасы, выдает имя исходного типа
фн (си: СиГен) имя исходного-типа(т: асд.Тип): Строка {
	пусть указ = асд.непосредственное указание-типа(т)
    вернуть си.имя описания(указ.оп-типа^)
}

// Генерация типа класса, дескриптор делается отдельно 
фн (си: СиГен) тип-класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {

	пусть имя-типа = си.имя описания(оп)

	пусть поля = Строки[выделить: длина(тк.поля)]
    цикл поле среди тк.поля {
		поля.добавить( строки.ф("$; $;;",
			си.указание-типа(поле.Т^),
			перевести имя(поле.имя)) // без префикса модуля
        )
	}

	си.з("struct $;$; {", имя-типа, суффикс-полей-класса)
	если тк.Т-базовый # пусто {
		си.з("struct $;$; $;;", си.имя исходного-типа(тк.Т-базовый^), суффикс-полей-класса, имя-поля-базового-класса)
	}
	си.строки-заголовка.добавить(поля...)
	си.з("};")

	си.з("struct $;$;;", имя-типа, суффикс-структуры-ВТ)

	си.з("typedef struct $; { struct $;$;* $;; struct $;$; $;;} *$;;",
		имя-типа, 
        имя-типа, суффикс-структуры-ВТ, 
        имя-поля-ВТ, 
        имя-типа, суффикс-полей-класса, 
        имя-поля-класса, 
        имя-типа)

	си.з("")
}

тип Методы = []асд.Функция

// Делает таблицу методов, мета информацию, инициализирует все данные
фн (си: СиГен) дескриптор класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {

	пусть имя-типа = си.имя описания(оп)

	си.мета данные(тк, имя-типа)

    пусть таблица = Методы[]
    пусть добавлено = стр-лог.Словарь{}

    собрать ВТ(тк.атрибуты, тк, таблица, добавлено)

	си.таблица виртуальных методов(таблица, имя-типа)
	си.функция инициализации объекта(тк, имя-типа)
    си.инициализация данных класса(тк, оп.имя, таблица, имя-типа)
}

фн (си: СиГен) мета данные(тк: асд.ТипКласс, имя-типа: Строка) {

	си.к("struct $;$; {", имя-типа, суффикс-структуры-Мета)
	си.к("size_t object_size;")
	си.к("void* base;")
	си.к("$; name;", имя встроенного-типа(асд.ТСтрока()))
	си.к("};")
}

фн (си: СиГен) таблица виртуальных методов(таблица: Методы, имя-типа: Строка) {

	си.з("struct $;$; {", имя-типа, суффикс-структуры-ВТ)
	си.з("size_t self_size;")
	си.з("void (*$;)($;);", имя-функции-инициализации-объекта, имя-типа)

    цикл метод среди таблица {
		си.з("$;", си.поле виртуального метода(метод, имя-типа))
	}

	си.з("};")
}

фн (си: СиГен) поле виртуального метода(метод: асд.Функция, имя-типа: Строка): Строка {

	пусть тф =метод.Т(:асд.ТипФункция)

	пусть список = Строки[выделить: длина(тф.параметры)+1]

	список.добавить(си.указание-типа(метод.получатель^.Т^))
    цикл пар среди тф.параметры {
		если асд.вариативный тип?(пар.Т^) {
            список.добавить(имя встроенного-типа(асд.ТЦел64()))
            список.добавить("void*")
		} иначе {
        	пусть выходной := ""
			если пар.выходной {
				выходной := "*"
			}
        
			список.добавить(строки.ф("$;$;", си.указание-типа(пар.Т^), выходной))
		}
	}

	вернуть строки.ф("$; (*$;)($;);",
		си.тип-результата(тф),
		перевести имя(метод.имя), // только имя, без префикса модуля
		строки.соединить(", ", список...))
}

фн (си: СиГен) функция инициализации объекта(тк: асд.ТипКласс, имя-типа: Строка) {
	си.к("void $;$;($; o) {", имя-типа, имя-функции-инициализации-объекта, имя-типа)

	если тк.Т-базовый # пусто {
		пусть имя-базового = си.имя исходного-типа(тк.Т-базовый^)
		си.к("(($;*)$;$;)->vt.$;((void*)o);",
			имя-структуры-дескриптора,
			имя-базового, суффикс-адрес-дескриптора,
			имя-функции-инициализации-объекта)
	}

    цикл поле среди тк.поля {
		если ~ поле.задать-позже {
			си.к("o->$;.$; = $;;", имя-поля-класса, перевести имя(поле.имя), си.выражение(поле.значение^))
		}
	}

	си.к("}")
}

// Описывает структуру, переменные, функцию инициализации и вызывает её
фн (си: СиГен) инициализация данных класса(тк: асд.ТипКласс, имя-класса: Строка, таблица: Методы, имя-типа: Строка) {

	си.к("struct { struct $;$; vt; struct $;$; meta; } $;$;;", 
        имя-типа,  суффикс-структуры-ВТ, 
        имя-типа, суффикс-структуры-Мета, 
        имя-типа, суффикс-дескриптор)

    пусть имя-дескриптора = строки.собрать(имя-типа, суффикс-дескриптор)

	пусть адр = строки.ф("void * $;$;;", имя-типа, суффикс-адрес-дескриптора)
	си.з("extern $;", адр)
	си.к("$;", адр)

	си.к("void $;$;() {", имя-типа, суффикс-инициализатора-дескриптора)

	//---- инициализация ВТ
	си.к("$;.vt.self_size = sizeof(struct $;$;);", имя-дескриптора,  имя-типа,  суффикс-структуры-ВТ)
	си.к("$;.vt.$; = &$;$;;", имя-дескриптора, имя-функции-инициализации-объекта, имя-типа, имя-функции-инициализации-объекта)

    цикл метод среди таблица {
		си.к("$;.vt.$; = &$;;", имя-дескриптора, перевести имя(метод.имя), си.имя функции(метод))
	}

	//---- инициализация Meta
	пусть базовый := "NULL"
	если тк.Т-базовый # пусто {
		базовый := строки.собрать(си.имя исходного-типа(тк.Т-базовый^), суффикс-адрес-дескриптора)
	}
	си.к("$;.meta.object_size = sizeof(struct $;);", имя-дескриптора, имя-типа)
	си.к("$;.meta.base = $;;", имя-дескриптора, базовый)

	пусть стр = строки.ф("$;($;, $;, \"$;\")", rt_newString, длина(имя-класса(:Строка8)), -1, имя-класса)

	си.к("$;.meta.name = $;;", имя-дескриптора, стр)

	//---- сохранить адрес дескриптора
	си.к("$;$; = &$;;", имя-типа, суффикс-адрес-дескриптора, имя-дескриптора)
	си.к("}")

	си.строки-инициализация.добавить(строки.ф("$;$;();", имя-типа, суффикс-инициализатора-дескриптора))
}

//==== сборка таблицы методов (VTable)

// Передаются атрибуты класса, для которого собираем таблицу, чтобы в таблицу попадали 
// нужные методы - определенные для этого класса
фн собрать ВТ(атрибуты: асд.Словарь, тк: асд.ТипКласс,  таблица: Методы, добавлено: стр-лог.Словарь) {

	если тк.Т-базовый # пусто {
        собрать ВТ(атрибуты, асд.основа(тк.Т-базовый)(:асд.ТипКласс), таблица, добавлено)
	}

    цикл метод среди тк.методы {

        если добавлено.найти(метод.имя) = пусто {
    
            пусть эл = атрибуты.найти(метод.имя) 
            надо эл # пусто иначе авария("assert")
		
            таблица.добавить(эл^.значение(:асд.Функция))
            добавлено.добавить(метод.имя, истина)
		}
	}
}
