модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"

/*
фн (си: СиГен) указание-типа(t асд.Тип) Строка {
	выбор x := t.(type) {
	когда асд.PredefinedType:
		вернуть predefinedTypeName(x.имя)
	когда асд.УказТипа:
		//fmt.Printf("~TR1 %v %T\n", x.TypeName, x.Typ)
		// Пропускаю тип ref до последнего
		пусть tr = ast.DirectTypeRef(тек)
		выбор y := tr.Typ.(type) {
		когда асд.УказТипа:
			fmt.Printf(" ~TR2 %v %T\n", y.TypeName, y.Typ)
			вернуть си.указание-типа(y.Typ)
		когда асд.ТипМБ:
			вернуть си.указание-типа(y.Typ)
		когда асд.PredefinedType:
			вернуть predefinedTypeName(y.имя)
		другое
			если си.genTypes {
				вернуть си.покаwardTypeName(tr.TypeDecl)
			}
			вернуть си.имя описания(tr.TypeDecl)
		}
	когда асд.ТипМБ:
		вернуть си.указание-типа(x.Typ)
	другое
		panic(строки.ф("assert: %T", t))
	}
}

фн (си: СиГен) покаwardTypeName(td асд.ОписаниеТипа) Строка {

	пусть name = си.имя описания(td)

	если td.GetHost() = си.мод & асд.тип-класса?(td.Typ) {
		вернуть строки.ф("= класс $;*", name)
	}
	вернуть name
}

// Выдает имя типа, чтобы использовать его с суффиксами, например, _ST
фн (си: СиГен) baseTypeName(t асд.Тип) Строка {
	выбор x := t.(type) {
	когда асд.УказТипа:
		выбор y := x.Typ.(type) {
		когда асд.УказТипа:
			вернуть си.указание-типа(y.Typ)
			//		когда асд.ТипМБ:
			//			вернуть си.указание-типа(y.Typ)
		другое
			вернуть си.имя описания(x.TypeDecl)
		}
	другое
		panic(строки.ф("assert: %T", t))
	}
}

фн predefinedTypeName(name Строка) Строка {
	выбор name {
	когда "Байт":
		вернуть "TByte"
		//	когда "Цел":
		//		вернуть "int"
	когда "Цел64":
		вернуть "TInt64"
	когда "Вещ64":
		вернуть "TFloat64"
	когда "Слово64":
		вернуть "TWord64"
	когда "Лог":
		вернуть "TBool"
	когда "Символ":
		вернуть "TSymbol"
	когда "Строка":
		вернуть "TString"
	когда "Строка8":
		вернуть "TString"
	другое
		panic(строки.ф("predefinedTypeName: ni $;", name))
	}
}

фн (си: СиГен) genTypeDecl(td асд.ОписаниеТипа) {
	выбор x := td.Typ.(type) {
	когда асд.ТипВектор:
		пусть tname = си.имя описания(td)
		пусть et = си.указание-типа(x.ElementTyp)
		//TODO meta
		си.з("typedef = класс $; {", tname)
		си.з("TInt64 len; TInt64 capacity; $;* body;", et)
		си.з("} *$;;", tname)
	когда асд.ТипКласс:
		си.genClassType(td, x)
	когда асд.УказТипа:
		/*nothing*/
	когда асд.ТипМБ:
		/*nothing*/
	другое
		panic(строки.ф("getTypeDecl: ni %T", td.Typ))
	}
}

// === класс

// genClassType - покаward VT
// описание класса - beпокаe entry
фн (си: СиГен) genClassType(td асд.ОписаниеТипа, x асд.ТипКласс) {

	пусть tname = си.имя описания(td)
	пусть tname_fields = tname + nm_class_fields_suffix
	пусть vt_тип = tname + nm_VT_suffix

	пусть fields = make([]Строка, длина(x.Fields))
	пока i, f := range x.Fields {
		fields[i] = строки.ф("$; $;;",
			си.указание-типа(f.Typ),
			си.outName(f.имя)) // без префикса модуля
	}

	си.з("= класс $; {", tname_fields)
	если x.BaseTyp # пусто {
		си.з("= класс $;$; $;;", си.baseTypeName(x.BaseTyp), nm_class_fields_suffix, nm_base_fields)
	}
	си.строки-заголовка = append(си.строки-заголовка, fields...)
	си.з("};")

	си.з("= класс $;;", vt_type)

	си.з("typedef = класс $; { = класс $;* $;; = класс $; $;;} *$;;",
		tname, vt_type, nm_VT_field, tname_fields, nm_class_fields, tname)

	си.з("")
}

фн (си: СиГен) описание класса(td асд.ОписаниеТипа, cl асд.ТипКласс) {

	пусть tname = си.имя описания(td)
	пусть tname_fields = tname + "_ST"
	пусть meta_тип = tname + nm_meta_suffix
	пусть vt_тип = tname + nm_VT_suffix

	си.genMeta(cl, meta_type)

	пусть col collector

	col.collectVTable(cl)

	си.genVTable(col.vtable, tname, meta_type, vt_type)
	си.genObjectInit(cl, tname)
	си.genClassInit(cl, td.имя, col.vtable, tname, tname_fields, meta_type, vt_type)
}

фн (си: СиГен) genMeta(cl асд.ТипКласс, meta_тип Строка) {

	си.к("= класс $; {", meta_type)
	си.к("size_t object_size;")
	си.к("void* base;")
	си.к("$; name;", predefinedTypeName(асд.ТСтрока().имя))
	си.к("};")
}

фн (си: СиГен) genVTable(vtable []асд.Функция, tname, meta_type, vt_тип Строка) {

	си.з("= класс $; {", vt_type)
	си.з("size_t self_size;")
	си.з("void (*$;)($;);", nm_object_init_suffux, tname)

	пока _, f := range vtable {
		си.з("$;", си.genMethodField(f, tname))
	}

	си.з("};")
}

фн (си: СиГен) genObjectInit(cl асд.ТипКласс, tname Строка) {
	си.к("void $;$;($; o) {", tname, nm_object_init_suffux, tname)

	если cl.BaseTyp # пусто {
		пусть base = си.baseTypeName(cl.BaseTyp)
		си.к("(($;*)$;)->vt.$;((void*)o);",
			nm_base_class_info_struct,
			base+nm_class_info_ptr_suffix,
			nm_object_init_suffux)
	}

	пока _, f := range cl.Fields {
		если ~f.задать-позже {
			си.к("o->$;.$; = $;;", nm_class_fields, си.outName(f.имя), си.выражение(f.Init))
		}
	}

	си.к("}")
}

фн (си: СиГен) genMethodField(f асд.Функция, tname Строка) Строка {
	пусть ft = f.Typ.(асд.ТипФункция)

	пусть ps = make([]Строка, длина(ft.Params)+1)

	ps[0] = си.указание-типа(f.Recv.Typ)
	пока i, p := range ft.Params {
		если асд.вариативный тип?(p.Typ) {
			ps[i+1] = "TInt64"
			ps = append(ps, "void*")
		} иначе {
			ps[i+1] = си.указание-типа(p.Typ)
		}
	}

	вернуть строки.ф("$; (*$;)($;);",
		си.вернутьType(ft),
		си.outName(f.имя), // только имя, без префикса модуля
		Строкаs.Join(ps, ", "))
}

фн (си: СиГен) genClassInit(x асд.ТипКласс,
	className Строка,
	vtable []асд.Функция,
	tname, tname_fields, meta_type, vt_тип Строка) {

	пусть desc_пусть = tname + nm_class_info_suffix
	си.к("= класс { = класс $; vt; = класс $; meta; } $;;", vt_type, meta_type, desc_var)

	пусть ptr = строки.ф("void * $;;", tname+nm_class_info_ptr_suffix)
	си.з("extern $;", ptr)
	си.к("$;", ptr)

	пусть meta_init_fn = tname + "_init"

	си.к("void $;() {", meta_init_fn)

	//-- VT
	си.к("$;.vt.self_size = sizeof(= класс $;);", desc_var, vt_type)
	си.к("$;.vt.$; = &$;$;;", desc_var, nm_object_init_suffux, tname, nm_object_init_suffux)

	пока _, f := range vtable {
		си.к("$;.vt.$; = &$;;", desc_var, си.outName(f.имя), си.фнtionName(f))
	}

	//-- Meta
	пусть base = "NULL"
	если x.BaseTyp # пусто {
		base = си.baseTypeName(x.BaseTyp) + nm_class_info_ptr_suffix
	}
	си.к("$;.meta.object_size = sizeof(= класс $;);", desc_var, tname)
	си.к("$;.meta.base = $;;", desc_var, base)

	пусть str = строки.ф("$;(%d, %d, \"$;\")", rt_newString, длина(className), -1, className)

	си.к("$;.meta.name = $;;", desc_var, str)

	//--
	си.к("$; = &$;;", tname+nm_class_info_ptr_suffix, desc_var)
	си.к("}")

	си.строки-инициализация = append(си.строки-инициализация, строки.ф("$;();", meta_init_fn))
}

//== collect methods

тип collector = класс {
	cl     асд.ТипКласс
	vtable []асд.Функция
	done   map[Строка]struct{}
}

фн (col *collector) collectVTable(x асд.ТипКласс) {

	col.cl = x
	col.vtable = make([]асд.Функция, 0)
	col.done = make(map[Строка]struct{})

	если x.BaseTyp # пусто {
		col.addMethods(асд.основа(x.BaseTyp).(асд.ТипКласс))
	}
	col.addMethods(тек)

	//fmt.Printf("~ len = %d\n", длина(col.vtable))
}

фн (col *collector) addMethods(sub асд.ТипКласс) {

	пока _, m := range sub.Methods {

		d, ok := col.cl.Members[m.имя]
		если ~ok {
			panic("assert")
		}

		f := d.(асд.Функция)

		_, ok = col.done[f.имя]
		если ~ok {
			col.vtable = append(col.vtable, d.(асд.Функция))
			col.done[f.имя] = struct{}{}
			//fmt.Printf("~ add $;\n", f.имя)
		}
	}

}
*/