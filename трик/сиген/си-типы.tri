модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"

фн (си: СиГен) описание-типа(оп: асд.ОписаниеТипа) {

	выбор пусть тек: тип оп.Т^ {
	когда асд.ТипВектор:
		пусть имя = си.имя описания(оп)
		пусть эт = си.указание-типа(тек.Т-элемента)
		//TODO meta
		си.з("typedef = класс $; {", имя)
		си.з("TInt64 len; TInt64 capacity; $;* body;", эт)
		си.з("} *$;;", имя)
	когда асд.ТипКласс:
		си.тип-класса(оп, тек)
	когда асд.УказТипа:
		// ничего
	когда асд.ТипМБ:
		// ничего
	другое
        авария(строки.ф("необработанный тип: $тип;", оп.Т^)) 
	}    
}

фн (си: СиГен) указание-типа(т: асд.Тип): Строка {
	выбор пусть тек: тип т {
	когда асд.ТипВстроенный:
		вернуть имя встроенного-типа(тек)
	когда асд.УказТипа:
		// Пропускаю указание тип до последнего
		пусть указ = асд.непосредственное указание-типа(тек)
		выбор пусть тт: тип указ.Т^ {
		когда асд.ТипВстроенный:
			вернуть имя встроенного-типа(тт)
		когда асд.ТипМБ:
			вернуть си.указание-типа(тт.Т)
		когда асд.ТипКласс:
        //! внимание - переписано по сравнению с Го
            пусть оп = указ.оп-типа^
            пусть имя =си.имя описания(оп)
            // TODO: убрать режим-генерации-типов и всегда использовать struct Т*
            если си.режим-генерации-типов & оп.владелец^ = си.мод {
            		вернуть строки.ф("struct $;*", имя)
            }
            вернуть имя
		другое
			вернуть си.имя описания(указ.оп-типа^)
		}
	когда асд.ТипМБ:
		вернуть си.указание-типа(тек.Т)
	другое
        авария(строки.ф("необработанный тип: $тип;", т))     
	}
}

/*
// Выдает имя типа, чтобы использовать его с суффиксами, например, _ST
фн (си: СиГен) baseTypeName(t асд.Тип): Строка {
	выбор x := t.(type) {
	когда асд.УказТипа:
		выбор y := x.Typ.(type) {
		когда асд.УказТипа:
			вернуть си.указание-типа(y.Typ)
			//		когда асд.ТипМБ:
			//			вернуть си.указание-типа(y.Typ)
		другое
			вернуть си.имя описания(x.TypeDecl)
		}
	другое
		авария(строки.ф("assert: $тип;", t))
	}
}
*/

фн имя встроенного-типа(т: асд.ТипВстроенный): Строка {
	выбор т.имя {
	когда "Байт":
		вернуть "TByte"
	когда "Цел64":
		вернуть "TInt64"
	когда "Вещ64":
		вернуть "TFloat64"
	когда "Слово64":
		вернуть "TWord64"
	когда "Лог":
		вернуть "TBool"
	когда "Символ":
		вернуть "TSymbol"
	когда "Строка":
		вернуть "TString"
	когда "Строка8":
		вернуть "TString"
	другое
        авария(строки.ф("необработанный встроенный тип: $;", т.имя)) 
	}
}

// === класс

// Генерация типа класса, дескриптор делается отдельно 
фн (си: СиГен) тип-класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {
/*
	пусть tname = си.имя описания(td)
	пусть tname_fields = tname + nm_class_fields_suffix
	пусть vt_тип = tname + nm_VT_suffix

	пусть fields = make([]Строка, длина(x.Fields))
	пока i, f := range x.Fields {
		fields[i] = строки.ф("$; $;;",
			си.указание-типа(f.Typ),
			си.outName(f.имя)) // без префикса модуля
	}

	си.з("= класс $; {", tname_fields)
	если x.BaseTyp # пусто {
		си.з("= класс $;$; $;;", си.baseTypeName(x.BaseTyp), nm_class_fields_suffix, nm_base_fields)
	}
	си.строки-заголовка = append(си.строки-заголовка, fields...)
	си.з("};")

	си.з("= класс $;;", vt_type)

	си.з("typedef = класс $; { = класс $;* $;; = класс $; $;;} *$;;",
		tname, vt_type, nm_VT_field, tname_fields, nm_class_fields, tname)

	си.з("")
*/    
}

// Делает таблицу методов, мета информацию, инициализирует все данные
фн (си: СиГен) дескриптор класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {
/*
	пусть tname = си.имя описания(td)
	пусть tname_fields = tname + "_ST"
	пусть meta_тип = tname + nm_meta_suffix
	пусть vt_тип = tname + nm_VT_suffix

	си.genMeta(cl, meta_type)

	пусть col collector

	col.collectVTable(cl)

	си.genVTable(col.vtable, tname, meta_type, vt_type)
	си.genObjectInit(cl, tname)
	си.genClassInit(cl, td.имя, col.vtable, tname, tname_fields, meta_type, vt_type)
*/    
}

/*
фн (си: СиГен) genMeta(cl асд.ТипКласс, meta_тип Строка) {

	си.к("= класс $; {", meta_type)
	си.к("size_t object_size;")
	си.к("void* base;")
	си.к("$; name;", имя встроенного-типа(асд.ТСтрока()))
	си.к("};")
}

фн (си: СиГен) genVTable(vtable []асд.Функция, tname, meta_type, vt_тип Строка) {

	си.з("= класс $; {", vt_type)
	си.з("size_t self_size;")
	си.з("void (*$;)($;);", nm_object_init_suffux, tname)

	пока _, f := range vtable {
		си.з("$;", си.genMethodField(f, tname))
	}

	си.з("};")
}

фн (си: СиГен) genObjectInit(cl асд.ТипКласс, tname Строка) {
	си.к("void $;$;($; o) {", tname, nm_object_init_suffux, tname)

	если cl.BaseTyp # пусто {
		пусть base = си.baseTypeName(cl.BaseTyp)
		си.к("(($;*)$;)->vt.$;((void*)o);",
			nm_base_class_info_struct,
			base+nm_class_info_ptr_suffix,
			nm_object_init_suffux)
	}

	пока _, f := range cl.Fields {
		если ~f.задать-позже {
			си.к("o->$;.$; = $;;", nm_class_fields, си.outName(f.имя), си.выражение(f.Init))
		}
	}

	си.к("}")
}

фн (си: СиГен) genMethodField(f асд.Функция, tname Строка): Строка {
	пусть ft = f.Typ.(асд.ТипФункция)

	пусть ps = make([]Строка, длина(ft.Params)+1)

	ps[0] = си.указание-типа(f.Recv.Typ)
	пока i, p := range ft.Params {
		если асд.вариативный тип?(p.Typ) {
			ps[i+1] = "TInt64"
			ps = append(ps, "void*")
		} иначе {
			ps[i+1] = си.указание-типа(p.Typ)
		}
	}

	вернуть строки.ф("$; (*$;)($;);",
		си.тип-результата(ft),
		си.outName(f.имя), // только имя, без префикса модуля
		Строкаs.Join(ps, ", "))
}

фн (си: СиГен) genClassInit(тек: асд.ТипКласс,
	className Строка,
	vtable []асд.Функция,
	tname, tname_fields, meta_type, vt_тип Строка) {

	пусть desc_пусть = tname + nm_class_info_suffix
	си.к("= класс { = класс $; vt; = класс $; meta; } $;;", vt_type, meta_type, desc_var)

	пусть ptr = строки.ф("void * $;;", tname+nm_class_info_ptr_suffix)
	си.з("extern $;", ptr)
	си.к("$;", ptr)

	пусть meta_init_fn = tname + "_init"

	си.к("void $;() {", meta_init_fn)

	//-- VT
	си.к("$;.vt.self_size = sizeof(= класс $;);", desc_var, vt_type)
	си.к("$;.vt.$; = &$;$;;", desc_var, nm_object_init_suffux, tname, nm_object_init_suffux)

	пока _, f := range vtable {
		си.к("$;.vt.$; = &$;;", desc_var, си.outName(f.имя), си.имя функции(f))
	}

	//-- Meta
	пусть base = "NULL"
	если x.BaseTyp # пусто {
		base = си.baseTypeName(x.BaseTyp) + nm_class_info_ptr_suffix
	}
	си.к("$;.meta.object_size = sizeof(= класс $;);", desc_var, tname)
	си.к("$;.meta.base = $;;", desc_var, base)

	пусть str = строки.ф("$;(%d, %d, \"$;\")", rt_newString, длина(className), -1, className)

	си.к("$;.meta.name = $;;", desc_var, str)

	//--
	си.к("$; = &$;;", tname+nm_class_info_ptr_suffix, desc_var)
	си.к("}")

	си.строки-инициализация = append(си.строки-инициализация, строки.ф("$;();", meta_init_fn))
}

//== collect methods

тип collector = класс {
	cl     асд.ТипКласс
	vtable []асд.Функция
	done   map[Строка]struct{}
}

фн (col *collector) collectVTable(тек: асд.ТипКласс) {

	col.cl = x
	col.vtable = make([]асд.Функция, 0)
	col.done = make(map[Строка]struct{})

	если x.BaseTyp # пусто {
		col.addMethods(асд.основа(x.BaseTyp).(асд.ТипКласс))
	}
	col.addMethods(тек)

	//fmt.Printf("~ len = %d\n", длина(col.vtable))
}

фн (col *collector) addMethods(sub асд.ТипКласс) {

	пока _, m := range sub.Methods {

		d, ok := col.cl.Members[m.имя]
		если ~ok {
			авария("assert")
		}

		f := d.(асд.Функция)

		_, ok = col.done[f.имя]
		если ~ok {
			col.vtable = append(col.vtable, d.(асд.Функция))
			col.done[f.имя] = struct{}{}
			//fmt.Printf("~ add $;\n", f.имя)
		}
	}

}
*/