модуль сиген

импорт "стд::вывод"
импорт "стд::платформа"
импорт "стд::строки"
импорт "стд::файлы"

импорт "трик/асд"
импорт "трик/основа"

конст (
	имя-конфиг-файла = "genc.txt"
	место-папка-файлов     = "#genc#"
	место-файлы    = "#files#"
	место-имя-цели   = "#target#"
	место-папка-runtime  = "#runtime#"
)

тип Модули = []асд.Модуль

фн построить исполняемый файл*(модули: Модули) {

    вывод.ф("построить исполняемый файл")

    пусть настройки = прочитать конфигурацию()
	надо основа.число ошибок() = 0 иначе вернуть

    пусть ОС = платформа.вид ОС()
    //пусть имя = строки.сборка(ОС, "-build")

    пусть команда := найти настройку(настройки, строки.собрать(ОС, "-build"))
    надо команда # "" иначе вернуть 

    пусть имена = Строки[выделить: длина(модули)]

	цикл мод среди модули {
        имена.добавить(строки.ф("$;.c", перевести имя(мод.имя)))
	}

    пусть цель = перевести имя(модули[длина(модули)-1].имя)

	команда := строки.заменить все(команда, место-файлы, строки.соединить(" ", имена...))
вывод.ф("$;\n", команда)    
	команда := строки.заменить все(команда, место-папка-runtime, основа.путь к папке runtime())
вывод.ф("$;\n", команда)    
	команда := строки.заменить все(команда, место-имя-цели, цель)
вывод.ф("$;\n", команда)    

    пусть ф = файлы.новый файл(основа.подготовить папку кода())
    пусть выходная-папка = ф.абсолютный путь()
	команда := строки.заменить все(команда, место-папка-файлов, выходная-папка)

	//==== запись скрипта
	пусть скрипт = найти настройку(настройки, строки.собрать(ОС, "-script"))
	если скрипт # "" {
		пусть список = Строки[команда]

		записать файл(выходная-папка, скрипт, "", список)
	}
/*
	пусть arg Строка
	пусть mainCmd Строка

	выбор runtime.GOOS {
	когда "windows":
		mainCmd = "cmd"
		arg = строки.ф("[/c cd $; & call $; ]", folder, скрипт)
		//fmt.Printf("arg %v\n", arg)
	когда "linux":
		absoluteFolder, _ := filepath.Abs(folder)
		mainCmd = "bash"
		arg = path.Join(absoluteFolder, скрипт)
	другое
		авария("build not implemented пока " + runtime.GOOS)
	}

	пусть cmd = exec.Command(mainCmd, arg)
	out, err := cmd.CombinedOutput()
	если err # пусто {
		fmt.Printf("Exec failed: $;\n$;\n", err.Error(), Строка(out))
	} иначе {
		fmt.Printf("Execute: $;/$;  Rebuild C code: $;/$;\n", folder, target, folder, скрипт)
	}
*/    
}

//==== конфигурация

фн прочитать конфигурацию(): Строки {

    пусть путь = основа.собрать путь настройки(имя-конфиг-файла)
    пусть файл = файлы.новый файл(путь)
    пусть байты = файл.прочитать()    
	если файл.ошибка?() # пусто {
		основа.добавить общую ошибку("ГЕН-ОШ-КОНФ-ФАЙЛА", файл.ошибка?()^.сообщение())
		вернуть Строки[]
	}
    
	вернуть строки.разобрать(байты(:Строка), "\n")
}    


фн найти настройку(настройки: Строки, имя: Строка): Строка {

	цикл стр среди настройки {
		если строки.есть префикс(стр, имя) {
            пусть левая := ""
            пусть правая := ""
			если строки.разделить(стр, ":", левая, правая) {
                пусть настройка = строки.обрезать пробельные символы(правая)
                надо настройка # "" иначе {
                    основа.добавить общую ошибку("ГЕН-ОШ-НАСТРОЙКА", имя-конфиг-файла, имя)
                    вернуть ""
                }
                вернуть настройка 
            }
		}
	}
	основа.добавить общую ошибку("ГЕН-ОШ-НАСТРОЙКА", имя-конфиг-файла, имя)
	вернуть ""
}


