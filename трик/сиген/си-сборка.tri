модуль сиген

импорт "стд::вывод"
импорт "стд::платформа"
импорт "стд::строки"
импорт "стд::файлы"

импорт "трик/асд"
импорт "трик/основа"

конст (
	имя-конфиг-файла = "genc.txt"
	маркер-папка-файлов = "#genc#"
	маркер-файлы = "#files#"
	маркер-имя-цели = "#target#"
	маркер-папка-runtime = "#runtime#"
)

тип Модули = []асд.Модуль

фн построить исполняемый файл*(модули: Модули) {

    пусть настройки = прочитать конфигурацию()
	надо основа.число ошибок() = 0 иначе вернуть

    пусть ОС = платформа.вид ОС()
    //пусть имя = строки.сборка(ОС, "-build")

    пусть сборка := найти настройку(настройки, строки.собрать(ОС, "-build"))
    надо сборка # "" иначе вернуть 

    пусть имена = Строки[выделить: длина(модули)]

	цикл мод среди модули {
        имена.добавить(строки.ф("$;.c", перевести имя(мод.имя)))
	}

    //пусть цель = перевести имя(модули[длина(модули)-1].имя)
    пусть цель = модули[длина(модули)-1].имя

	сборка := строки.заменить все(сборка, маркер-файлы, строки.соединить(" ", имена...))
	сборка := строки.заменить все(сборка, маркер-папка-runtime, основа.путь к папке runtime())
	сборка := строки.заменить все(сборка, маркер-имя-цели, цель)

    пусть папка = файлы.новый файл(основа.подготовить папку кода())
    пусть выходная-папка = папка.абсолютный путь()
	сборка := строки.заменить все(сборка, маркер-папка-файлов, выходная-папка)

	//==== запись скрипта
	пусть скрипт = найти настройку(настройки, строки.собрать(ОС, "-script"))
	если скрипт # "" {
		пусть список = Строки[сборка]

		записать исполняемый файл(выходная-папка, скрипт, "", список)
	}

	пусть аргумент := ""
	пусть исполнитель := ""

	выбор ОС {
	когда "windows":
		исполнитель := "cmd /c"
		аргумент := строки.ф("\"cd $; & call $; >NUL\"", папка.путь(), скрипт)
	когда "linux", "darwin", "freebsd":
		исполнитель := "bash"
		аргумент := файлы.собрать путь(выходная-папка, скрипт)
	другое
		авария(строки.ф("сборка не сделана для $;\n", ОС))
	}

    пусть команда = строки.собрать(исполнитель, " ", аргумент)

    пусть ответ = платформа.выполнить(команда)
    если ответ {
		вывод.ф("Выполнить: ./$;  Собрать: $;/$;\n", цель, папка.путь(), скрипт)
    } иначе {
		//вывод.ф("Ошибка при сборке. Проверить сборку: $;/$;\n", папка.путь(), скрипт)
        основа.добавить общую ошибку("ГЕН-ОШ-СБОРКА", папка.путь(), скрипт)
    }

/*
	пусть cmd = exec.Command(mainCmd, arg)
	out, err := cmd.CombinedOutput()
	если err # пусто {
		fmt.Printf("Exec failed: $;\n$;\n", err.Error(), Строка(out))
	} иначе {
		fmt.Printf("Execute: $;/$;  Rebuild C code: $;/$;\n", folder, target, folder, скрипт)
	}
*/    
}

//==== конфигурация

фн прочитать конфигурацию(): Строки {

    пусть путь = основа.собрать путь настройки(имя-конфиг-файла)
    пусть файл = файлы.новый файл(путь)
    пусть байты = файл.прочитать()    
	если файл.ошибка?() # пусто {
		основа.добавить общую ошибку("ГЕН-ОШ-КОНФ-ФАЙЛА", файл.ошибка?()^.сообщение())
		вернуть Строки[]
	}
    
	вернуть строки.разобрать(байты(:Строка), "\n")
}    


фн найти настройку(настройки: Строки, имя: Строка): Строка {

	цикл стр среди настройки {
		если строки.есть префикс(стр, имя) {
            пусть левая := ""
            пусть правая := ""
			если строки.разделить(стр, ":", левая, правая) {
                пусть настройка = строки.обрезать пробельные символы(правая)
                надо настройка # "" иначе {
                    основа.добавить общую ошибку("ГЕН-ОШ-НАСТРОЙКА", имя-конфиг-файла, имя)
                    вернуть ""
                }
                вернуть настройка 
            }
		}
	}
	основа.добавить общую ошибку("ГЕН-ОШ-НАСТРОЙКА", имя-конфиг-файла, имя)
	вернуть ""
}


