модуль сиген

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод"

импорт "трик/асд"
импорт "трик/лексер"

фн (си: СиГен) выражение(выр: асд.Выражение): Строка {
	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
		вернуть си.идентификатор(тек)
	когда асд.Литерал:
		вернуть си.литерал(тек)
	когда асд.УнарнаяОперация:
		вернуть строки.ф("$;($;)", унарная операция(тек.операция), си.выражение(тек.Л))
	когда асд.БинарнаяОперация:
		вернуть си.бинарное выражение(тек)
	когда асд.ПроверкаТипа:
		вернуть си.проверка-типа(тек)
	когда асд.Доступ:
		вернуть си.доступ(тек)
	когда асд.Вызов:
		вернуть си.вызов(тек)
	когда асд.Преобразовать:
		если тек.осторожное {
			вернуть си.осторожное преобразование(тек)
		} иначе {
			вернуть си.преобразование(тек)
		}
	когда асд.ПодтверждениеТипа:
		вернуть си.подтверждение-типа(тек)

	когда асд.ИндексацияИлиКомпозит:
		вернуть си.индексация или конструктор вектора(тек)

	когда асд.КомпозитКласса:
		вернуть си.конструктор класса(тек)

	другое
		авария(строки.ф("выражение: $тип;", выр))
	}
}

//==== идентификатор

фн (си: СиГен) идентификатор(тек: асд.ОперандИдент): Строка {

	пусть оп = тек.объект^(:асд.Описание)
	пусть рез = константа как литерал(оп)
	если рез # "" {
		вернуть рез
	}

	если выходной параметр?(оп) {
		вернуть строки.ф("(*$;)", си.имя описания(оп))
	}

	вернуть си.имя описания(оп)
}

фн константа как литерал(оп: асд.Описание): Строка {

	если ~ (оп типа асд.ОписаниеКонстанты) {
		вернуть ""
	}
	выбор пусть тек: тип оп(:асд.ОписаниеКонстанты).значение^ {
	когда асд.ЛогЛитерал:
		если тек.значение {
			вернуть "истина"
		} иначе {
			вернуть "ложь"
		}
	когда асд.Литерал:
		если асд.тип-пусто?(тек.Т^) {
			вернуть "NULL"
		}
	}
	вернуть ""
}

фн выходной параметр?(оп: асд.Описание): Лог {
	надо оп типа асд.ОписаниеПеременной иначе 	вернуть ложь
	вернуть оп(:асд.ОписаниеПеременной).выходной-параметр
}

//== literals

фн (си: СиГен) литерал(лит: асд.Литерал): Строка {
	выбор лит.вид {
	когда асд.Лит-Цел:
		вернуть строки.ф("$цел;", лит.цел)
	когда асд.Лит-Слово:
		вернуть строки.ф("0x$ш;", лит.слово)
	когда асд.Лит-Вещ:
		вернуть лит.вещ
	когда асд.Лит-Символ:
		вернуть строки.ф("0x$ш;", лит.слово)
	когда асд.Лит-Строка:
		вернуть си.строковый литерал(лит)
	другое
		авария("ni")
	}
}

фн (си: СиГен) строковый литерал(лит: асд.Литерал): Строка {
	если длина(лит.стр^) = 0 {
		вернуть строки.ф("$;()", rt_emptyString)
	}

	пусть имя = си.новое локальное имя(префикс-строкового-литерала)
	си.глобал("static TString $; = NULL;", имя)

	пусть стр = приготовить строковый литерал(лит.стр^)

	// передаю -1 в число байтов, чтобы не учитывать Си эскейп последовательности
	вернуть строки.ф("$;(&$;, %d, %d, \"$;\")", rt_newLiteralString, имя, -1, длина(лит.стр^), стр)
}

фн приготовить строковый литерал(символы: Символы): Строка {
	пусть сб = строки.Сборщик{}
    
    цикл сим среди символы {
		выбор сим {
/*        
		когда '\a':
			сб.добавить строку("\\a")
		когда '\b':
			сб.добавить строку("\\b")
		когда '\f':
			сб.добавить строку("\\f")
*/
		когда '\n':
			сб.добавить строку("\\n")
		когда '\r':
			сб.добавить строку("\\r")
		когда '\t':
			сб.добавить строку("\\t")
//		когда '\v':
//			сб.добавить строку("\\v")
		когда '\\':
			сб.добавить строку("\\\\")
		когда '"':
			сб.добавить строку("\\\"")
		другое
			если юникод.управляющий символ?(сим) {
				авария("ni") // можно \0xddd
			}
			сб.добавить символ(сим)
		}
	}
	вернуть сб.строка()
}

//==== унарные операции

фн унарная операция(операция: лексер.Лексема): Строка {
	выбор операция {
	когда лексер.ВЫЧЕСТЬ:
		вернуть "-"
	когда лексер.НЕ:
		вернуть "~"
	когда лексер.БИТ-НЕ:
		вернуть "~"

	другое
		авария(строки.ф("ni унарная: $;", лексер.для показа(операция)))
	}
}

//== бинарные операции

фн бинарная операция(операция: лексер.Лексема): Строка {
	выбор операция {
	когда лексер.ИЛИ:
		вернуть "|"
	когда лексер.И:
		вернуть "&"
	когда лексер.РАВНО:
		вернуть "="
	когда лексер.НЕ-РАВНО:
		вернуть "#"
	когда лексер.МЕНЬШЕ:
		вернуть "<"
	когда лексер.МЕНЬШЕ-РАВНО:
		вернуть "<="
	когда лексер.БОЛЬШЕ:
		вернуть ">"
	когда лексер.БОЛЬШЕ-РАВНО:
		вернуть ">="
	когда лексер.СЛОЖИТЬ:
		вернуть "+"
	когда лексер.ВЫЧЕСТЬ:
		вернуть "-"
	когда лексер.БИТ-ИЛИ:
		вернуть "|"
	когда лексер.УМНОЖИТЬ:
		вернуть "*"
	когда лексер.ДЕЛИТЬ:
		вернуть "/"
	когда лексер.ОСТАТОК:
		вернуть "%"
	когда лексер.БИТ-И:
		вернуть "&"
	когда лексер.БИТ-ИСК-ИЛИ:
		вернуть "^"
	когда лексер.СДВИГ-Л:
		вернуть "<<"
	когда лексер.СДВИГ-П:
		вернуть ">>"
	другое
		авария(строки.ф("ni бинарная: $;", лексер.для показа(операция)))
	}
}

фн (си: СиГен) бинарное выражение(тек: асд.БинарнаяОперация): Строка {

    пусть т = тек.Л.Т^
	если асд.строка?(т) {
		пусть не := ""
		если тек.операция =лексер.НЕ-РАВНО {
			не := "~"
		}

		вернуть строки.ф("$;$;($;, $;)", не, rt_equalStrings, си.выражение(тек.Л), си.выражение(тек.П))
	}

	если асд.тип-класса?(тек.Л.Т^) {
		вернуть строки.ф("((void*)$; $; (void*)$;)", си.выражение(тек.Л), бинарная операция(тек.операция), си.выражение(тек.П))
	} иначе {
		вернуть строки.ф("($; $; $;)", си.выражение(тек.Л), бинарная операция(тек.операция), си.выражение(тек.П))
	}
}

фн (си: СиГен) проверка-типа(тек: асд.ПроверкаТипа): Строка {
	пусть имя-типа = си.указание-типа(тек.цель)

	вернуть строки.ф("$;($;, $;$;)",
		rt_isClassType,
		си.выражение(тек.Л),
		имя-типа,
        суффикс-адрес-дескриптора)

}

//== selector

фн (си: СиГен) доступ(тек: асд.Доступ): Строка {
	если тек.Л = пусто {
		вернуть си.имя описания(тек.объект^(:асд.Описание))
	}

	пусть тк = асд.основа(тек.Л^.Т^)^(:асд.ТипКласс)
    
	вернуть строки.ф("($;)->$;.$;$;",
		си.выражение(тек.Л^),
		имя-поля-класса,
		путь к полю(тк, тек.имя),
		перевести имя(тек.имя))
}

фн путь к полю(тк: асд.ТипКласс, имя-поля: Строка): Строка {
	пусть путь := ""
	пока истина {
		если тк.Т-базовый = пусто {
			прервать
		}
		тк := асд.основа(тк.Т-базовый)^(:асд.ТипКласс)

        пусть эл = тк.атрибуты.найти(имя-поля)
		если эл = пусто  {
			прервать
		}
		путь := строки.собрать(путь, имя-поля-базового-класса, ".")
	}
	вернуть путь
}

//== проверка на не пусто

фн (си: СиГен) подтверждение-типа(тек: асд.ПодтверждениеТипа): Строка {
	вернуть строки.ф("($;)$;($;,$;)",
		си.указание-типа(тек.Т^),
		rt_nilcheck,
		си.выражение(тек.Л),
		позиция в строку(тек.поз))
}

//== индексация и композит массива

фн (си: СиГен) индексация или конструктор вектора(тек: асд.ИндексацияИлиКомпозит): Строка {
    вернуть ""
/*
	если x.Index # пусто {

		выбор xt := асд.основа(тек.Л.Т).(type) {
		когда асд.ТипВектор:
			вернуть си.genVectorIndex(тек.Л, x.Index, "len")
		когда асд.ТипВариативный:
			вернуть си.genVariadicIndex(xt, тек.Л, x.Index)
		другое
			если xt = асд.ТСтрока8() {
				вернуть си.genVectorIndex(тек.Л, x.Index, "bytes")
			}
			авария("assert")
		}
	}

	вернуть си.genArrayComposite(x.Composite)
*/    
}

/*
фн (си: СиГен) genVectorIndex(x, inx асд.Выражение, lenName Строка): Строка {
	пусть name Строка
	если id, ok := x.(асд.ОперандИдент); ok {
		name = си.идентификатор(id)
	} иначе {
		name = си.новое локальное имя("")

		си.к("$; $; = $;;",
			си.указание-типа(тек.Т),
			name,
			си.выражение(тек))
	}
	вернуть строки.ф("$;->body[$;($;, $;->$;,$;)]",
		name,
		rt_indexcheck,
		си.выражение(inx),
		name,
		lenName,
		позиция в строку(inx.поз))

}

фн (си: СиГен) genVariadicIndex(vt асд.ТипВариативный, x, inx асд.Выражение): Строка {

	пусть vPar = си.выражение(тек)

	если асд.полиморфный тип?(vt.ElementTyp) {
		/ *
			вернуть строки.ф("(($;*)($; + sizeof(TInt64)))[$;($;, *(TInt64 *)$;) << 1]",
				имя встроенного-типа(асд.ТЦел64()),
				vPar,
				rt_indexcheck,
				си.выражение(inx),
				vPar)
		* /
		авария("assert")
	} иначе {

		вернуть строки.ф("(($;*)$;)[$;($;, $;$;, $;)]",
			си.указание-типа(vt.ElementTyp),
			vPar,
			rt_indexcheck,
			си.выражение(inx),
			vPar,
			суффикс-длины-вариативного,
			позиция в строку(inx.поз))
	}
}

//== конструктор вектора

фн (си: СиГен) genArrayComposite(тек: асд.ArrayCompositeExpr): Строка {
	пусть vt = асд.основа(x.Typ).(асд.ТипВектор)

	пусть name = си.новое локальное имя("")
	пусть lenExpr = си.genArrayCompositeLen(тек)

	// нужно ли проверять макс индекс на < длина?
	если длина(x.Indexes) > 0 & x.LenExpr # пусто {
		// c.Length = maxIndex + 1
		пусть lenName = си.новое локальное имя("len")
		си.к("$; $; = $;;", имя встроенного-типа(асд.ТЦел64()), lenName, lenExpr)
		lenExpr = lenName

		си.к("$;(%d, $;, $;);", rt_indexcheck, x.MaxIndex, lenName, позиция в строку(x.поз))
	}

	пусть s = ""

	если x.Default # пусто {
		s = строки.ф("$; $; = $;(sizeof($;), $;, $;, $;);",
			си.указание-типа(x.Typ),
			name,
			rt_newVectorFill,
			си.указание-типа(vt.ElementTyp),
			lenExpr,
			си.genArrayCompositeCap(тек),
			си.genFiller(x.Default))
	} иначе {
		s = строки.ф("$; $; = $;(sizeof($;), $;, $;);",
			си.указание-типа(x.Typ),
			name,
			rt_newVector,
			си.указание-типа(vt.ElementTyp),
			lenExpr,
			си.genArrayCompositeCap(тек))
	}

	пусть list = make([]Строка, длина(x.Values))
	пока i, val := range x.Values {
		пусть inx Строка
		если длина(x.Indexes) = 0 {
			inx = строки.ф("%d", i)
		} иначе {
			inx = си.выражение(x.Indexes[i])
		}
		list[i] = строки.ф("$;->body[$;] = $;;", name, inx, си.выражение(val))
	}
	s += Строкаs.Join(list, " ")

	си.к("$;", s)

	вернуть name
}

фн (си: СиГен) genArrayCompositeLen(тек: асд.ArrayCompositeExpr): Строка {
	// если длина задана явно и это константое выражение
	если x.Length >= 0 {
		вернуть строки.ф("%d", x.Length)
	}

	// если длина задана явно
	если x.LenExpr # пусто {
		вернуть си.выражение(x.LenExpr)
	}

	// если длина задана неявно по индексам
	если x.MaxIndex >= 0 {
		вернуть строки.ф("%d", x.MaxIndex+1)
	}

	// если последовательность значений (без индекса)
	вернуть строки.ф("%d", длина(x.Values))
}

фн (си: СиГен) genArrayCompositeCap(тек: асд.ArrayCompositeExpr): Строка {
	если x.CapExpr # пусто {
		вернуть си.выражение(x.CapExpr)
	}
	вернуть "0"
}

фн (си: СиГен) genFiller(тек: асд.Выражение): Строка {
	пусть expr = си.выражение(тек)

	вернуть си.genCastToWord64(expr, тек.Т)
}
*/

//== конструктор класса

фн (си: СиГен) конструктор класса(тек: асд.КомпозитКласса): Строка {
    вернуть ""
/*
	пусть name = си.новое локальное имя("")

	пусть tname = си.указание-типа(x.Typ)
	пусть s = строки.ф("$; $; = $;($;);",
		tname,
		name,
		rt_newObject,
		tname+суффикс-адрес-дескриптора)

	пусть cl = асд.основа(x.Typ).(асд.ТипКласс)

	пусть list = make([]Строка, длина(x.Values))
	пока i, v := range x.Values {
		пусть cast = си.конверсия при присваивании(v.Field.Typ, v.Value.GetType())
		list[i] = строки.ф("$;->$;.$;$; = $;$;;",
			name, имя-поля-класса, путь к полю(cl, v.имя), перевести имя(v.имя),
			cast, си.выражение(v.Value))
	}
	s += Строкаs.Join(list, " ")

	си.к("$;", s)
	вернуть name
*/    
}
