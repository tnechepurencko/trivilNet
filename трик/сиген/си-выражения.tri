модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"
импорт "трик/лексер"

фн (си: СиГен) выражение(выр: асд.Выражение): Строка {
/*
	выбор x := expr.(type) {
	когда асд.ОперандИдент:
		вернуть си.идентификатор(тек)
	когда асд.Литерал:
		вернуть си.литерал(тек)
	когда асд.УнарнаяОперация:
		вернуть строки.ф("$;($;)", unaryOp(x.Op), си.выражение(x.X))
	когда асд.БинарнаяОперация:
		вернуть си.бинарное выражениеExpr(тек)
	когда асд.ПроверкаТипа:
		вернуть си.проверка-типа(тек)
	когда асд.Доступ:
		вернуть си.доступ(тек)
	когда асд.Вызов:
		вернуть си.вызов(тек)
	когда асд.Преобразовать:
		если x.Caution {
			вернуть си.осторожное преобразование(тек)
		} иначе {
			вернуть си.преобразование(тек)
		}
	когда асд.ПодтверждениеТипа:
		вернуть си.подтверждение-типа(тек)

	когда асд.ИндексацияИлиКомпозит:
		вернуть си.индексация или конструктор вектора(тек)

	когда асд.КомпозитКласса:
		вернуть си.конструктор класса(тек)

	другое
		авария(строки.ф("gen expression: ni $тип;", expr))
	}
*/
        авария("не")
}

/*
фн (си: СиГен) идентификатор(id асд.ОперандИдент): Строка {

	пусть d = id.Obj.(асд.Описание)
	пусть s = genConstAsLiteral(d)
	если s # "" {
		вернуть s
	}

	если isVarOutParam(d) {
		вернуть строки.ф("(*$;)", си.имя описания(d))
	}

	вернуть си.имя описания(d)
}

фн isVarOutParam(d асд.Описание) Лог {
	v, ok := d.(асд.ОписаниеПеременной)
	если ~ok {
		вернуть ложь
	}
	вернуть v.OutParam
}

фн genConstAsLiteral(d асд.Описание): Строка {

	c, ok := d.(асд.ОписаниеКонстанты)
	если ~ok {
		вернуть ""
	}
	выбор x := c.Value.(type) {
	когда асд.BoolLiteral:
		если x.Value {
			вернуть "истина"
		} иначе {
			вернуть "ложь"
		}
	когда асд.Литерал:
		если x.Typ = ast.NullType {
			вернуть "NULL"
		}
	}
	вернуть ""
}

//== literals

фн (си: СиГен) литерал(li асд.Литерал): Строка {
	выбор li.Kind {
	когда асд.Лит-Цел:
		вернуть строки.ф("%d", li.IntVal)
	когда асд.Лит-Слово:
		вернуть строки.ф("0x%x", li.WordVal)
	когда асд.Лит-Вещ:
		вернуть li.FloatStr
	когда асд.Лит-Символ:
		вернуть строки.ф("0x%x", li.WordVal)
	когда ast.Lit_String:
		вернуть си.genStringLiteral(li)
	другое
		авария("ni")
	}
}

фн (си: СиГен) genStringLiteral(li асд.Литерал): Строка {

	если длина(li.StrVal) = 0 {
		вернуть строки.ф("$;()", rt_emptyString)
	}

	пусть name = си.новое локальное имя(nm_СтрокаLiteral)
	си.g("static TString $; = NULL;", name)

	пусть outs = encodeLiteralString(li.StrVal)
	//fmt.Printf("~ байты=%d  символы=%d\n", длина(outs), длина(li.StrVal))

	// передаю -1 в число байтов, чтобы не учитывать Си эскейп последовательности
	вернуть строки.ф("$;(&$;, %d, %d, \"$;\")", rt_newLiteralString, name, -1, длина(li.StrVal), outs)
}

фн encodeLiteralString(runes []rune): Строка {
	пусть b = Строкаs.Builder{}
	пока _, r := range runes {
		выбор r {
		когда '\a':
			b.WriteString("\\a")
		когда '\b':
			b.WriteString("\\b")
		когда '\f':
			b.WriteString("\\f")
		когда '\n':
			b.WriteString("\\n")
		когда '\r':
			b.WriteString("\\r")
		когда '\t':
			b.WriteString("\\t")
		когда '\v':
			b.WriteString("\\v")
		когда '\\':
			b.WriteString("\\\\")
		когда '"':
			b.WriteString("\\\"")
		другое
			если unicode.IsControl(r) {
				авария("ni") // можно \0xddd
			}
			b.WriteRune(r)
		}
	}
	вернуть b.String()
}

//== унарные операции

фн unaryOp(op lexer.Token): Строка {
	выбор op {
	когда lexer.SUB:
		вернуть "-"
	когда lexer.NOT:
		вернуть "~"
	когда lexer.BITNOT:
		вернуть "~"

	другое
		авария("ni unary" + op.String())
	}
}

//== бинарные операции

фн binaryOp(op lexer.Token): Строка {
	выбор op {
	когда lexer.OR:
		вернуть "|"
	когда lexer.AND:
		вернуть "&"
	когда lexer.EQ:
		вернуть "="
	когда lexer.NEQ:
		вернуть "#"
	когда lexer.LSS:
		вернуть "<"
	когда lexer.LEQ:
		вернуть "<="
	когда lexer.GTR:
		вернуть ">"
	когда lexer.GEQ:
		вернуть ">="
	когда lexer.ADD:
		вернуть "+"
	когда lexer.SUB:
		вернуть "-"
	когда lexer.BITOR:
		вернуть "|"
	когда lexer.MUL:
		вернуть "*"
	когда lexer.QUO:
		вернуть "/"
	когда lexer.REM:
		вернуть "%"
	когда lexer.BITAND:
		вернуть "&"
	когда lexer.BITXOR:
		вернуть "^"
	когда lexer.SHL:
		вернуть "<<"
	когда lexer.SHR:
		вернуть ">>"
	другое
		авария("ni binary" + op.String())
	}
}

фн (си: СиГен) бинарное выражениеExpr(тек: асд.БинарнаяОперация): Строка {

	если асд.строка?(тек.Л.Т) {
		пусть not = ""
		если x.Op = lexer.NEQ {
			not = "~"
		}

		вернуть строки.ф("$;$;($;, $;)", not, rt_equalStrings, си.выражение(x.X), си.выражение(x.Y))
	}

	если асд.тип-класса?(тек.Л.Т) {
		вернуть строки.ф("((void*)$; $; (void*)$;)", си.выражение(x.X), binaryOp(x.Op), си.выражение(x.Y))
	} иначе {
		вернуть строки.ф("($; $; $;)", си.выражение(x.X), binaryOp(x.Op), си.выражение(x.Y))
	}
}

фн (си: СиГен) проверка-типа(тек: асд.ПроверкаТипа): Строка {
	пусть tname = си.указание-типа(x.TargetTyp)

	вернуть строки.ф("$;($;, $;)",
		rt_isClassType,
		си.выражение(x.X),
		tname+nm_class_info_ptr_suffix)

}

//== selector

фн (си: СиГен) доступ(тек: асд.Доступ): Строка {
	если x.X = пусто {
		вернуть си.имя описания(тек.объект^.(асд.Описание))
	}

	пусть cl = асд.основа(тек.Л.Т).(асд.ТипКласс)
	вернуть строки.ф("($;)->$;.$;$;",
		си.выражение(x.X),
		nm_class_fields,
		pathToField(cl, x.имя),
		си.outName(x.имя))
}

фн pathToField(cl асд.ТипКласс, name Строка): Строка {
	пусть path = ""
	пока {
		если cl.BaseTyp = пусто {
			прервать
		}
		cl = асд.основа(cl.BaseTyp).(асд.ТипКласс)

		_, ok := cl.Members[name]
		если ~ok {
			прервать
		}
		path += nm_base_fields + "."
	}
	вернуть path
}

//== проверка на пусто

фн (си: СиГен) подтверждение-типа(тек: асд.ПодтверждениеТипа): Строка {
	вернуть строки.ф("($;)$;($;,$;)",
		си.указание-типа(x.Typ),
		rt_пустоcheck,
		си.выражение(x.X),
		genPos(x.поз))
}

//== индексация и композит массива

фн (си: СиГен) индексация или конструктор вектора(тек: асд.ИндексацияИлиКомпозит): Строка {

	если x.Index # пусто {

		выбор xt := асд.основа(тек.Л.Т).(type) {
		когда асд.ТипВектор:
			вернуть си.genVectorIndex(x.X, x.Index, "len")
		когда асд.ТипВариативный:
			вернуть си.genVariadicIndex(xt, x.X, x.Index)
		другое
			если xt = асд.ТСтрока8() {
				вернуть си.genVectorIndex(x.X, x.Index, "bytes")
			}
			авария("assert")
		}
	}

	вернуть си.genArrayComposite(x.Composite)
}

фн (си: СиГен) genVectorIndex(x, inx асд.Выражение, lenName Строка): Строка {
	пусть name Строка
	если id, ok := x.(асд.ОперандИдент); ok {
		name = си.идентификатор(id)
	} иначе {
		name = си.новое локальное имя("")

		си.к("$; $; = $;;",
			си.указание-типа(тек.Т),
			name,
			си.выражение(тек))
	}
	вернуть строки.ф("$;->body[$;($;, $;->$;,$;)]",
		name,
		rt_indexcheck,
		си.выражение(inx),
		name,
		lenName,
		genPos(inx.поз))

}

фн (си: СиГен) genVariadicIndex(vt асд.ТипВариативный, x, inx асд.Выражение): Строка {

	пусть vPar = си.выражение(тек)

	если асд.полиморфный тип?(vt.ElementTyp) {
		/ *
			вернуть строки.ф("(($;*)($; + sizeof(TInt64)))[$;($;, *(TInt64 *)$;) << 1]",
				имя встроенного-типа(асд.ТЦел64()),
				vPar,
				rt_indexcheck,
				си.выражение(inx),
				vPar)
		* /
		авария("assert")
	} иначе {

		вернуть строки.ф("(($;*)$;)[$;($;, $;$;, $;)]",
			си.указание-типа(vt.ElementTyp),
			vPar,
			rt_indexcheck,
			си.выражение(inx),
			vPar,
			суффикс-длины-вариативного,
			genPos(inx.поз))
	}
}

//== конструктор вектора

фн (си: СиГен) genArrayComposite(тек: асд.ArrayCompositeExpr): Строка {
	пусть vt = асд.основа(x.Typ).(асд.ТипВектор)

	пусть name = си.новое локальное имя("")
	пусть lenExpr = си.genArrayCompositeLen(тек)

	// нужно ли проверять макс индекс на < длина?
	если длина(x.Indexes) > 0 & x.LenExpr # пусто {
		// c.Length = maxIndex + 1
		пусть lenName = си.новое локальное имя("len")
		си.к("$; $; = $;;", имя встроенного-типа(асд.ТЦел64()), lenName, lenExpr)
		lenExpr = lenName

		си.к("$;(%d, $;, $;);", rt_indexcheck, x.MaxIndex, lenName, genPos(x.поз))
	}

	пусть s = ""

	если x.Default # пусто {
		s = строки.ф("$; $; = $;(sizeof($;), $;, $;, $;);",
			си.указание-типа(x.Typ),
			name,
			rt_newVectorFill,
			си.указание-типа(vt.ElementTyp),
			lenExpr,
			си.genArrayCompositeCap(тек),
			си.genFiller(x.Default))
	} иначе {
		s = строки.ф("$; $; = $;(sizeof($;), $;, $;);",
			си.указание-типа(x.Typ),
			name,
			rt_newVector,
			си.указание-типа(vt.ElementTyp),
			lenExpr,
			си.genArrayCompositeCap(тек))
	}

	пусть list = make([]Строка, длина(x.Values))
	пока i, val := range x.Values {
		пусть inx Строка
		если длина(x.Indexes) = 0 {
			inx = строки.ф("%d", i)
		} иначе {
			inx = си.выражение(x.Indexes[i])
		}
		list[i] = строки.ф("$;->body[$;] = $;;", name, inx, си.выражение(val))
	}
	s += Строкаs.Join(list, " ")

	си.к("$;", s)

	вернуть name
}

фн (си: СиГен) genArrayCompositeLen(тек: асд.ArrayCompositeExpr): Строка {
	// если длина задана явно и это константое выражение
	если x.Length >= 0 {
		вернуть строки.ф("%d", x.Length)
	}

	// если длина задана явно
	если x.LenExpr # пусто {
		вернуть си.выражение(x.LenExpr)
	}

	// если длина задана неявно по индексам
	если x.MaxIndex >= 0 {
		вернуть строки.ф("%d", x.MaxIndex+1)
	}

	// если последовательность значений (без индекса)
	вернуть строки.ф("%d", длина(x.Values))
}

фн (си: СиГен) genArrayCompositeCap(тек: асд.ArrayCompositeExpr): Строка {
	если x.CapExpr # пусто {
		вернуть си.выражение(x.CapExpr)
	}
	вернуть "0"
}

фн (си: СиГен) genFiller(тек: асд.Выражение): Строка {
	пусть expr = си.выражение(тек)

	вернуть си.genCastToWord64(expr, тек.Т)
}

//== конструктор класса

фн (си: СиГен) конструктор класса(тек: асд.КомпозитКласса): Строка {
	пусть name = си.новое локальное имя("")

	пусть tname = си.указание-типа(x.Typ)
	пусть s = строки.ф("$; $; = $;($;);",
		tname,
		name,
		rt_newObject,
		tname+nm_class_info_ptr_suffix)

	пусть cl = асд.основа(x.Typ).(асд.ТипКласс)

	пусть list = make([]Строка, длина(x.Values))
	пока i, v := range x.Values {
		пусть cast = си.конверсия при присваивании(v.Field.Typ, v.Value.GetType())
		list[i] = строки.ф("$;->$;.$;$; = $;$;;",
			name, nm_class_fields, pathToField(cl, v.имя), си.outName(v.имя),
			cast, си.выражение(v.Value))
	}
	s += Строкаs.Join(list, " ")

	си.к("$;", s)
	вернуть name
}
*/