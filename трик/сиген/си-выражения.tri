модуль сиген

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод"

импорт "трик/асд"
импорт "трик/лексер"

фн (си: СиГен) выражение(выр: асд.Выражение): Строка {
	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
		вернуть си.идентификатор(тек)
	когда асд.Литерал:
		вернуть си.литерал(тек)
	когда асд.УнарнаяОперация:
		вернуть строки.ф("$;($;)", унарная операция(тек.операция), си.выражение(тек.Л))
	когда асд.БинарнаяОперация:
		вернуть си.бинарное выражение(тек)
	когда асд.ПроверкаТипа:
		вернуть си.проверка-типа(тек)
	когда асд.Доступ:
		вернуть си.доступ(тек)
	когда асд.Вызов:
		вернуть си.вызов(тек)
	когда асд.Преобразовать:
		если тек.осторожное {
			вернуть си.осторожное преобразование(тек)
		} иначе {
			вернуть си.преобразование(тек)
		}
	когда асд.ПодтверждениеТипа:
		вернуть си.подтверждение-типа(тек)

	когда асд.ИндексацияИлиКонструктор:
		вернуть си.индексация или конструктор вектора(тек)

	когда асд.КонструкторКласса:
		вернуть си.конструктор класса(тек)

	другое
		авария(строки.ф("выражение: $тип;", выр))
	}
}

//==== идентификатор

фн (си: СиГен) идентификатор(тек: асд.ОперандИдент): Строка {

	пусть оп = тек.объект^(:асд.Описание)
	пусть рез = константа как литерал(оп)
	если рез # "" {
		вернуть рез
	}

	если выходной параметр?(оп) {
		вернуть строки.ф("(*$;)", си.имя описания(оп))
	}

	вернуть си.имя описания(оп)
}

фн константа как литерал(оп: асд.Описание): Строка {

	если ~ (оп типа асд.ОписаниеКонстанты) {
		вернуть ""
	}
	выбор пусть тек: тип оп(:асд.ОписаниеКонстанты).значение^ {
	когда асд.ЛогЛитерал:
		если тек.значение {
			вернуть "true"
		} иначе {
			вернуть "false"
		}
	когда асд.Литерал:
		если асд.тип-пусто?(тек.Т^) {
			вернуть "NULL"
		}
	}
	вернуть ""
}

фн выходной параметр?(оп: асд.Описание): Лог {
	надо оп типа асд.ОписаниеПеременной иначе 	вернуть ложь
	вернуть оп(:асд.ОписаниеПеременной).выходной-параметр
}

//== literals

фн (си: СиГен) литерал(лит: асд.Литерал): Строка {
	выбор лит.вид {
	когда асд.Лит-Цел:
		вернуть строки.ф("$цел;", лит.цел)
	когда асд.Лит-Слово:
		вернуть строки.ф("0x$ш;", лит.слово)
	когда асд.Лит-Вещ:
		вернуть лит.вещ
	когда асд.Лит-Символ:
		вернуть строки.ф("0x$ш;", лит.слово)
	когда асд.Лит-Строка:
		вернуть си.строковый литерал(лит)
	другое
		авария("ni")
	}
}

фн (си: СиГен) строковый литерал(лит: асд.Литерал): Строка {
	если длина(лит.стр^) = 0 {
		вернуть строки.ф("$;()", rt_emptyString)
	}

	пусть имя = си.новое локальное имя(префикс-строкового-литерала)
	си.глобал("static TString $; = NULL;", имя)

	пусть стр = приготовить строковый литерал(лит.стр^)

	// передаю -1 в число байтов, чтобы не учитывать Си эскейп последовательности
	вернуть строки.ф("$;(&$;, $;, $;, \"$;\")", rt_newLiteralString, имя, -1, длина(лит.стр^), стр)
}

фн приготовить строковый литерал(символы: Символы): Строка {
	пусть сб = строки.Сборщик{}
    
    цикл сим среди символы {
		выбор сим {
/* лексер не пропускает. добавить?       
		когда '\a':
			сб.добавить строку("\\a")
		когда '\b':
			сб.добавить строку("\\b")
		когда '\f':
			сб.добавить строку("\\f")
		когда '\v':
			сб.добавить строку("\\v")            
*/
		когда '\n':
			сб.добавить строку("\\n")
		когда '\r':
			сб.добавить строку("\\r")
		когда '\t':
			сб.добавить строку("\\t")
		когда '\\':
			сб.добавить строку("\\\\")
		когда '"':
			сб.добавить строку("\\\"")
		другое
			если юникод.управляющий символ?(сим) {
				авария("ni") // можно \0xddd
			}
			сб.добавить символ(сим)
		}
	}
	вернуть сб.строка()
}

//==== унарные операции

фн унарная операция(операция: лексер.Лексема): Строка {
	выбор операция {
	когда лексер.ВЫЧЕСТЬ:
		вернуть "-"
	когда лексер.НЕ:
		вернуть "!"
	когда лексер.БИТ-НЕ:
		вернуть "~"

	другое
		авария(строки.ф("ni унарная: $;", лексер.для показа(операция)))
	}
}

//== бинарные операции

фн бинарная операция(операция: лексер.Лексема): Строка {
	выбор операция {
	когда лексер.ИЛИ:
		вернуть "||"
	когда лексер.И:
		вернуть "&&"
	когда лексер.РАВНО:
		вернуть "=="
	когда лексер.НЕ-РАВНО:
		вернуть "!="
	когда лексер.МЕНЬШЕ:
		вернуть "<"
	когда лексер.МЕНЬШЕ-РАВНО:
		вернуть "<="
	когда лексер.БОЛЬШЕ:
		вернуть ">"
	когда лексер.БОЛЬШЕ-РАВНО:
		вернуть ">="
	когда лексер.СЛОЖИТЬ:
		вернуть "+"
	когда лексер.ВЫЧЕСТЬ:
		вернуть "-"
	когда лексер.БИТ-ИЛИ:
		вернуть "|"
	когда лексер.УМНОЖИТЬ:
		вернуть "*"
	когда лексер.ДЕЛИТЬ:
		вернуть "/"
	когда лексер.ОСТАТОК:
		вернуть "%"
	когда лексер.БИТ-И:
		вернуть "&"
	когда лексер.БИТ-ИСК-ИЛИ:
		вернуть "^"
	когда лексер.СДВИГ-Л:
		вернуть "<<"
	когда лексер.СДВИГ-П:
		вернуть ">>"
	другое
		авария(строки.ф("ni бинарная: $;", лексер.для показа(операция)))
	}
}

фн (си: СиГен) бинарное выражение(тек: асд.БинарнаяОперация): Строка {

    пусть т = тек.Л.Т^
	если асд.строка?(т) {
		пусть не := ""
		если тек.операция =лексер.НЕ-РАВНО {
			не := "!"
		}

		вернуть строки.ф("$;$;($;, $;)", не, rt_equalStrings, си.выражение(тек.Л), си.выражение(тек.П))
	}

	если асд.тип-класса?(тек.Л.Т^) {
		вернуть строки.ф("((void*)$; $; (void*)$;)", си.выражение(тек.Л), бинарная операция(тек.операция), си.выражение(тек.П))
	} иначе {
		вернуть строки.ф("($; $; $;)", си.выражение(тек.Л), бинарная операция(тек.операция), си.выражение(тек.П))
	}
}

фн (си: СиГен) проверка-типа(тек: асд.ПроверкаТипа): Строка {
	пусть имя-типа = си.указание-типа(тек.цель)

	вернуть строки.ф("$;($;, $;$;)",
		rt_isClassType,
		си.выражение(тек.Л),
		имя-типа,
        суффикс-адрес-дескриптора)

}

//== selector

фн (си: СиГен) доступ(тек: асд.Доступ): Строка {
	если тек.Л = пусто {
		вернуть си.имя описания(тек.объект^(:асд.Описание))
	}

	пусть тк = асд.основа(тек.Л^.Т^)^(:асд.ТипКласс)
    
	вернуть строки.ф("($;)->$;.$;$;",
		си.выражение(тек.Л^),
		имя-поля-класса,
		путь к полю(тк, тек.имя),
		перевести имя(тек.имя))
}

фн путь к полю(тк: асд.ТипКласс, имя-поля: Строка): Строка {
	пусть путь := ""
	пока истина {
		если тк.Т-базовый = пусто {
			прервать
		}
		тк := асд.основа(тк.Т-базовый)^(:асд.ТипКласс)

        пусть эл = тк.атрибуты.найти(имя-поля)
		если эл = пусто  {
			прервать
		}
		путь := строки.собрать(путь, имя-поля-базового-класса, ".")
	}
	вернуть путь
}

//== проверка на не пусто

фн (си: СиГен) подтверждение-типа(тек: асд.ПодтверждениеТипа): Строка {
	вернуть строки.ф("($;)$;($;,$;)",
		си.указание-типа(тек.Т^),
		rt_nilcheck,
		си.выражение(тек.Л),
		позиция в строку(тек.поз))
}

//== индексация и композит массива

фн (си: СиГен) индексация или конструктор вектора(тек: асд.ИндексацияИлиКонструктор): Строка {

	если тек.индекс # пусто {
        пусть индекс = тек.индекс^
        пусть т = асд.основа(тек.Л.Т^)^

		выбор пусть тт: тип т {
		когда асд.ТипВектор:
			вернуть си.индексация вектора(тек.Л, индекс, "len")
		когда асд.ТипВариативный:
			вернуть си.индексация вариативного(тт, тек.Л, индекс)
		другое
			если асд.строка8?(т) {
				вернуть си.индексация вектора(тек.Л, индекс, "bytes")
			}
		}
		авария("assert")
	}

	вернуть си.конструктор вектора(тек.композит)
}

фн (си: СиГен) индексация вектора(левое: асд.Выражение, индекс: асд.Выражение, имя-длины: Строка): Строка {

	пусть лок := ""
	если левое типа асд.ОперандИдент {
		лок := си.идентификатор(левое(:асд.ОперандИдент))
	} иначе {
		лок := си.новое локальное имя("")

		си.к("$; $; = $;;",
			си.указание-типа(левое.Т^),
			лок,
			си.выражение(левое))
	}
	вернуть строки.ф("$;->body[$;($;, $;->$;,$;)]",
		лок,
		rt_indexcheck,
		си.выражение(индекс),
		лок,
		имя-длины,
		позиция в строку(индекс.поз))
}

фн (си: СиГен) индексация вариативного(вар-Т: асд.ТипВариативный, левое: асд.Выражение, индекс: асд.Выражение): Строка {

	пусть си-левое = си.выражение(левое)

	если асд.полиморфный тип?(вар-Т.Т-элемента) {
		/* переделать!
			вернуть строки.ф("(($;*)($; + sizeof(TInt64)))[$;($;, *(TInt64 *)$;) << 1]",
				имя встроенного-типа(асд.ТЦел64()),
				си-левое,
				rt_indexcheck,
				си.выражение(индекс),
				си-левое)
		*/
		авария("assert")
	} иначе {

		вернуть строки.ф("(($;*)$;)[$;($;, $;$;, $;)]",
			си.указание-типа(вар-Т.Т-элемента),
			си-левое,
			rt_indexcheck,
			си.выражение(индекс),
			си-левое,
			суффикс-длины-вариативного,
			позиция в строку(индекс.поз))
	}
}

//== конструктор вектора

фн (си: СиГен) конструктор вектора(тек: асд.КонструкторВектора): Строка {

	пусть тв = асд.основа(тек.Т)^(:асд.ТипВектор)

	пусть лок = си.новое локальное имя("")
	пусть си-длина := си.длина вектора(тек)

	// нужно ли проверять макс индекс на < длина?
	если длина(тек.индексы) > 0 & тек.размер # пусто {
		пусть лок-длина = си.новое локальное имя("len")
		си.к("$; $; = $;;", имя встроенного-типа(асд.ТЦел64()), лок-длина, си-длина)
		си-длина := лок-длина // сохранили и дальше используем локал

		си.к("$;($;, $;, $;);", rt_indexcheck, тек.макс-индекс, лок-длина, позиция в строку(тек.поз))
	}

	пусть создать-вектор := ""

	если тек.умолчание # пусто {
		создать-вектор := строки.ф("$; $; = $;(sizeof($;), $;, $;, $;);",
			си.указание-типа(тек.Т^),
			лок,
			rt_newVectorFill,
			си.указание-типа(тв.Т-элемента),
			си-длина,
			си.резерв вектора(тек),
            си.привести к слово64(си.выражение(тек.умолчание^), тек.умолчание^.Т^)
        )
	} иначе {
		создать-вектор := строки.ф("$; $; = $;(sizeof($;), $;, $;);",
			си.указание-типа(тек.Т^),
			лок,
			rt_newVector,
			си.указание-типа(тв.Т-элемента),
			си-длина,
			си.резерв вектора(тек)
        )
	}

	пусть список = Строки[выделить: длина(тек.значения)]
    цикл [№]значение среди тек.значения {
		пусть инд := ""
		если длина(тек.индексы) = 0 {
			инд := строки.ф("$;", №)
		} иначе {
			инд := си.выражение(тек.индексы[№])
		}
		список.добавить(строки.ф("$;->body[$;] = $;;", лок, инд, си.выражение(значение)))
	}

	си.к("$;$;", создать-вектор, строки.соединить(" ", список...))

	вернуть лок
}

фн (си: СиГен) длина вектора(тек: асд.КонструкторВектора): Строка {
	// если длина задана явно и это константное выражение
	если тек.число-элементов >= 0 {
		вернуть строки.ф("$;", тек.число-элементов)
	}

	// если длина задана явно
	если тек.размер # пусто {
		вернуть си.выражение(тек.размер^)
	}

	// если длина задана неявно по индексам
	если тек.макс-индекс >= 0 {
		вернуть строки.ф("$;", тек.макс-индекс + 1)
	}

	// если последовательность значений (без индекса)
	вернуть строки.ф("$;", длина(тек.значения))
}

фн (си: СиГен) резерв вектора(тек: асд.КонструкторВектора): Строка {
	если тек.резерв # пусто {
		вернуть си.выражение(тек.резерв^)
	}
	вернуть "0"
}

//== конструктор класса

фн (си: СиГен) конструктор класса(тек: асд.КонструкторКласса): Строка {

	пусть лок = си.новое локальное имя("")

	пусть имя-типа = си.указание-типа(тек.Т^)
	пусть создать = строки.ф("$; $; = $;($;$;);",
		имя-типа,
		лок,
		rt_newObject,
		имя-типа, 
        суффикс-адрес-дескриптора)

	пусть тк = асд.основа(тек.Т)^(:асд.ТипКласс)

	пусть список = Строки[выделить: длина(тек.значения)]
	цикл пара среди тек.значения {
		пусть конверсия = си.конверсия при присваивании(пара.поле^.Т^, пара.В.Т^)
		список.добавить(строки.ф("$;->$;.$;$; = $;$;;",
			лок, имя-поля-класса, путь к полю(тк, пара.имя-поля), перевести имя(пара.имя-поля),
			конверсия, си.выражение(пара.В))
        )
	}

	си.к("$;$;", создать, строки.соединить(" ", список...))
    
	вернуть лок 
}
