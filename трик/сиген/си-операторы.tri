модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"
//импорт "трик/лексер"

/*
фн (си: СиГен) список операторов(seq асд.СписокОператоров) {

	пока _, s := range seq.Statements {
		си.оператор(s)
	}
}

фн (си: СиГен) оператор(s асд.Оператор) {
	выбор x := s.(type) {
	когда асд.ОператорОписание:
		s := си.локальное описание(x.D)
		си.к("%s", s)
	когда асд.ОператорВыражение:
		s := си.выражение(x.X)
		си.к("%s;", s)
	когда асд.ОператорПрисвоить:
		l := си.выражение(x.L)
		r := си.выражение(x.R)

		пусть cast = си.конверсия при присваивании(x.L.GetType(), x.R.GetType())
		си.к("%s = %s%s;", l, cast, r)
	когда асд.ОператорУвеличить:
		l := си.выражение(x.L)
		си.к("%s++;", l)
	когда асд.ОператорУменьшить:
		l := си.выражение(x.L)
		си.к("%s--;", l)
	когда асд.ОператорЕсли:
		си.genIf(x, "")
	когда асд.ОператорПока:
		си.оператор-пока(тек)
	когда асд.ОператорЦикл:
		си.оператор-цикл(тек)
	когда асд.ОператорНадо:
		си.оператор-надо(тек)
	когда асд.ОператорВыбор:
		если можно ли использовать switch(тек) {
			си.оператор выбора через switch(тек)
		} иначе если x.X = пусто {
			си.оператор выбора по предикатам(тек)
		} иначе {
			си.генерация выбора через if(тек)
		}
	когда асд.ОператорВыборПоТипу:
		си.оператор выбора по типу(тек)
	когда асд.ОператорВернуть:
		если x.X # пусто {
			пусть cast = си.конверсия при присваивании(x.Т-вернуть, тек.Л.Т)
			си.к("вернуть %s%s;", cast, си.выражение(x.X))
		} иначе {
			си.к("вернуть;")
		}
	когда асд.ОператорПрервать:
		си.к("прервать;")
	когда асд.ОператорАвария:
		си.оператор-авария(тек)

	другое
		panic(строки.ф("gen statement: ni %T", s))
	}
}

фн (си: СиГен) конверсия при присваивании(lt, rt асд.Тип) Строка {

	если асд.основа(lt) # асд.основа(rt) {
		вернуть "(" + си.указание-типа(lt) + ")"
	}
	вернуть ""
}

фн (си: СиГен) genIf(x асд.ОператорЕсли, prefix Строка) {
	си.к("%sесли (%s) {", prefix, removeExtraPars(си.выражение(x.Cond)))
	си.список операторов(x.если-да)
	си.к("}")
	если x.если-нет # пусто {

		elsif, ok := x.если-нет.(асд.ОператорЕсли)
		если ok {
			си.genIf(elsif, "иначе ")
		} иначе {
			си.к("иначе {")
			си.список операторов(x.если-нет.(асд.СписокОператоров))
			си.к("}")
		}
	}
}

фн removeExtraPars(s Строка) Строка {
	если длина(s) = 0 {
		вернуть s
	}
	если s[0] = '(' & s[len(s)-1] = ')' {
		вернуть s[1 : длина(s)-1]
	}
	вернуть s
}

фн (си: СиГен) оператор-пока(x асд.ОператорПока) {
	си.к("while (%s) {", removeExtraPars(си.выражение(x.Cond)))
	си.список операторов(x.Seq)
	си.к("}")
}

фн (си: СиГен) оператор-цикл(x асд.ОператорЦикл) {

	пусть index = ""
	если x.IndexVar # пусто {
		index = си.имя описания(x.IndexVar)
	} иначе {
		index = си.localName("i")
	}

	если асд.вариативный тип?(x.Expr.GetType()) {
		// нельзя использовать временную переменную
		panic("не реализовано для вариативных")
	}

	пусть loc = си.localName("")
	си.к("%s %s = %s;", си.указание-типа(x.Expr.GetType()), loc, си.выражение(x.Expr))

	си.к("пока (%s %s = 0;%s < %s;%s++) {",
		predefinedTypeName(асд.ТЦел64().Name),
		index,
		index,
		си.genLen(loc, x.Expr.GetType()),
		index)

	если x.ElementVar # пусто {
		си.к("%s %s = %s;",
			си.указание-типа(x.ElementVar.Typ),
			си.имя описания(x.ElementVar),
			си.genForElementSet(x.Expr.GetType(), loc, index))
	}
	си.список операторов(x.Seq)
	си.к("}")
}

фн (си: СиГен) genForElementSet(arrayType асд.Тип, array Строка, index Строка) Строка {
	выбор xt := асд.основа(arrayType).(type) {
	когда асд.ТипВектор:
		вернуть строки.ф("%s->body[%s]", array, index)
	когда асд.ТипВариативный:
		panic("ni")
	другое
		если xt = асд.ТСтрока8() {
			вернуть строки.ф("%s->body[%s]", array, index)
		}
		panic("assert")
	}

}

фн (си: СиГен) оператор-надо(x асд.ОператорНадо) {
	си.к("если (~(%s)) {", removeExtraPars(си.выражение(x.Cond)))
	seq, ok := x.если-нет.(асд.СписокОператоров)
	если ok {
		си.список операторов(seq)
	} иначе {
		си.оператор(x.если-нет)
	}
	си.к("}")
}

фн (си: СиГен) оператор-авария(x асд.ОператорАвария) {

	пусть expr Строка
	пусть li = literal(x.X)
	если li # пусто {
		expr = "\"" + encodeLiteralString(li.StrVal) + "\""
	} иначе {
		expr = си.выражение(x.X) + "->body"
	}

	си.к("%s((char *)%s,%s);", rt_crash, expr, genPos(x.поз))
}

фн genPos(pos int) Строка {
	src, line, col := env.SourcePos(pos)
	вернуть строки.ф("\"%s/%s:%d:%d\"", src.OriginPath, src.FileName, line, col)
}

фн literal(expr асд.Выражение) асд.Литерал {

	выбор x := expr.(type) {
	когда асд.Литерал:
		вернуть x
	когда асд.Преобразовать:
		если x.Done {
			вернуть literal(x.X)
		}
	}
	вернуть пусто
}

//== оператор выбор

фн можно ли использовать switch(x асд.ОператорВыбор) Лог {

	если x.X = пусто {
		вернуть ложь
	}

	пусть t = асд.основа(тек.Л.Т)
	выбор t {
	когда асд.ТБайт(), асд.ТЦел64(), асд.ТСлово64(), асд.ТСимвол():
	другое
		вернуть ложь
	}

	пока _, c := range x.Cases {
		пока _, e := range c.Exprs {
			если _, ok := e.(асд.Литерал); ~ok {
				вернуть ложь
			}
		}
	}
	вернуть истина
}

фн (си: СиГен) оператор выбора через switch(x асд.ОператорВыбор) {
	си.к("выбор (%s) {", си.выражение(x.X))

	пока _, c := range x.Cases {
		пока _, e := range c.Exprs {
			си.к("когда %s: ", си.выражение(e))
		}
		си.к("{") // пока clang 15.0.7 on linux
		си.список операторов(c.Seq)
		си.к("}")
		си.к("прервать;")
	}

	если x.если-нет # пусто {
		си.к("другое")
		си.список операторов(x.если-нет)
	}

	си.к("}")
}

фн (си: СиГен) генерация выбора через if(x асд.ОператорВыбор) {

	пусть strCompare = асд.строка?(тек.Л.Т)

	пусть loc = си.localName("")
	си.к("%s %s = %s;", си.указание-типа(тек.Л.Т), loc, си.выражение(x.X))

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			если strCompare {
				conds = append(conds, строки.ф("%s(%s, %s)", rt_equalStrings, loc, си.выражение(e)))
			} иначе {
				conds = append(conds, строки.ф("%s = %s", loc, си.выражение(e)))
			}
		}
		си.к("%sесли (%s) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}
}

фн (си: СиГен) оператор выбора по предикатам(x асд.ОператорВыбор) {

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			conds = append(conds, removeExtraPars(си.выражение(e)))
		}
		си.к("%sесли (%s) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}
}

//== оператор выбора по типу

// if
фн (си: СиГен) оператор выбора по типу(x асд.ОператорВыборПоТипу) {

	пусть loc = си.localName("")
	си.к("%s %s = %s;", си.указание-типа(тек.Л.Т), loc, си.выражение(x.X))

	пусть tag = си.localName("tag")
	си.к("void* %s = %s->%s;", tag, loc, nm_VT_field)

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, t := range c.Types {
			пусть tname = си.указание-типа(t)
			conds = append(conds, строки.ф("%s = %s", tag, tname+nm_class_info_ptr_suffix))
		}
		си.к("%sесли (%s) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "

		если c.Var # пусто {
			пусть v = c.Var

			си.к("%s %s = %s%s;",
				си.указание-типа(v.Typ),
				си.имя описания(v),
				си.конверсия при присваивании(v.Typ, тек.Л.Т),
				loc)
		}
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}

}
*/