модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"

фн (си: СиГен) список операторов(блок: асд.СписокОператоров) {
	цикл оп среди блок.операторы {
		си.оператор(оп)
	}
}

фн (си: СиГен) оператор(оп: асд.Оператор) {

	выбор пусть тек: тип оп {
	когда асд.ОператорОписание:
		си.к("$;", си.локальное описание(тек.описание))
	когда асд.ОператорВыражение:
		си.к("$;;", си.выражение(тек.выражение))
	когда асд.ОператорПрисвоить:
		пусть л = си.выражение(тек.Л)
		пусть п = си.выражение(тек.П)
		пусть конверсия = си.конверсия при присваивании(тек.Л.Т^, тек.П.Т^)
		си.к("$; = $;$;;", л, конверсия, п)
	когда асд.ОператорУвеличить:
		си.к("$;++;", си.выражение(тек.Л))
	когда асд.ОператорУменьшить:
		си.к("$;--;", си.выражение(тек.Л))
	когда асд.ОператорЕсли:
		си.оператор-если(тек, "")
	когда асд.ОператорПока:
		си.оператор-пока(тек)
	когда асд.ОператорЦикл:
		си.оператор-цикл(тек)
	когда асд.ОператорНадо:
		си.оператор-надо(тек)
	когда асд.ОператорВыбор:
		если можно ли использовать switch?(тек) {
			си.оператор выбора через switch(тек)
		} иначе если тек.В = пусто {
			си.оператор выбора по предикатам(тек)
		} иначе {
			си.генерация выбора через if(тек)
		}
	когда асд.ОператорВыборПоТипу:
		си.оператор выбора по типу(тек)
	когда асд.ОператорВернуть:
		если тек.В # пусто {
			пусть конверсия = си.конверсия при присваивании(тек.Т-вернуть^, тек.В^.Т^)
			си.к("вернуть $;$;;", конверсия, си.выражение(тек.В^))
		} иначе {
			си.к("вернуть;")
		}
	когда асд.ОператорПрервать:
		си.к("прервать;")
	когда асд.ОператорАвария:
		си.оператор-авария(тек)

	другое
		авария(строки.ф("необработанный оператор: $тип;", оп))
	}
}

фн (си: СиГен) конверсия при присваивании(лт: асд.Тип, пт: асд.Тип): Строка {

	если асд.основа(лт) # асд.основа(пт) {
		вернуть строки.ф("($;)", си.указание-типа(лт))
	}
	вернуть ""
}


фн (си: СиГен) оператор-если(тек: асд.ОператорЕсли, префикс: Строка) {

	си.к("$;если ($;) {", префикс, убрать лишние скобки(си.выражение(тек.условие)))
	си.список операторов(тек.если-да)
	си.к("}")
	если тек.если-нет # пусто {
		если тек.если-нет типа асд.ОператорЕсли {
			си.оператор-если(тек.если-нет^(:асд.ОператорЕсли), "иначе ")
		} иначе {
			си.к("иначе {")
			си.список операторов(тек.если-нет^(:асд.СписокОператоров))
			си.к("}")
		}
	}
}

фн убрать лишние скобки(с: Строка): Строка {
	если длина(с) = 0 {
		вернуть с
	}
    пусть с8 = с(:Строка8)
    
	если с8[0] = '('(:Байт) & с8[длина(с8)-1] = ')'(:Байт) {
		вернуть строки.извлечь(с, 1, длина(с8)-2)
	}
	вернуть с
}

фн (си: СиГен) оператор-надо(тек: асд.ОператорНадо) {
	си.к("если (~($;)) {", убрать лишние скобки(си.выражение(тек.условие)))
	если тек.если-нет типа асд.СписокОператоров {
		си.список операторов(тек.если-нет(:асд.СписокОператоров))
	} иначе {
		си.оператор(тек.если-нет)
	}
	си.к("}")
}

//==== циклы

фн (си: СиГен) оператор-пока(тек: асд.ОператорПока) {
	си.к("while ($;) {", убрать лишние скобки(си.выражение(тек.условие)))
	си.список операторов(тек.тело)
	си.к("}")
}

фн (си: СиГен) оператор-цикл(тек: асд.ОператорЦикл) {

	пусть индекс := ""
	если тек.индекс # пусто {
		индекс := си.имя описания(тек.индекс^)
	} иначе {
		индекс := си.новое локальное имя("i")
	}

    пусть т = тек.В.Т^

	если асд.вариативный тип?(т) {
		// нельзя использовать временную переменную
		авария("не реализовано для вариативных")
	}

	пусть лок = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(т), лок, си.выражение(тек.В))

	си.к("пока ($; $; = 0;$; < $;;$;++) {",
		имя встроенного-типа(асд.ТЦел64()),
		индекс,
		индекс,
		си.взять длину(лок, т),
		индекс)

	если тек.элемент # пусто {
		си.к("$; $; = $;;",
			си.указание-типа(тек.элемент^.Т^),
			си.имя описания(тек.элемент^),
			си.значение элемента цикла(т, лок, индекс))
	}
	си.список операторов(тек.тело)
	си.к("}")
}

фн (си: СиГен) значение элемента цикла(т: асд.Тип, лок: Строка, индекс: Строка): Строка {
	выбор пусть тек: тип асд.основа(т)^ {
	когда асд.ТипВектор:
		вернуть строки.ф("$;->body[$;]", лок, индекс)
	когда асд.ТипВариативный:
		авария("ni")
	другое
		если асд.строка8?(т) {
			вернуть строки.ф("$;->body[$;]", лок, индекс)
		}
		авария("assert")
	}
}

фн (си: СиГен) оператор-авария(тек: асд.ОператорАвария) {

	пусть арг := ""
	пусть лит? = взять литерал(тек.В)
	если лит? # пусто {
		арг := строки.ф("\"$;\"", приготовить строковый литерал(лит?^.стр^))
	} иначе {
		арг := строки.ф("$;->body", си.выражение(тек.В))
	}

	си.к("$;((char *)$;,$;);", rt_crash, арг, позиция в строку(тек.поз))
}

фн взять литерал(выр: асд.Выражение): мб асд.Литерал {

	выбор пусть тек: тип выр {
	когда асд.Литерал:
		вернуть тек
	когда асд.Преобразовать:
		если тек.сделано {
			вернуть взять литерал(тек.Л)
		}
	}
	вернуть пусто
}

//== оператор выбора

фн можно ли использовать switch?(тек: асд.ОператорВыбор): Лог {

	если тек.В = пусто {
		вернуть ложь
	}

	пусть т = асд.основа(тек.В^.Т^)^
    надо асд.байт?(т) | асд.цел64?(т) | асд.слово64?(т) | асд.символ?(т) иначе вернуть ложь

    цикл вариант среди тек.варианты {
        цикл метка среди вариант.выражения {
            // TODO: константное выражение
            надо метка типа асд.Литерал иначе вернуть ложь
		}
	}
	вернуть истина
}

фн (си: СиГен) оператор выбора через switch(тек: асд.ОператорВыбор) {

	си.к("switch ($;) {", си.выражение(тек.В^))

    цикл вариант среди тек.варианты {
        цикл метка среди вариант.выражения {
			си.к("case $;: ", си.выражение(метка))
		}
		си.к("{") // пока clang 15.0.7 on linux
		си.список операторов(вариант.тело)
		си.к("}")
		си.к("прервать;")
	}

	если тек.если-нет # пусто {
		си.к("default:")
		си.список операторов(тек.если-нет^)
	}

	си.к("}")
}

фн (си: СиГен) генерация выбора через if(тек: асд.ОператорВыбор) {

	пусть сравнение-строк = асд.строка?(тек.В^.Т^)

	пусть лок = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.В^.Т^), лок, си.выражение(тек.В^))

	пусть начало := ""
    цикл вариант среди тек.варианты {

		пусть условия = Строки[]
		цикл метка среди вариант.выражения {
			если сравнение-строк {
				условия.добавить(строки.ф("$;($;, $;)", rt_equalStrings, лок, си.выражение(метка)))
			} иначе {
				условия.добавить(строки.ф("$; = $;", лок, си.выражение(метка)))
			}
		}
		си.к("$;если ($;) {", начало, строки.соединить(" | ", условия...))
		начало := "else "
		си.список операторов(вариант.тело)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет^)
		си.к("}")
	}
}

фн (си: СиГен) оператор выбора по предикатам(тек: асд.ОператорВыбор) {

	пусть начало := ""
    цикл вариант среди тек.варианты {

		пусть условия = Строки[]
		цикл метка среди вариант.выражения {
			условия.добавить(убрать лишние скобки(си.выражение(метка)))
		}
		си.к("$;если ($;) {", начало, строки.соединить(" | ", условия...))
		начало := "иначе "
		си.список операторов(вариант.тело)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет^)
		си.к("}")
	}
}

//== оператор выбора по типу

фн (си: СиГен) оператор выбора по типу(тек: асд.ОператорВыборПоТипу) {

	пусть лок = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.В.Т^), лок, си.выражение(тек.В))

	пусть тег = си.новое локальное имя("tag")
	си.к("void* $; = $;->$;;", тег, лок, имя-поля-ВТ)

	пусть начало := ""
    цикл вариант среди тек.варианты {

		пусть условия = Строки[]
		цикл т среди вариант.типы {
			пусть имя-типа = си.указание-типа(т)
			условия.добавить(строки.ф("$; = $;$;", тег, имя-типа, суффикс-адрес-дескриптора))
		}
		си.к("$;если ($;) {", начало, строки.соединить(" | ", условия...))
		начало := "иначе "

		если вариант.переменная # пусто {
			пусть пер = вариант.переменная^

			си.к("$; $; = $;$;;",
				си.указание-типа(пер.Т^),
				си.имя описания(пер),
				си.конверсия при присваивании(пер.Т^, тек.В.Т^),
				лок)
		}
		си.список операторов(вариант.тело)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет^)
		си.к("}")
	}
}
