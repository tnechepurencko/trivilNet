модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
//импорт "трик/основа"

фн (си: СиГен) список операторов(блок: асд.СписокОператоров) {
	цикл оп среди блок.операторы {
		си.оператор(оп)
	}
}

фн (си: СиГен) оператор(оп: асд.Оператор) {
/*
	выбор x := s.(type) {
	когда асд.ОператорОписание:
		s := си.локальное описание(x.D)
		си.к("$;", s)
	когда асд.ОператорВыражение:
		s := си.выражение(x.X)
		си.к("$;;", s)
	когда асд.ОператорПрисвоить:
		l := си.выражение(x.L)
		r := си.выражение(x.R)

		пусть cast = си.конверсия при присваивании(x.L.GetType(), x.R.GetType())
		си.к("$; = $;$;;", l, cast, r)
	когда асд.ОператорУвеличить:
		l := си.выражение(x.L)
		си.к("$;++;", l)
	когда асд.ОператорУменьшить:
		l := си.выражение(x.L)
		си.к("$;--;", l)
	когда асд.ОператорЕсли:
		си.genIf(x, "")
	когда асд.ОператорПока:
		си.оператор-пока(тек)
	когда асд.ОператорЦикл:
		си.оператор-цикл(тек)
	когда асд.ОператорНадо:
		си.оператор-надо(тек)
	когда асд.ОператорВыбор:
		если можно ли использовать switch(тек) {
			си.оператор выбора через switch(тек)
		} иначе если x.X = пусто {
			си.оператор выбора по предикатам(тек)
		} иначе {
			си.генерация выбора через if(тек)
		}
	когда асд.ОператорВыборПоТипу:
		си.оператор выбора по типу(тек)
	когда асд.ОператорВернуть:
		если x.X # пусто {
			пусть cast = си.конверсия при присваивании(x.Т-вернуть, тек.Л.Т)
			си.к("вернуть $;$;;", cast, си.выражение(x.X))
		} иначе {
			си.к("вернуть;")
		}
	когда асд.ОператорПрервать:
		си.к("прервать;")
	когда асд.ОператорАвария:
		си.оператор-авария(тек)

	другое
		авария(строки.ф("gen statement: ni $тип;", s))
	}
*/    
}

фн (си: СиГен) конверсия при присваивании(лт: асд.Тип, пт: асд.Тип): Строка {

	если асд.основа(лт) # асд.основа(пт) {
		вернуть строки.ф("($;)", си.указание-типа(лт))
	}
	вернуть ""
}

/*
фн (си: СиГен) genIf(тек: асд.ОператорЕсли, prefix Строка) {
	си.к("$;если ($;) {", prefix, removeExtraPars(си.выражение(x.Cond)))
	си.список операторов(x.если-да)
	си.к("}")
	если x.если-нет # пусто {

		elsif, ok := x.если-нет.(асд.ОператорЕсли)
		если ok {
			си.genIf(elsif, "иначе ")
		} иначе {
			си.к("иначе {")
			си.список операторов(x.если-нет.(асд.СписокОператоров))
			си.к("}")
		}
	}
}

фн removeExtraPars(s Строка): Строка {
	если длина(s) = 0 {
		вернуть s
	}
	если s[0] = '(' & s[len(s)-1] = ')' {
		вернуть s[1 : длина(s)-1]
	}
	вернуть s
}

фн (си: СиГен) оператор-пока(тек: асд.ОператорПока) {
	си.к("while ($;) {", removeExtraPars(си.выражение(x.Cond)))
	си.список операторов(x.Seq)
	си.к("}")
}

фн (си: СиГен) оператор-цикл(тек: асд.ОператорЦикл) {

	пусть index = ""
	если x.IndexVar # пусто {
		index = си.имя описания(x.IndexVar)
	} иначе {
		index = си.новое локальное имя("i")
	}

	если асд.вариативный тип?(x.Expr.GetType()) {
		// нельзя использовать временную переменную
		авария("не реализовано для вариативных")
	}

	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(x.Expr.GetType()), loc, си.выражение(x.Expr))

	си.к("пока ($; $; = 0;$; < $;;$;++) {",
		имя встроенного-типа(асд.ТЦел64()),
		index,
		index,
		си.genLen(loc, x.Expr.GetType()),
		index)

	если x.ElementVar # пусто {
		си.к("$; $; = $;;",
			си.указание-типа(x.ElementVar.Typ),
			си.имя описания(x.ElementVar),
			си.genForElementSet(x.Expr.GetType(), loc, index))
	}
	си.список операторов(x.Seq)
	си.к("}")
}

фн (си: СиГен) genForElementSet(arrayType асд.Тип, array Строка, index Строка): Строка {
	выбор xt := асд.основа(arrayType).(type) {
	когда асд.ТипВектор:
		вернуть строки.ф("$;->body[$;]", array, index)
	когда асд.ТипВариативный:
		авария("ni")
	другое
		если xt = асд.ТСтрока8() {
			вернуть строки.ф("$;->body[$;]", array, index)
		}
		авария("assert")
	}

}

фн (си: СиГен) оператор-надо(тек: асд.ОператорНадо) {
	си.к("если (~($;)) {", removeExtraPars(си.выражение(x.Cond)))
	seq, ok := x.если-нет.(асд.СписокОператоров)
	если ok {
		си.список операторов(seq)
	} иначе {
		си.оператор(x.если-нет)
	}
	си.к("}")
}

фн (си: СиГен) оператор-авария(тек: асд.ОператорАвария) {

	пусть expr Строка
	пусть li = literal(x.X)
	если li # пусто {
		expr = "\"" + encodeLiteralString(li.StrVal) + "\""
	} иначе {
		expr = си.выражение(x.X) + "->body"
	}

	си.к("$;((char *)$;,$;);", rt_crash, expr, позиция в строку(x.поз))
}

фн literal(expr асд.Выражение) асд.Литерал {

	выбор x := expr.(type) {
	когда асд.Литерал:
		вернуть x
	когда асд.Преобразовать:
		если x.Done {
			вернуть literal(x.X)
		}
	}
	вернуть пусто
}

//== оператор выбор

фн можно ли использовать switch(тек: асд.ОператорВыбор) Лог {

	если x.X = пусто {
		вернуть ложь
	}

	пусть t = асд.основа(тек.Л.Т)
	выбор t {
	когда асд.ТБайт(), асд.ТЦел64(), асд.ТСлово64(), асд.ТСимвол():
	другое
		вернуть ложь
	}

	пока _, c := range x.Cases {
		пока _, e := range c.Exprs {
			если _, ok := e.(асд.Литерал); ~ok {
				вернуть ложь
			}
		}
	}
	вернуть истина
}

фн (си: СиГен) оператор выбора через switch(тек: асд.ОператорВыбор) {
	си.к("выбор ($;) {", си.выражение(x.X))

	пока _, c := range x.Cases {
		пока _, e := range c.Exprs {
			си.к("когда $;: ", си.выражение(e))
		}
		си.к("{") // пока clang 15.0.7 on linux
		си.список операторов(c.Seq)
		си.к("}")
		си.к("прервать;")
	}

	если x.если-нет # пусто {
		си.к("другое")
		си.список операторов(x.если-нет)
	}

	си.к("}")
}

фн (си: СиГен) генерация выбора через if(тек: асд.ОператорВыбор) {

	пусть strCompare = асд.строка?(тек.Л.Т)

	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.Л.Т), loc, си.выражение(x.X))

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			если strCompare {
				conds = append(conds, строки.ф("$;($;, $;)", rt_equalStrings, loc, си.выражение(e)))
			} иначе {
				conds = append(conds, строки.ф("$; = $;", loc, си.выражение(e)))
			}
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}
}

фн (си: СиГен) оператор выбора по предикатам(тек: асд.ОператорВыбор) {

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			conds = append(conds, removeExtraPars(си.выражение(e)))
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}
}

//== оператор выбора по типу

// if
фн (си: СиГен) оператор выбора по типу(тек: асд.ОператорВыборПоТипу) {

	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.Л.Т), loc, си.выражение(x.X))

	пусть tag = си.новое локальное имя("tag")
	си.к("void* $; = $;->$;;", tag, loc, имя-поля-ВТ)

	пусть els = ""
	пока _, c := range x.Cases {

		пусть conds = make([]Строка, 0)
		пока _, t := range c.Types {
			пусть tname = си.указание-типа(t)
			conds = append(conds, строки.ф("$; = $;", tag, tname+суффикс-адрес-дескриптора))
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "

		если c.Var # пусто {
			пусть v = c.Var

			си.к("$; $; = $;$;;",
				си.указание-типа(v.Typ),
				си.имя описания(v),
				си.конверсия при присваивании(v.Typ, тек.Л.Т),
				loc)
		}
		си.список операторов(c.Seq)
		си.к("}")
	}

	если x.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(x.если-нет)
		си.к("}")
	}

}
*/