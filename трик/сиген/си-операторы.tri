модуль сиген

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"

фн (си: СиГен) список операторов(блок: асд.СписокОператоров) {
	цикл оп среди блок.операторы {
		си.оператор(оп)
	}
}

фн (си: СиГен) оператор(оп: асд.Оператор) {

	выбор пусть тек: тип оп {
	когда асд.ОператорОписание:
		си.к("$;", си.локальное описание(тек.описание))
	когда асд.ОператорВыражение:
		си.к("$;;", си.выражение(тек.выражение))
	когда асд.ОператорПрисвоить:
		пусть л = си.выражение(тек.Л)
		пусть п = си.выражение(тек.П)
		пусть конверсия = си.конверсия при присваивании(тек.Л.Т^, тек.П.Т^)
		си.к("$; = $;$;;", л, конверсия, п)
	когда асд.ОператорУвеличить:
		си.к("$;++;", си.выражение(тек.Л))
	когда асд.ОператорУменьшить:
		си.к("$;--;", си.выражение(тек.Л))
	когда асд.ОператорЕсли:
		си.оператор-если(тек, "")
	когда асд.ОператорПока:
		си.оператор-пока(тек)
	когда асд.ОператорЦикл:
		си.оператор-цикл(тек)
	когда асд.ОператорНадо:
		си.оператор-надо(тек)
	когда асд.ОператорВыбор:
		если можно ли использовать switch(тек) {
			си.оператор выбора через switch(тек)
		} иначе если тек.В = пусто {
			си.оператор выбора по предикатам(тек)
		} иначе {
			си.генерация выбора через if(тек)
		}
	когда асд.ОператорВыборПоТипу:
		си.оператор выбора по типу(тек)
	когда асд.ОператорВернуть:
		если тек.В # пусто {
			пусть конверсия = си.конверсия при присваивании(тек.Т-вернуть^, тек.В^.Т^)
			си.к("вернуть $;$;;", конверсия, си.выражение(тек.В^))
		} иначе {
			си.к("вернуть;")
		}
	когда асд.ОператорПрервать:
		си.к("прервать;")
	когда асд.ОператорАвария:
		си.оператор-авария(тек)

	другое
		авария(строки.ф("необработанный оператор: $тип;", оп))
	}
}

фн (си: СиГен) конверсия при присваивании(лт: асд.Тип, пт: асд.Тип): Строка {

	если асд.основа(лт) # асд.основа(пт) {
		вернуть строки.ф("($;)", си.указание-типа(лт))
	}
	вернуть ""
}


фн (си: СиГен) оператор-если(тек: асд.ОператорЕсли, префикс: Строка) {

	си.к("$;если ($;) {", префикс, убрать лишние скобки(си.выражение(тек.условие)))
	си.список операторов(тек.если-да)
	си.к("}")
	если тек.если-нет # пусто {
		если тек.если-нет типа асд.ОператорЕсли {
			си.оператор-если(тек.если-нет^(:асд.ОператорЕсли), "иначе ")
		} иначе {
			си.к("иначе {")
			си.список операторов(тек.если-нет^(:асд.СписокОператоров))
			си.к("}")
		}
	}
}

фн убрать лишние скобки(с: Строка): Строка {
	если длина(с) = 0 {
		вернуть с
	}
    пусть с8 = с(:Строка8)
    
	если с8[0] = '('(:Байт) & с8[длина(с8)-1] = ')'(:Байт) {
		вернуть строки.извлечь(с, 1, длина(с8)-2)
	}
	вернуть с
}

фн (си: СиГен) оператор-пока(тек: асд.ОператорПока) {
	си.к("while ($;) {", убрать лишние скобки(си.выражение(тек.условие)))
	си.список операторов(тек.тело)
	си.к("}")
}

фн (си: СиГен) оператор-цикл(тек: асд.ОператорЦикл) {
/*
	пусть index = ""
	если тек.IndexVar # пусто {
		index = си.имя описания(тек.IndexVar)
	} иначе {
		index = си.новое локальное имя("i")
	}

	если асд.вариативный тип?(тек.Expr.Т) {
		// нельзя использовать временную переменную
		авария("не реализовано для вариативных")
	}

	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.Expr.Т), loc, си.выражение(тек.Expr))

	си.к("пока ($; $; = 0;$; < $;;$;++) {",
		имя встроенного-типа(асд.ТЦел64()),
		index,
		index,
		си.genLen(loc, тек.Expr.Т),
		index)

	если тек.ElementVar # пусто {
		си.к("$; $; = $;;",
			си.указание-типа(тек.ElementVar.Typ),
			си.имя описания(тек.ElementVar),
			си.genForElementSet(тек.Expr.Т, loc, index))
	}
	си.список операторов(тек.Seq)
	си.к("}")
*/    
}

/*
фн (си: СиГен) genForElementSet(arrayType асд.Тип, array Строка, index Строка): Строка {
	выбор xt := асд.основа(arrayType).(type) {
	когда асд.ТипВектор:
		вернуть строки.ф("$;->body[$;]", array, index)
	когда асд.ТипВариативный:
		авария("ni")
	другое
		если xt = асд.ТСтрока8() {
			вернуть строки.ф("$;->body[$;]", array, index)
		}
		авария("assert")
	}
}
*/

фн (си: СиГен) оператор-надо(тек: асд.ОператорНадо) {
	си.к("если (~($;)) {", убрать лишние скобки(си.выражение(тек.условие)))
	если тек.если-нет типа асд.СписокОператоров {
		си.список операторов(тек.если-нет(:асд.СписокОператоров))
	} иначе {
		си.оператор(тек.если-нет)
	}
	си.к("}")
}

фн (си: СиГен) оператор-авария(тек: асд.ОператорАвария) {

	пусть арг := ""
	пусть лит? = взять литерал(тек.В)
	если лит? # пусто {
		арг := строки.ф("\"$;\"", приготовить строковый литерал(лит?^.стр^))
	} иначе {
		арг := строки.ф("$;->body", си.выражение(тек.В))
	}

	си.к("$;((char *)$;,$;);", rt_crash, арг, позиция в строку(тек.поз))
}

фн взять литерал(выр: асд.Выражение): мб асд.Литерал {

	выбор пусть тек: тип выр {
	когда асд.Литерал:
		вернуть тек
	когда асд.Преобразовать:
		если тек.сделано {
			вернуть взять литерал(тек.Л)
		}
	}
	вернуть пусто
}

//== оператор выбор

фн можно ли использовать switch(тек: асд.ОператорВыбор): Лог {
/*
	если тек.X = пусто {
		вернуть ложь
	}

	пусть t = асд.основа(тек.Л.Т)
	выбор t {
	когда асд.ТБайт(), асд.ТЦел64(), асд.ТСлово64(), асд.ТСимвол():
	другое
		вернуть ложь
	}

	пока _, c := range тек.Cases {
		пока _, e := range c.Exprs {
			если _, ok := e.(асд.Литерал); ~ok {
				вернуть ложь
			}
		}
	}
*/    
	вернуть истина
}

фн (си: СиГен) оператор выбора через switch(тек: асд.ОператорВыбор) {
/*
	си.к("выбор ($;) {", си.выражение(тек.X))

	пока _, c := range тек.Cases {
		пока _, e := range c.Exprs {
			си.к("когда $;: ", си.выражение(e))
		}
		си.к("{") // пока clang 15.0.7 on linux
		си.список операторов(c.Seq)
		си.к("}")
		си.к("прервать;")
	}

	если тек.если-нет # пусто {
		си.к("другое")
		си.список операторов(тек.если-нет)
	}

	си.к("}")
*/    
}

фн (си: СиГен) генерация выбора через if(тек: асд.ОператорВыбор) {
/*
	пусть strCompare = асд.строка?(тек.Л.Т)

	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.Л.Т), loc, си.выражение(тек.X))

	пусть els = ""
	пока _, c := range тек.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			если strCompare {
				conds = append(conds, строки.ф("$;($;, $;)", rt_equalStrings, loc, си.выражение(e)))
			} иначе {
				conds = append(conds, строки.ф("$; = $;", loc, си.выражение(e)))
			}
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет)
		си.к("}")
	}
*/    
}

фн (си: СиГен) оператор выбора по предикатам(тек: асд.ОператорВыбор) {
/*
	пусть els = ""
	пока _, c := range тек.Cases {

		пусть conds = make([]Строка, 0)
		пока _, e := range c.Exprs {
			conds = append(conds, убрать лишние скобки(си.выражение(e)))
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "
		си.список операторов(c.Seq)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет)
		си.к("}")
	}
*/    
}

//== оператор выбора по типу

// if
фн (си: СиГен) оператор выбора по типу(тек: асд.ОператорВыборПоТипу) {
/*
	пусть loc = си.новое локальное имя("")
	си.к("$; $; = $;;", си.указание-типа(тек.Л.Т), loc, си.выражение(тек.X))

	пусть tag = си.новое локальное имя("tag")
	си.к("void* $; = $;->$;;", tag, loc, имя-поля-ВТ)

	пусть els = ""
	пока _, c := range тек.Cases {

		пусть conds = make([]Строка, 0)
		пока _, t := range c.Types {
			пусть tname = си.указание-типа(t)
			conds = append(conds, строки.ф("$; = $;", tag, tname+суффикс-адрес-дескриптора))
		}
		си.к("$;если ($;) {", els, Строкаs.Join(conds, " | "))
		els = "иначе "

		если c.Var # пусто {
			пусть v = c.Var

			си.к("$; $; = $;$;;",
				си.указание-типа(v.Typ),
				си.имя описания(v),
				си.конверсия при присваивании(v.Typ, тек.Л.Т),
				loc)
		}
		си.список операторов(c.Seq)
		си.к("}")
	}

	если тек.если-нет # пусто {
		си.к("иначе {")
		си.список операторов(тек.если-нет)
		си.к("}")
	}
*/
}
