модуль сиген

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод/utf8"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/сиген/перевод-имен"

конст (
    префикс-имени-типа = "T"
   	префикс-строкового-литерала = "strlit" // префикс для имен строковых литералов
    суффикс-длины-вариативного = "_len"
)    

// класс струкура и мета информация
конст (
	имя-поля-класса        = "f"
	суффикс-полей-класса = "_F"
	имя-поля-базового-класса = "_BASE"

	имя-поля-ВТ    = "vtable"
	имя-поля-Мета = "_meta_"

	суффикс-структуры-ВТ = "_VT"
	суффикс-структуры-Мета = "_Meta"

	суффикс-дескриптор     = "_class_info"
	суффикс-адрес-дескриптора = "_class_info_ptr"
/*
	nm_object_init_suffux    = "__init__"

	nm_base_class_info_= класс = "_BaseClassInfo"
*/
)


конст 	(
    rt_префикс = "tri_"
    rt_cast_union = "TUnion64"
    rt_convert = rt_префикс
)    

//=== run-time API
пусть rt_init = строки.собрать(rt_префикс, "init")

пусть rt_newLiteralString = строки.собрать(rt_префикс, "newLiteralString") // сохраняет в переменную
пусть rt_newString          = строки.собрать(rt_префикс, "newString")
пусть rt_lenString       = строки.собрать(rt_префикс, "lenString")
пусть rt_emptyString     = строки.собрать(rt_префикс, "emptyString")
пусть rt_equalStrings    = строки.собрать(rt_префикс, "equalStrings")

пусть rt_newVector    = строки.собрать(rt_префикс, "newVector")
пусть rt_newVectorFill = строки.собрать(rt_префикс, "newVectorFill")

пусть rt_indexcheck = строки.собрать(rt_префикс, "indexcheck")
пусть rt_nilcheck  = строки.собрать(rt_префикс, "nilcheck")

пусть rt_newObject     = строки.собрать(rt_префикс, "newObject")
пусть rt_checkClassType = строки.собрать(rt_префикс, "checkClassType")
пусть rt_isClassType   = строки.собрать(rt_префикс, "isClassType")

пусть rt_crash= строки.собрать(rt_префикс, "crash")
пусть rt_tag= строки.собрать(rt_префикс, "tag")

пусть rt_vectorAppend= строки.собрать(rt_префикс, "vectorAppend")


// TODO: поставить "_" перед именем
фн (си: СиГен) новое локальное имя(префикс: Строка): Строка {
	если префикс = "" {
		префикс := "loc"
	}

	си.авто-№++
	вернуть строки.ф("$;%d", префикс, си.авто-№)
}

//==

фн (си: СиГен) имя описания(оп: асд.Описание): Строка {

    пусть эл = си.си-имена.найти(оп)

	если эл # пусто {
		вернуть эл^.значение
	}

	если оп типа асд.Функция {
        пусть ф = оп(:асд.Функция)
    
        если ф.внешняя  {
            
            пусть имя := асд.атрибут модификатора(ф.модификатор, "имя")
            если имя = "" {
                имя := перевести имя(ф.имя) 
            }
            
            си.си-имена.добавить(оп, имя)
            вернуть имя
        }
	}

	пусть имя-владельца := ""
	пусть префикс := ""

	если оп.владелец # пусто {
        имя-владельца := строки.ф("$;__", си.имя описания(оп.владелец^))
	}

	если оп типа асд.ОписаниеТипа {
		префикс := префикс-имени-типа
	}

    пусть имя = строки.ф("$;$;$;", префикс, имя-владельца, перевести имя(оп.имя) )

    си.си-имена.добавить(оп, имя)

	вернуть имя
}

фн (си: СиГен) имя функции(ф: асд.Функция): Строка {

	если ф.получатель # пусто {
		вернуть строки.ф("$;_$;", си.указание-типа(ф.получатель^.Т^) , перевести имя(ф.имя))
	}
	вернуть си.имя описания(ф)
}

//==== трансляция имен

пусть перевод = перевод-имен.Словарь{}

// Возвращает имя, заменяя русские буквы и пробелы
// TODO: переиспользовать один Сборщик 
фн перевести имя(имя: Строка): Строка {
    пусть сб = строки.Сборщик{}
    пусть № := 0
    пусть байтов := 0
    пусть и8 = имя(:Строка8)
    пока № < длина(и8) {
        пусть сим = utf8.декодировать символ-строка8(и8, №, байтов)
        пусть эл = перевод.найти(сим)
        если эл = пусто {
            сб.добавить символ(сим)
        } иначе {
            сб.добавить строку(эл^.значение)
        }
    }

	вернуть сб.строка()
}

//==== инициализация перевода

тип П = класс { 
    сим: Символ = позже
    стр: Строка = позже
}
тип ПП = []П 

пусть список = ПП[
    П{сим: ' ', стр: "_"},
    П{сим: '-', стр: "_"},
    
    П{сим: '№', стр: "N_"},    
    П{сим: '?', стр: "Qm"},     
    П{сим: '!', стр: "Em"},      

    П{сим: 'ж', стр: "zh"},       П{сим: 'Ж', стр: "ZH"},
    П{сим: 'й', стр: "yi"},        П{сим: 'Й', стр: "YI"},
    П{сим: 'ц', стр: "tc"},        П{сим: 'Ц', стр: "TC"},
    П{сим: 'ч', стр: "ch"},        П{сим: 'Ч', стр: "CH"},
    П{сим: 'ш', стр: "sh"},       П{сим: 'Ш', стр: "SH"},
    П{сим: 'щ', стр: "shch"},    П{сим: 'Щ', стр: "SHCH"},
    П{сим: 'ю', стр: "yu"},       П{сим: 'Ю', стр: "YU"},
    П{сим: 'я', стр: "ya"},        П{сим: 'Я', стр: "YA"},
]

пусть простые = "аaбbвvгgдdеeёeзzиiкkлlмmнnоoпpрrсsтtуuфfхxъ_ыyь_эeАAБBВVГGДDЕEЁEЗZИIКKЛLМMНNОOПPРRСSТTУUФFХXЪ_ЫYЬ_ЭE"

тип Символы = []Символ

вход{
    цикл п среди список {
        перевод.добавить(п.сим, п.стр)
    }
    пусть пары = простые(:Символы)
    пусть № := 0
    пока № < длина(пары) -1 {
        перевод.добавить(пары[№], пары[№+1](:Строка))
        № := № + 2
    }

 /* в тесты:       
    вывод.ф("$;\n", перевести имя("Привет!"))
    вывод.ф("$;\n", перевести имя("цара Пать-ся"))
*/    
}