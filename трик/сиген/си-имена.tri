модуль сиген

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод/utf8"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/сиген/перевод-имен"

/*
конст typeNamePrefix = "T"

// класс струкура и мета информация
конст (
	nm_class_fields        = "f"
	nm_class_fields_suffix = "_F"

	nm_base_fields = "_BASE"
	nm_VT_field    = "vtable"

	nm_VT_suffix             = "_VT"
	nm_meta_suffix           = "_Meta"
	nm_meta_field            = "_meta_"
	nm_class_info_suffix     = "_class_info"
	nm_class_info_ptr_suffix = "_class_info_ptr"
	nm_object_init_suffux    = "__init__"

	nm_base_class_info_= класс = "_BaseClassInfo"

	nm_variadic_len_suffic = "_len"
)

// prefixes пока generated names
конст (
	nm_СтрокаLiteral = "strlit"
)

// run-time API
конст (
	rt_prefix = "tri_"

	rt_cast_union = "TUnion64"

	rt_init = rt_prefix + "init"

	rt_newLiteralString = rt_prefix + "newLiteralString" // сохраняет в переменную
	rt_newString        = rt_prefix + "newString"
	rt_lenString        = rt_prefix + "lenString"
	rt_emptyString      = rt_prefix + "emptyString"
	rt_equalStrings     = rt_prefix + "equalStrings"

	rt_newVector     = rt_prefix + "newVector"
	rt_newVectorFill = rt_prefix + "newVectorFill"
	//rt_lenVector     = rt_prefix + "lenVector"

	rt_indexcheck = rt_prefix + "indexcheck"
	rt_пустоcheck   = rt_prefix + "пустоcheck"

	rt_newObject      = rt_prefix + "newObject"
	rt_checkClassType = rt_prefix + "checkClassType"
	rt_isClassType    = rt_prefix + "isClassType"

	rt_convert = rt_prefix

	rt_crash = rt_prefix + "crash"

	rt_tag = rt_prefix + "tag"

	rt_vectorAppend = rt_prefix + "vectorAppend"
)

фн (си: СиГен) localName(prefix Строка) Строка {
	если prefix = "" {
		prefix = "loc"
	}

	си.autoNo++
	вернуть строки.ф("$;%d", prefix, си.autoNo)
}

//==

фн (си: СиГен) имя описания(d асд.Описание) Строка {

	out, ok := си.имя описанияs[d]
	если ok {
		вернуть out
	}

	f, is_fn := d.(асд.Функция)

	если is_fn & f.External {
		name, ok := f.Mod.Attrs["имя"]
		если ~ok {
			name = env.OutName(f.Name)
		}
		си.имя описанияs[d] = name

		вернуть name
	}

	out = ""
	пусть host = d.GetHost()
	если host # пусто {
		out = си.имя описания(host) + "__"
	}

	пусть prefix = ""
	если _, ok := d.(асд.ОписаниеТипа); ok {
		prefix = typeNamePrefix
	}

	out += prefix + env.OutName(d.GetName())

	си.имя описанияs[d] = out

	вернуть out
}

фн (си: СиГен) outName(name Строка) Строка {
	вернуть env.OutName(name)
}

фн (си: СиГен) фнtionName(f асд.Функция) Строка {

	если f.Recv # пусто {
		вернуть си.указание-типа(f.Recv.Typ) + "_" + си.outName(f.Name)
	}
	вернуть си.имя описания(f)
}
*/

//==== трансляция имен

пусть перевод = перевод-имен.Словарь{}

// Возвращает имя, заменяя русские буквы и пробелы
// TODO: переиспользовать один Сборщик 
фн перевести имя(имя: Строка): Строка {
    пусть сб = строки.Сборщик{}
    пусть № := 0
    пусть байтов := 0
    пусть и8 = имя(:Строка8)
    пока № < длина(и8) {
        пусть сим = utf8.декодировать символ-строка8(и8, №, байтов)
        пусть эл = перевод.найти(сим)
        если эл = пусто {
            сб.добавить символ(сим)
        } иначе {
            сб.добавить строку(эл^.значение)
        }
    }

	вернуть сб.строка()
}

//==== инициализация перевода

тип П = класс { 
    сим: Символ = позже
    стр: Строка = позже
}
тип ПП = []П 

пусть список = ПП[
    П{сим: ' ', стр: "_"},
    П{сим: '-', стр: "_"},
    
    П{сим: '№', стр: "N_"},    
    П{сим: '?', стр: "Qm"},     
    П{сим: '!', стр: "Em"},      

    П{сим: 'ж', стр: "zh"},       П{сим: 'Ж', стр: "ZH"},
    П{сим: 'й', стр: "yi"},        П{сим: 'Й', стр: "YI"},
    П{сим: 'ц', стр: "tc"},        П{сим: 'Ц', стр: "TC"},
    П{сим: 'ч', стр: "ch"},        П{сим: 'Ч', стр: "CH"},
    П{сим: 'ш', стр: "sh"},       П{сим: 'Ш', стр: "SH"},
    П{сим: 'щ', стр: "shch"},    П{сим: 'Щ', стр: "SHCH"},
    П{сим: 'ю', стр: "yu"},       П{сим: 'Ю', стр: "YU"},
    П{сим: 'я', стр: "ya"},        П{сим: 'Я', стр: "YA"},
]

пусть простые = "аaбbвvгgдdеeёeзzиiкkлlмmнnоoпpрrсsтtуuфfхxъ_ыyь_эeАAБBВVГGДDЕEЁEЗZИIКKЛLМMНNОOПPРRСSТTУUФFХXЪ_ЫYЬ_ЭE"

тип Символы = []Символ

вход{
    цикл п среди список {
        перевод.добавить(п.сим, п.стр)
    }
    пусть пары = простые(:Символы)
    пусть № := 0
    пока № < длина(пары) -1 {
        перевод.добавить(пары[№], пары[№+1](:Строка))
        № := № + 2
    }

 /* в тесты:       
    вывод.ф("$;\n", перевести имя("Привет!"))
    вывод.ф("$;\n", перевести имя("цара Пать-ся"))
*/    
}