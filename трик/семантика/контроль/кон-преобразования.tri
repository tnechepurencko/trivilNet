модуль контроль

импорт "стд::вывод"
импорт "стд::юникод"

импорт "трик/асд"
импорт "трик/основа"

/*
  по целевому типу:
	Байт: Цел64, Слово64, Символ (0..255), Строковый литерал (из 1-го символа)
	Цел64: Байт, Слово64, Вещ64, Символ, Строковый литерал (из 1-го символа)
	Слово64: Байт, Символ, Цел64, Строковый литерал (из 1-го символа)
	Вещ64: Цел64
	Лог: -
	Символ: Байт, Цел64, Слово64, Строковый литерал (из 1-го символа)
	Строка: Символ, []Символ, []Байт
	[]Байт: Строка, Символ
	[]Символ: Строка
	Класс: Класс (от базового к расширенному)
*/
фн (кон: Контроль) преобразование(тек: асд.Преобразовать) {

	кон.выражение(тек.Л)
    
    если асд.полиморфный тип?(тек.Л.Т^) {
		кон.преобразование полиморфного(тек)
		вернуть
    }

	пусть цель = асд.основа(тек.цель)^

	выбор {
	когда асд.байт?(цель):
		кон.преобразование к байту(тек)
		вернуть
	когда асд.цел64?(цель):
		кон.преобразование к цел64(тек)
		вернуть
	когда асд.слово64?(цель):
		кон.преобразование к слово64(тек)
		вернуть
	когда асд.вещ64?(цель):
		кон.преобразование к вещ64(тек)
		вернуть
	когда асд.лог?(цель):
		основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТЛог().имя)
		тек.Т := асд.ТипОшибочный{поз: тек.поз}
		вернуть
	когда асд.символ?(цель):
		кон.преобразование к символу(тек)
		вернуть
	когда асд.строка?(цель):
		кон.преобразование к строке(тек)
		вернуть
	когда асд.строка8?(цель):
		кон.преобразование к строке8(тек)
		вернуть
	другое
		выбор пусть тт: тип цель {
		когда асд.ТипВектор:
			кон.преобразование к вектору(тек, тт)
			вернуть
		когда асд.ТипКласс:
			кон.преобразование к классу(тек, тт)
			вернуть
		}
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.изображение-типа(тек.цель))
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к байту(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.байт?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТБайт()
		вернуть
	когда асд.цел64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.цел < 0 | лит.цел > 255 {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТБайт().имя)
			} иначе {
				лит.вид := асд.Лит-Слово
				лит.слово := лит.цел(:Слово64)
				лит.Т := асд.ТБайт()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТБайт()
		вернуть
	когда асд.слово64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.слово > 255(:Слово64) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТБайт().имя)
			} иначе {
				лит.Т := асд.ТБайт()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТБайт()
		вернуть
	когда асд.символ?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.слово > 255(:Слово64) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТБайт().имя)
			} иначе {
				лит.вид := асд.Лит-Слово
				лит.Т := асд.ТБайт()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТБайт()
		вернуть
	когда асд.строка?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если длина(лит.стр^) # 1 {
				основа.добавить ошибку(тек.поз, "СЕМ-ДЛИНА-СТРОКИ-НЕ-1")
			} иначе {
				если лит.стр^[0] > 255(:Символ) {
					основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТБайт().имя)
				} иначе {
					лит.вид := асд.Лит-Слово
					лит.Т := асд.ТБайт()
					тек.сделано := истина
				}
			}
			тек.Т := асд.ТБайт()
			вернуть
		}
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТБайт().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к цел64(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.цел64?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТЦел64()
		вернуть
	когда асд.байт?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			лит.вид := асд.Лит-Цел
			лит.цел := лит.слово(:Цел64)
			лит.Т := асд.ТЦел64()
			тек.сделано := истина
		}
		тек.Т := асд.ТЦел64()
		вернуть
	когда асд.символ?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			лит.вид := асд.Лит-Цел
			лит.цел := лит.слово(:Цел64)
			лит.Т := асд.ТЦел64()
			тек.сделано := истина
		}
		тек.Т := асд.ТЦел64()
		вернуть
	когда асд.слово64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.слово > 0x7FFFFFFFFFFFFFFF {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТЦел64().имя)
			} иначе {
				лит.вид := асд.Лит-Цел
				лит.цел := лит.слово(:Цел64)
				лит.Т := асд.ТЦел64()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТЦел64()
		вернуть
	когда асд.вещ64?(т):
		//TODO: литерал
		тек.Т := асд.ТЦел64()
		вернуть
	когда асд.строка?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если длина(лит.стр^) # 1 {
				основа.добавить ошибку(тек.поз, "СЕМ-ДЛИНА-СТРОКИ-НЕ-1")
			} иначе {
				лит.вид := асд.Лит-Цел
				лит.цел := лит.стр^[0](:Цел64)
				тек.Т := асд.ТЦел64()
				тек.сделано := истина
			}
			вернуть
		}
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТЦел64().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к слово64(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.слово64?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТСлово64()
		вернуть
	когда асд.байт?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			лит.Т := асд.ТСлово64()
			тек.сделано := истина
		}
		тек.Т := асд.ТСлово64()
		вернуть
	когда асд.символ?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			лит.Т := асд.ТСлово64()
			тек.сделано := истина
		}
		тек.Т := асд.ТСлово64()
		вернуть
	когда асд.цел64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.цел < 0 {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТСлово64().имя)
			} иначе {
				лит.вид := асд.Лит-Слово
				лит.слово := лит.цел(:Слово64)
				лит.Т := асд.ТСлово64()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТСлово64()
		вернуть
	когда асд.строка?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если длина(лит.стр^) # 1 {
				основа.добавить ошибку(тек.поз, "СЕМ-ДЛИНА-СТРОКИ-НЕ-1")
			} иначе {
				лит.вид := асд.Лит-Слово
				лит.слово := лит.стр^[0](:Слово64)
				тек.сделано := истина
			}
			тек.Т := асд.ТСлово64()
			вернуть
		}
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТСлово64().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к вещ64(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.вещ64?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТВещ64()
		вернуть
	когда асд.цел64?(т):
		// пока не работаю с литералами
		тек.Т := асд.ТВещ64()
		вернуть
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТВещ64().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}

}

фн (кон: Контроль) преобразование к символу(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.символ?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТСимвол()
		вернуть
	когда асд.байт?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			тек.сделано := истина
			лит.Т := асд.ТСимвол()
		}
		тек.Т := асд.ТСимвол()
		вернуть
	когда асд.цел64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.цел < 0 | лит.цел > юникод.МаксСимвол(:Цел64) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТСимвол().имя)
			} иначе {
				лит.вид := асд.Лит-Слово
				лит.слово := лит.цел(:Слово64)
				лит.Т := асд.ТСимвол()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТСимвол()
		вернуть
	когда асд.слово64?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.слово > юникод.МаксСимвол(:Слово64) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-В-ДИАПАЗОНЕ", асд.ТСимвол().имя)
			} иначе {
				лит.Т := асд.ТСимвол()
				тек.сделано := истина
			}
		}
		тек.Т := асд.ТСимвол()
		вернуть
	когда асд.строка?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			если длина(лит.стр^) # 1 {
				основа.добавить ошибку(тек.поз, "СЕМ-ДЛИНА-СТРОКИ-НЕ-1")
			} иначе {
				лит.вид := асд.Лит-Символ
				лит.слово := лит.стр^[0](:Слово64)
				тек.сделано := истина
			}
			тек.Т := асд.ТСимвол()
			вернуть
		}
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТСимвол().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}

}

фн (кон: Контроль) преобразование к строке(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.строка?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТСтрока()
		вернуть
	когда асд.строка8?(т):
		тек.Т := асд.ТСтрока()
		вернуть
	когда асд.символ?(т):
		пусть лит? = литерал(тек.Л)
		если лит? # пусто {
            пусть лит = лит?^
			лит.Т := асд.ТСтрока()
			лит.стр := асд.Символы[лит.слово(:Символ)]
			тек.сделано := истина
		}
		тек.Т := асд.ТСтрока()
		вернуть
	}

	если т типа асд.ТипВектор {
		пусть эт = т(:асд.ТипВектор).Т-элемента

		если асд.байт?(эт) | асд.символ?(эт) {
			тек.Т := асд.ТСтрока()
			вернуть
		}
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТСтрока().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к строке8(тек: асд.Преобразовать) {

	пусть т = асд.основа(тек.Л.Т)^

	выбор {
	когда асд.строка?(т):
		тек.Т := асд.ТСтрока8()
		вернуть
	когда асд.строка8?(т):
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.Л.Т))
		тек.Т := асд.ТСтрока8()
		вернуть
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА", асд.изображение-типа(тек.Л.Т), асд.ТСтрока8().имя)
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

фн (кон: Контроль) преобразование к вектору(тек: асд.Преобразовать, цель: асд.ТипВектор) {

	пусть т = асд.основа(тек.Л.Т)^

	если асд.строка?(т) {
		пусть эт = асд.основа(цель.Т-элемента)^

		если асд.байт?(эт) | асд.символ?(эт) {
			тек.Т := тек.цель
			вернуть
		}
	} иначе если асд.символ?(т) {
		тек.Т := тек.цель
		вернуть
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА",
		асд.изображение-типа(тек.Л.Т), асд.изображение-типа(тек.цель))
	тек.Т := асд.ТипОшибочный{поз: тек.поз}

}

фн (кон: Контроль) преобразование к классу(тек: асд.Преобразовать, цель: асд.ТипКласс) {
	пусть т := асд.основа(тек.Л.Т)^

	если т = цель {
		основа.добавить ошибку(тек.поз, "СЕМ-ПРИВЕДЕНИЕ-ТИПА-К-СЕБЕ", асд.изображение-типа(тек.цель))
		тек.Т := тек.цель
		вернуть
	}

    если т типа асд.ТипМБ {
        т := асд.основа(т(:асд.ТипМБ).Т)^
    }

	если т типа асд.ТипКласс {
		если ~ является расширением класса(т(:асд.ТипКласс), цель) {
			основа.добавить ошибку(тек.поз, "СЕМ-ДОЛЖЕН-БЫТЬ-НАСЛЕДНИКОМ", асд.изображение-типа(тек.цель), асд.изображение-типа(тек.Л.Т))
		}
		тек.Т := тек.цель
		вернуть
	}

	основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ПРИВЕДЕНИЯ-ТИПА",
		асд.изображение-типа(тек.Л.Т), асд.изображение-типа(тек.цель))
	тек.Т := асд.ТипОшибочный{поз: тек.поз}
}

//====

фн (кон: Контроль) преобразование полиморфного(тек: асд.Преобразовать) {
    // все преобразования разрешены
    тек.Т := тек.цель
}

