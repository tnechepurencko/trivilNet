модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"

//==== типы

фн (кон: Контроль) описание-типа(оп: асд.ОписаниеТипа) {
	выбор пусть тек: тип оп.Т^ {
	когда асд.ТипОшибочный:
		// ничего
	когда асд.ТипВектор:
		// есть ли что проверять?
	когда асд.ТипКласс:
		кон.тип-класса(оп, тек)
	когда асд.ТипМБ:
		// ничего
	когда асд.УказТипа:
		// ничего
	другое
        авария(строки.ф("необработанный тип: $тип;", оп.Т^)) 
	}
   
}

фн (кон: Контроль) уже проверено(тек: асд.ОписаниеТипа): Лог {

	если тек.владелец # пусто & тек.владелец^ # кон.мод {
		вернуть истина
	}
    
    пусть эл = кон.описание-проверено.найти(тек)
    
	вернуть эл # пусто
}

фн (кон: Контроль) тип-класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {

	если кон.уже проверено(оп) {
		вернуть
	}
	кон.описание-проверено.добавить(оп, истина)

	если тк.Т-базовый # пусто {
		кон.базовый тип-класса(тк, тк.атрибуты)
	}
/*
	пока _, f := range тк.Fields {

		если f.задать-позже {
			если f.Typ = пусто {
				основа.добавить ошибку(f.Pos, "СЕМ-ДЛЯ-ПОЗЖЕ-НУЖЕН-ТИП")
			}
		} иначе {
			кон.выражение(f.Init)

			если f.Typ # пусто {
				кон.проверить совместимость по присваиванию(f.Typ, f.Init)
			} иначе {
				f.Typ = f.Init.GetType()
				если f.Typ = пусто {
					panic("assert - не задан тип поля")
				}
			}
		}

		prev, ok := тк.Members[f.Name]
		если ok {
			основа.добавить ошибку(f.Pos, "СЕМ-ДУБЛЬ-В-КЛАССЕ", f.Name, env.PosString(prev.(ast.Node).GetPos()))
		} иначе {
			тк.Members[f.Name] = f
		}
	}

	пока _, m := range тк.Methods {
		prev, ok := тк.Members[m.Name]
		если ok {
			prevM, ok := prev.(асд.Функция)
			если ok & ast.UnderType(prevM.Recv.Typ) # ast.UnderType(m.Recv.Typ) {
				// сигнатуры при переопределении должны совпадать
				пусть res = кон.compareFuncTypes(m.Typ, prevM.Typ)
				если res # "" {
					основа.добавить ошибку(m.Pos, "СЕМ-РАЗНЫЕ-ТИПЫ-МЕТОДОВ", m.Name, res)
				} иначе {
					тк.Members[m.Name] = m
				}
			} иначе {
				основа.добавить ошибку(m.Pos, "СЕМ-ДУБЛЬ-В-КЛАССЕ", m.Name, env.PosString(prev.(ast.Node).GetPos()))
			}
		} иначе {
			тк.Members[m.Name] = m
		}
	}
*/    
}

фн (кон: Контроль) базовый тип-класса(тк: асд.ТипКласс, атрибуты: асд.Словарь) {
/*
	пусть tr = тк.BaseTyp.(асд.УказТипа)

	baseClass, ok := tr.Typ.(асд.ТипКласс)
	если ~ok {
		основа.добавить ошибку(tr.Pos, "СЕМ-БАЗА-НЕ-КЛАСС")
		вернуть
	}

	если ~кон.уже проверено(tr.TypeDecl) {
		кон.тип-класса(tr.TypeDecl, baseClass)
	}

	если baseClass.BaseTyp # пусто {
		кон.базовый тип-класса(baseClass, members)
	}

	пока _, f := range baseClass.Fields {
		members[f.Name] = f
	}
	пока _, m := range baseClass.Methods {
		members[m.Name] = m
	}
*/    
}

/*
// Возвращает "", если равны или причину, если разные
фн (кон: Контроль) compareFuncTypes(t1, t2 асд.Тип) Строка {
	ft1, ok1 := t1.(асд.ТипФункция)
	ft2, ok2 := t2.(асд.ТипФункция)
	если ~ok1 | ~ok2 {
		вернуть "" // а вдруг где-то Invalid type
	}

	если длина(ft1.Params) # длина(ft2.Params) {
		вернуть "разное число параметров"
	}

	пока i, p := range ft1.Params {
		если p.Out # ft2.Params[i].Out {
			вернуть fmt.Sprintf("не совпадает признак выходного параметра '%s'", p.Name)
		}
		если ~эквивалентные типы(p.Typ, ft2.Params[i].Typ) {
			вернуть fmt.Sprintf("не совпадает тип у параметра '%s'", p.Name)
		}
	}

	если ~эквивалентные типы(ft1.Т-вернуть, ft2.Т-вернуть) {
		вернуть "разные типы результата"
	}

	вернуть ""
}

// Возвращает истина, если можно присвоить
фн (кон: Контроль) assignable(lt асд.Тип, r асд.Выражение) Лог {

	кон.errorHint = ""

	если эквивалентные типы(lt, r.GetType()) {
		вернуть истина
	}

	пусть t = ast.UnderType(lt)

	выбор t {
	когда ast.Byte:
		пусть li = literal(r)
		если li # пусто {
			если li.Kind = ast.Lit_Int & (li.IntVal >= 0 | li.IntVal <= 255) {
				li.WordVal = Слово64(li.IntVal)
				li.Typ = ast.Byte
				вернуть истина
			} иначе если li.Kind = ast.Lit_Word & li.WordVal <= 255 {
				li.Typ = ast.Byte
				вернуть истина
			}
		}
	когда ast.Word64:
		пусть li = literal(r)
		если li # пусто {
			если li.Kind = ast.Lit_Int & li.IntVal >= 0 {
				li.WordVal = Слово64(li.IntVal)
				li.Typ = ast.Word64
				вернуть истина
			} иначе если li.Kind = ast.Lit_Word {
				li.Typ = ast.Word64
				вернуть истина
			}
		}
	когда ast.Int64:
		пусть li = literal(r)
		если li # пусто {
			если li.Kind = ast.Lit_Word & li.WordVal <= 1<<63-1 {
				li.Typ = ast.Int64
				вернуть истина
			}
		}
	когда ast.TagPairType:
		вернуть ast.HasTag(r.GetType())
	}

	выбор xt := t.(type) {
	/*
		когда асд.ТипВектор:
			rvec, ok := ast.UnderType(r.GetType()).(асд.ТипВектор)
			если ok & эквивалентные типы(xt.ElementTyp, rvec.ElementTyp) {
				вернуть истина
			}
	*/
	когда асд.ТипКласс:
		rcl, ok := ast.UnderType(r.GetType()).(асд.ТипКласс)
		если ok & isDerivedClass(xt, rcl) {
			вернуть истина
		}
	когда асд.ТипМБ:
		пусть rt = ast.UnderType(r.GetType())
		если rt = ast.NullType {
			вернуть истина
		} иначе если кон.assignable(xt.Typ, r) {
			вернуть истина
		}

	}

	// TODO: фнtion types, ...
	вернуть ложь
}

фн (кон: Контроль) проверить совместимость по присваиванию(lt асд.Тип, r асд.Выражение) {

	если ast.IsVoidType(r.GetType()) {
		основа.добавить ошибку(r.GetPos(), "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
		вернуть
	}

	если кон.assignable(lt, r) {
		вернуть
	}
	если ast.IsInvalidType(lt) | ast.IsInvalidType(r.GetType()) {
		вернуть
	}

	основа.добавить ошибку(r.GetPos(), "СЕМ-НЕСОВМЕСТИМО-ПРИСВ", кон.errorHint,
		асд.изображение имени-типа(lt), асд.изображение имени-типа(r.GetType()))
}

фн эквивалентные типы(t1, t2 асд.Тип) Лог {
	t1 = ast.UnderType(t1)
	t2 = ast.UnderType(t2)
	если t1 = t2 {
		вернуть истина
	}
	выбор x1 := t1.(type) {
	когда асд.ТипВектор:
		x2, ok := t2.(асд.ТипВектор)
		вернуть ok & эквивалентные типы(x1.ElementTyp, x2.ElementTyp)
	когда асд.VariadicType:
		x2, ok := t2.(асд.VariadicType)
		вернуть ok & эквивалентные типы(x1.ElementTyp, x2.ElementTyp)
	когда асд.ТипМБ:
		x2, ok := t2.(асд.ТипМБ)
		вернуть ok & эквивалентные типы(x1.Typ, x2.Typ)
	}
	вернуть ложь
}

//== ошибки с проверкой

фн addErrorForType(t асд.Тип, pos int, id Строка, args ...interface{}) {
	если ~ast.IsInvalidType(t) {
		основа.добавить ошибку(pos, id, args...)
	}
}

*/