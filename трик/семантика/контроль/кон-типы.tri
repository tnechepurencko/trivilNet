модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"

//==== типы

фн (кон: Контроль) описание-типа(оп: асд.ОписаниеТипа) {
	выбор пусть тек: тип оп.Т^ {
	когда асд.ТипОшибочный:
		// ничего
	когда асд.ТипВектор:
		// есть ли что проверять?
	когда асд.ТипКласс:
		кон.тип-класса(оп, тек)
	когда асд.ТипМБ:
		// ничего
	когда асд.УказТипа:
		// ничего
	другое
        авария(строки.ф("необработанный тип: $тип;", оп.Т^)) 
	}
   
}

фн (кон: Контроль) уже проверено(тек: асд.ОписаниеТипа): Лог {

	если тек.владелец # пусто & тек.владелец^ # кон.мод {
		вернуть истина
	}
    
    пусть эл = кон.описание-проверено.найти(тек)
    
	вернуть эл # пусто
}

фн (кон: Контроль) тип-класса(оп: асд.ОписаниеТипа, тк: асд.ТипКласс) {

	если кон.уже проверено(оп) {
		вернуть
	}
	кон.описание-проверено.добавить(оп, истина)

	если тк.Т-базовый # пусто {
		кон.базовый тип-класса(тк, тк.атрибуты)
	}

    цикл поле среди тк.поля {

		если поле.задать-позже {
			если поле.Т = пусто {
				основа.добавить ошибку(поле.поз, "СЕМ-ДЛЯ-ПОЗЖЕ-НУЖЕН-ТИП")
			}
		} иначе {
			кон.выражение(поле.значение^)

			если поле.Т # пусто {
				кон.проверить совместимость по присваиванию(поле.Т^, поле.значение^)
			} иначе {
				поле.Т := поле.значение^.Т
				если поле.Т = пусто {
					авария("assert - не задан тип поля")
				}
			}
		}

        пусть эл = тк.атрибуты.найти(поле.имя)
		если эл # пусто {
			основа.добавить ошибку(поле.поз, "СЕМ-ДУБЛЬ-В-КЛАССЕ", поле.имя, основа.позиция для показа(эл^.значение.поз))
		} иначе {
			тк.атрибуты.добавить(поле.имя, поле)
		}
	}

    цикл метод среди тк.методы {
        пусть эл = тк.атрибуты.найти(метод.имя)
		если эл # пусто {
            кон.проверить определение метода(тк, метод, эл^.значение)
		} иначе {
			тк.атрибуты.добавить(метод.имя, метод)
		}
	}
}

фн(кон: Контроль) проверить определение метода(тк: асд.ТипКласс, метод: асд.Функция, пред: асд.Описание) {
    надо пред типа асд.Функция иначе { // smart cast уберет дублирование добавление ошибки
		основа.добавить ошибку(метод.поз, "СЕМ-ДУБЛЬ-В-КЛАССЕ", метод.имя, основа.позиция для показа(пред.поз))
        вернуть
    }
    пусть пред-метод = пред(:асд.Функция)
    если асд.основы равны(метод.получатель^.Т, пред-метод.получатель^.Т) {
		основа.добавить ошибку(метод.поз, "СЕМ-ДУБЛЬ-В-КЛАССЕ", метод.имя, основа.позиция для показа(пред-метод.поз))
    } иначе {
		// сигнатуры при переопределении должны совпадать
		пусть рез = кон.сравнить типы функций(метод.Т^, пред-метод.Т^)
		если рез # "" {
			основа.добавить ошибку(метод.поз, "СЕМ-РАЗНЫЕ-ТИПЫ-МЕТОДОВ", метод.имя, рез)
		} иначе {
			тк.атрибуты.добавить(метод.имя, метод)
		}
	}
}

фн (кон: Контроль) базовый тип-класса(тк: асд.ТипКласс, атрибуты: асд.Словарь) {

	пусть указ = тк.Т-базовый(:асд.УказТипа)

	если ~ (указ.Т типа асд.ТипКласс) {
		основа.добавить ошибку(указ.поз, "СЕМ-БАЗА-НЕ-КЛАСС")
		вернуть
	}

    пусть базовый-класс = указ.Т(:асд.ТипКласс)

	если ~кон.уже проверено(указ.оп-типа^) {
		кон.тип-класса(указ.оп-типа^, базовый-класс)
	}

	если базовый-класс.Т-базовый # пусто {
		кон.базовый тип-класса(базовый-класс, атрибуты)
	}

    цикл поле среди базовый-класс.поля {
		атрибуты.добавить(поле.имя, поле)
	}
    цикл метод среди базовый-класс.методы {
		атрибуты.добавить(метод.имя, метод)
	}
}

// Возвращает "", если равны или причину, если разные
фн (кон: Контроль) сравнить типы функций(т1: асд.Тип, т2: асд.Тип): Строка {

    пусть тф1  = т1(:асд.ТипФункция)
    пусть тф2  = т2(:асд.ТипФункция)

    если длина(тф1.параметры) # длина(тф2.параметры) {
		вернуть "разное число параметров"
	}

    цикл [№]пар среди тф1.параметры {
        если пар.выходной # тф2.параметры[№].выходной {
			вернуть строки.ф("не совпадает признак выходного параметра '$;'", пар.имя)
		}
		если ~эквивалентные типы(пар.Т, тф2.параметры[№].Т) {
			вернуть строки.ф("не совпадает тип у параметра '$;'", пар.имя)
		}
	}

	если ~эквивалентные типы(тф1.Т-вернуть, тф2.Т-вернуть) {
		вернуть "разные типы результата"
	}

	вернуть ""
}

// Возвращает истину, если можно присвоить
фн (кон: Контроль) можно присвоить(лт: асд.Тип, пр: асд.Выражение): Лог {

	если эквивалентные типы(лт, пр.Т^) {
		вернуть истина
	}

	пусть т = асд.основа(лт)^

	выбор {
	когда т = асд.ТБайт():
		пусть лит? = литерал(пр)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.вид = асд.Лит-Цел & (лит.цел >= 0 & лит.цел <= 255) {
				лит.слово := лит.цел(:Слово64)
				лит.Т := асд.ТБайт()
				вернуть истина
			} иначе если лит.вид = асд.Лит-Слово & лит.слово <= 255(:Слово64) {
				лит.Т := асд.ТБайт()
				вернуть истина
			}
		}
	когда т = асд.ТСлово64():
		пусть лит? = литерал(пр)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.вид = асд.Лит-Цел & лит.цел >= 0 {
				лит.слово := лит.цел(: Слово64)
				лит.Т := асд.ТСлово64()
				вернуть истина
			} иначе если лит.вид = асд.Лит-Слово {
				лит.Т := асд.ТСлово64()
				вернуть истина
			}
		}
	когда т = асд.ТЦел64():
		пусть лит? = литерал(пр)
		если лит? # пусто {
            пусть лит = лит?^
			если лит.вид = асд.Лит-Слово & лит.слово <= 0x7FFFFFFFFFFFFFFF {
				лит.Т := асд.ТЦел64()
				вернуть истина
			}
		}
	когда т = асд.ТипПолиморфный():
		вернуть асд.есть тег(пр.Т^)
	}

    пусть пр-т = пр.Т^
    
	выбор пусть тек: тип т {
	когда асд.ТипКласс:
        надо асд.тип-класса?(пр-т) иначе вернуть ложь

		если является расширением класса(тек, асд.основа(пр-т)(:асд.ТипКласс)) {
			вернуть истина
		}
	когда асд.ТипМБ:
		пусть о = асд.основа(пр-т)
		если о^ = асд.ТипПусто() {
			вернуть истина
		} иначе если кон.можно присвоить(тек.Т, пр) {
			вернуть истина
		}
	}

	вернуть ложь
}


фн (кон: Контроль) проверить совместимость по присваиванию(лт: асд.Тип, пр: асд.Выражение) {

	если асд.тип-нет значения?(пр.Т^) {
		основа.добавить ошибку(пр.поз, "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
		вернуть
	}

	если кон.можно присвоить(лт, пр) {
		вернуть
	}
    
	если асд.ошибочный тип?(лт) | асд.ошибочный тип?(пр.Т^) {
		вернуть
	}

	основа.добавить ошибку(пр.поз, "СЕМ-НЕСОВМЕСТИМО-ПРИСВ", "",
		асд.изображение-типа(лт), асд.изображение-типа(пр.Т^))
}

фн эквивалентные типы(т1: мб асд.Тип,  т2: мб асд.Тип): Лог {
    надо т1 # пусто иначе вернуть т2 = пусто
    надо т2 # пусто иначе вернуть ложь

    т1 := асд.основа(т1^)
    т2 := асд.основа(т2^)
    если т1 = т2 {
        вернуть истина
    }

	выбор пусть о1: тип т1^ {
	когда асд.ТипВектор:
        надо т2 типа асд.ТипВектор иначе вернуть ложь
		вернуть эквивалентные типы(о1.Т-элемента, т2(:асд.ТипВектор).Т-элемента)

	когда асд.ТипВариативный:
        надо т2 типа асд.ТипВариативный иначе вернуть ложь
		вернуть эквивалентные типы(о1.Т-элемента, т2(:асд.ТипВариативный).Т-элемента)

	когда асд.ТипМБ:
        надо т2 типа асд.ТипМБ иначе вернуть ложь
		вернуть эквивалентные типы(о1.Т, т2(:асд.ТипМБ).Т)
	}
    
	вернуть ложь
}

фн является расширением класса(базовый: асд.ТипКласс,  тк: асд.ТипКласс): Лог {

	пусть тек := тк

	пока тек.Т-базовый # пусто {
        пусть о = асд.основа(тек.Т-базовый^)
		если о^ = базовый {
			вернуть истина
		}
		тек := о(:асд.ТипКласс)
	}
	вернуть ложь
}

