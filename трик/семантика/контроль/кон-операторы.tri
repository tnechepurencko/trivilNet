модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/лексер"

//== операторы

фн (кон: Контроль) вход!(тек: асд.Вход) {
	кон.уровень-цикла := 0
	кон.операторы(тек.тело)
}

фн (кон: Контроль) операторы(блок: асд.СписокОператоров) {
    цикл оп среди блок.операторы {
		кон.оператор(оп)
	}
}

фн (кон: Контроль) оператор(оп: асд.Оператор) {

	выбор пусть тек: тип оп {
	когда асд.СписокОператоров:
		кон.операторы(тек) // из иначе

	когда асд.ОператорВыражение:
		если тек.выражение типа асд.БинарнаяОперация & тек.выражение(:асд.БинарнаяОперация).операция = лексер.РАВНО {
			основа.добавить ошибку(тек.выражение.поз, "СЕМ-ОЖИДАЛОСЬ-ПРИСВАИВАНИЕ")
		} иначе {
			кон.выражение(тек.выражение)
			если ~ (тек.выражение типа асд.Вызов) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-ИСПОЛЬЗУЕТСЯ")
			}
		}
	когда асд.ОператорОписание:
		кон.локальное описание(тек.описание)

	когда асд.ОператорПрисвоить:
		кон.выражение(тек.Л)
		кон.выражение(тек.П)
		кон.проверить совместимость по присваиванию(тек.Л.Т^, тек.П)
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорУвеличить:
		кон.выражение(тек.Л)
		если ~ асд.целочисленный тип?(тек.Л.Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(тек.Л.Т^), лексер.для показа(лексер.УВЕЛИЧИТЬ))
		}
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорУменьшить:
		кон.выражение(тек.Л)
		если ~ асд.целочисленный тип?(тек.Л.Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(тек.Л.Т^), лексер.для показа(лексер.УМЕНЬШИТЬ))
		}
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорЕсли:
		кон.выражение(тек.условие)
		если ~асд.лог?(тек.условие.Т^) {
			основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
		}

		кон.операторы(тек.если-да)
		если тек.если-нет # пусто {
			кон.оператор(тек.если-нет^)
		}
	когда асд.ОператорПока:
		кон.оператор-пока(тек)
	когда асд.ОператорЦикл:
		кон.оператор-цикл(тек)
	когда асд.ОператорНадо:
		кон.выражение(тек.условие)
		если ~ асд.лог?(тек.условие.Т^) {
			основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
		}
		кон.оператор(тек.если-нет)
		если тек.если-нет типа асд.СписокОператоров {
			если ~завершающий оператор(тек.если-нет(:асд.СписокОператоров)) {
				основа.добавить ошибку(тек.если-нет.поз, "СЕМ-НЕ-ЗАВЕРШАЮЩИЙ")
			}
		}
	когда асд.ОператорВыбор:
//!		кон.checkSelect(тек)
	когда асд.ОператорВыборПоТипу:
//!		кон.checkSelectType(тек)

	когда асд.ОператорВернуть:
		если тек.В # пусто {
			кон.выражение(тек.В^)

			если кон.Т-вернуть = пусто {
				основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ВЕРНУТЬ-ЛИШНЕЕ")
			} иначе {
				кон.проверить совместимость по присваиванию(кон.Т-вернуть^, тек.В^)
				тек.Т-вернуть := кон.Т-вернуть
			}
		} иначе если кон.Т-вернуть # пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ВЕРНУТЬ-НУЖНО")
		}
	когда асд.ОператорПрервать:
		если кон.уровень-цикла = 0 {
			основа.добавить ошибку(тек.поз, "СЕМ-ПРЕРВАТЬ-ВНЕ-ЦИКЛА")
		}
	когда асд.ОператорАвария:
		кон.выражение(тек.В)
		если ~асд.строковый тип?(тек.В.Т^) {
			основа.добавить ошибку(тек.В.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТСтрока().имя)
		}

	другое
        авария(строки.ф("необработанный оператор: $тип;", оп)) 
	}
}

фн (кон: Контроль) локальное описание(оп: асд.Описание) {

	выбор пусть тек: тип оп {
	когда асд.ОписаниеПеременной:
		кон.описание переменной(тек)
	другое
        авария(строки.ф("необработанное локальное описание: $тип;", оп)) 
	}
}

//== циклы
фн (кон: Контроль) оператор-пока(тек: асд.ОператорПока) {
	кон.выражение(тек.условие)
	если ~асд.лог?(тек.условие.Т^) {
		основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
	}
	кон.уровень-цикла++
	кон.операторы(тек.тело)
	кон.уровень-цикла--
}

фн (кон: Контроль) оператор-цикл(тек: асд.ОператорЦикл) {

	кон.выражение(тек.В)
	пусть т := тек.В.Т^

	если ~асд.индексируемый тип?(т) {
		основа.добавить ошибку(тек.В.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-МАССИВА", асд.изображение имени-типа(т))
		т := асд.ТипОшибочный{поз: тек.В.поз}
	}

	если тек.индекс # пусто {
		если тек.индекс^.Т # пусто {
			авария("ni - явные типы для итерируемых переменных")
		}
		тек.индекс^.Т := асд.ТЦел64()
	}
	если тек.элемент # пусто {
		если тек.элемент^.Т # пусто {
			авария("ni - явные типы для итерируемых переменных")
		}
		тек.элемент^.Т := асд.тип-элемента(т)
	}

	кон.уровень-цикла++
	кон.операторы(тек.тело)
	кон.уровень-цикла--
}

//== оператор выбора по выражению
/*

фн (кон: Контроль) checkSelect(x асд.ОператорВыбор) {

	если тек.Л = пусто {
		кон.checkPredicateSelect(x)
		return
	}

	кон.выражение(тек.Л)
	checkSelectExpr(тек.Л)

	пока _, c := range тек.Cases {
		пока _, e := range c.Exprs {
			кон.выражение(e)
			если ~эквивалентные типы(тек.Л.Т, e.GetType()) {
				основа.добавить ошибку(e.поз, "СЕМ-ВЫБОР-ОШ-ТИП-ВАРИАНТА", асд.изображение имени-типа(e.GetType()), асд.изображение имени-типа(тек.Л.Т))
			}
		}
		кон.операторы(c.Seq)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет)
	}
}

фн (кон: Контроль) checkPredicateSelect(x асд.ОператорВыбор) {

	пока _, c := range тек.Cases {
		пока _, e := range c.Exprs {
			кон.выражение(e)
			если ~эквивалентные типы(e.GetType(), асд.ТЛог()) {
				основа.добавить ошибку(e.поз, "СЕМ-ВЫБОР-ОШ-ТИП-ПРЕДИКАТА", асд.изображение имени-типа(асд.ТЛог()), асд.изображение имени-типа(e.GetType()))
			}
		}
		кон.операторы(c.Seq)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет)
	}
}

фн checkSelectExpr(x асд.Выражение) {
	пусть t = асд.основа(тек.GetType())
	выбор t {
	когда асд.ТБайт(), асд.ТЦел64(), асд.ТСлово64(), асд.ТСимвол(), асд.ТСтрока():
		return
	другое
		если асд.тип-класса?(t) {
			return
		}
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ВЫБОР-ОШ-ТИП", асд.изображение имени-типа(тек.GetType()))
}

//== оператор выбора по типу

фн (кон: Контроль) checkSelectType(x асд.ОператорВыборType) {

	кон.выражение(тек.Л)

	tClass, isClass := асд.основа(тек.Л.Т).(асд.ТипКласс)

	если ~isClass {
		основа.добавить ошибку(тек.поз, "СЕМ-ВЫБОР-ТИП-КЛАССА", асд.изображение имени-типа(тек.Л.Т))
	}

	пока _, c := range тек.Cases {
		пока _, t := range c.Types {
			когдаClass, ok := асд.основа(t).(асд.ТипКласс)
			если ~ok {
				основа.добавить ошибку(t.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-КЛАССА", асд.изображение имени-типа(t))
			} иначе если isClass {
				если когдаClass # tClass & ~isDerivedClass(tClass, когдаClass) {
					основа.добавить ошибку(t.поз, "СЕМ-ДОЛЖЕН-БЫТЬ-НАСЛЕДНИКОМ", асд.изображение имени-типа(t), асд.изображение имени-типа(тек.Л.Т))
				}
			}
		}
		если c.Var # пусто {
			если длина(c.Types) > 1 {
				основа.добавить ошибку(c.поз, "СЕМ-ВЫБОР-ОДИН-ТИП")
			}

			c.Var.Typ = c.Types[0]

		}
		кон.операторы(c.Seq)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет)
	}
}
*/
//====

фн завершающий оператор(блок: асд.СписокОператоров): Лог {
	если длина(блок.операторы) = 0 {
		вернуть ложь
	}
	пусть последний = блок.операторы[длина(блок.операторы)-1]
    
	выбор тип последний {
	когда асд.ОператорВернуть, асд.ОператорПрервать, асд.ОператорАвария:
		вернуть истина
	другое
		вернуть ложь
	}
}
