модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/лексер"

//== операторы

фн (кон: Контроль) вход!(тек: асд.Вход) {
	кон.уровень-цикла := 0
	кон.операторы(тек.тело)
}

фн (кон: Контроль) операторы(блок: асд.СписокОператоров) {
    цикл оп среди блок.операторы {
		кон.оператор(оп)
	}
}

фн (кон: Контроль) оператор(оп: асд.Оператор) {

	выбор пусть тек: тип оп {
	когда асд.СписокОператоров:
		кон.операторы(тек) // из иначе

	когда асд.ОператорВыражение:
		если тек.выражение типа асд.БинарнаяОперация & тек.выражение(:асд.БинарнаяОперация).операция = лексер.РАВНО {
			основа.добавить ошибку(тек.выражение.поз, "СЕМ-ОЖИДАЛОСЬ-ПРИСВАИВАНИЕ")
		} иначе {
			кон.выражение(тек.выражение)
			если ~ (тек.выражение типа асд.Вызов) {
				основа.добавить ошибку(тек.поз, "СЕМ-ЗНАЧЕНИЕ-НЕ-ИСПОЛЬЗУЕТСЯ")
			}
		}
	когда асд.ОператорОписание:
		кон.локальное описание(тек.описание)

	когда асд.ОператорПрисвоить:
		кон.выражение(тек.Л)
		кон.выражение(тек.П)
		кон.проверить совместимость по присваиванию(тек.Л.Т^, тек.П)
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорУвеличить:
		кон.выражение(тек.Л)
		если ~ асд.целочисленный тип?(тек.Л.Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(тек.Л.Т^), лексер.для показа(лексер.УВЕЛИЧИТЬ))
		}
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорУменьшить:
		кон.выражение(тек.Л)
		если ~ асд.целочисленный тип?(тек.Л.Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(тек.Л.Т^), лексер.для показа(лексер.УМЕНЬШИТЬ))
		}
		кон.проверить левую часть присваивания(тек.Л)
	когда асд.ОператорЕсли:
		кон.выражение(тек.условие)
		если ~асд.лог?(тек.условие.Т^) {
			основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
		}

		кон.операторы(тек.если-да)
		если тек.если-нет # пусто {
			кон.оператор(тек.если-нет^)
		}
	когда асд.ОператорПока:
		кон.оператор-пока(тек)
	когда асд.ОператорЦикл:
		кон.оператор-цикл(тек)
	когда асд.ОператорНадо:
		кон.выражение(тек.условие)
		если ~ асд.лог?(тек.условие.Т^) {
			основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
		}
		кон.оператор(тек.если-нет)
		если тек.если-нет типа асд.СписокОператоров {
			если ~завершающий оператор(тек.если-нет(:асд.СписокОператоров)) {
				основа.добавить ошибку(тек.если-нет.поз, "СЕМ-НЕ-ЗАВЕРШАЮЩИЙ")
			}
		}
	когда асд.ОператорВыбор:
        кон.оператор выбора(тек)
	когда асд.ОператорВыборПоТипу:
		кон.оператор выбора по типу(тек)

	когда асд.ОператорВернуть:
		если тек.В # пусто {
			кон.выражение(тек.В^)

			если кон.Т-вернуть = пусто {
				основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ВЕРНУТЬ-ЛИШНЕЕ")
			} иначе {
				кон.проверить совместимость по присваиванию(кон.Т-вернуть^, тек.В^)
				тек.Т-вернуть := кон.Т-вернуть
			}
		} иначе если кон.Т-вернуть # пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ОШ-ВЕРНУТЬ-НУЖНО")
		}
	когда асд.ОператорПрервать:
		если кон.уровень-цикла = 0 {
			основа.добавить ошибку(тек.поз, "СЕМ-ПРЕРВАТЬ-ВНЕ-ЦИКЛА")
		}
	когда асд.ОператорАвария:
		кон.выражение(тек.В)
		если ~асд.строковый тип?(тек.В.Т^) {
			основа.добавить ошибку(тек.В.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТСтрока().имя)
		}

	другое
        авария(строки.ф("необработанный оператор: $тип;", оп)) 
	}
}

фн (кон: Контроль) локальное описание(оп: асд.Описание) {

	выбор пусть тек: тип оп {
	когда асд.ОписаниеПеременной:
		кон.описание переменной(тек)
	другое
        авария(строки.ф("необработанное локальное описание: $тип;", оп)) 
	}
}

//== циклы

фн (кон: Контроль) оператор-пока(тек: асд.ОператорПока) {
	кон.выражение(тек.условие)
	если ~асд.лог?(тек.условие.Т^) {
		основа.добавить ошибку(тек.условие.поз, "СЕМ-ТИП-ВЫРАЖЕНИЯ", асд.ТЛог().имя)
	}
	кон.уровень-цикла++
	кон.операторы(тек.тело)
	кон.уровень-цикла--
}

фн (кон: Контроль) оператор-цикл(тек: асд.ОператорЦикл) {

	кон.выражение(тек.В)
	пусть т := тек.В.Т^

	если ~асд.индексируемый тип?(т) {
		основа.добавить ошибку(тек.В.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-МАССИВА", асд.изображение имени-типа(т))
		т := асд.ТипОшибочный{поз: тек.В.поз}
	}

	если тек.индекс # пусто {
		если тек.индекс^.Т # пусто {
			авария("ni - явные типы для итерируемых переменных")
		}
		тек.индекс^.Т := асд.ТЦел64()
	}
	если тек.элемент # пусто {
		если тек.элемент^.Т # пусто {
			авария("ni - явные типы для итерируемых переменных")
		}
		тек.элемент^.Т := асд.тип-элемента(т)
	}

	кон.уровень-цикла++
	кон.операторы(тек.тело)
	кон.уровень-цикла--
}

//== оператор выбора по выражению

фн (кон: Контроль) оператор выбора(тек: асд.ОператорВыбор) {

	если тек.В = пусто {
		кон.оператор выбора по предикатам(тек)
		вернуть
	}

	кон.выражение(тек.В^)
	выражение оператора выбора(тек.В^)

    цикл вариант среди тек.варианты {
        цикл выр среди вариант.выражения {
			кон.выражение(выр)
			если ~ эквивалентные типы(тек.В^.Т, выр.Т) {
				основа.добавить ошибку(выр.поз, "СЕМ-ВЫБОР-ОШ-ТИП-ВАРИАНТА", 
                    асд.изображение имени-типа(выр.Т^), 
                    асд.изображение имени-типа(тек.В^.Т^))
			}
		}
		кон.операторы(вариант.тело)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет^)
	}
}

фн выражение оператора выбора(выр: асд.Выражение) {
	пусть т = асд.основа(выр.Т^)^
	если  т = асд.ТБайт() | т = асд.ТЦел64() | т = асд.ТСлово64() | т = асд.ТСимвол() | т = асд.ТСтрока() | асд.тип-класса?(т) {
		вернуть
    }
	основа.добавить ошибку(выр.поз, "СЕМ-ВЫБОР-ОШ-ТИП", асд.изображение имени-типа(выр.Т^))
}

фн (кон: Контроль) оператор выбора по предикатам(тек: асд.ОператорВыбор) {

    цикл вариант среди тек.варианты {
        цикл выр среди вариант.выражения {
			кон.выражение(выр)
			если ~эквивалентные типы(выр.Т, асд.ТЛог()) {
				основа.добавить ошибку(выр.поз, "СЕМ-ВЫБОР-ОШ-ТИП-ПРЕДИКАТА", 
                    асд.изображение имени-типа(асд.ТЛог()), 
                    асд.изображение имени-типа(выр.Т^))
			}
		}
		кон.операторы(вариант.тело)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет^)
	}
}

//== оператор выбора по типу

фн (кон: Контроль) оператор выбора по типу(тек: асд.ОператорВыборПоТипу) {

	кон.выражение(тек.В)

    пусть т = асд.основа(тек.В.Т^)^

    если ~ (т типа асд.ТипКласс) {
		основа.добавить ошибку(тек.поз, "СЕМ-ВЫБОР-ТИП-КЛАССА", асд.изображение имени-типа(тек.В.Т^))
    }

	пусть тк = т(:асд.ТипКласс)

    цикл вариант среди тек.варианты {
        цикл тп среди вариант.типы {
            
			если ~ (асд.основа(тп) типа асд.ТипКласс) {
				основа.добавить ошибку(тп.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-КЛАССА", асд.изображение имени-типа(тп))
             } иначе {
                пусть класс-варианта = асд.основа(тп)^(:асд.ТипКласс)
                если класс-варианта # тк & ~ является расширением класса(тк, класс-варианта) {
					основа.добавить ошибку(тп.поз, "СЕМ-ДОЛЖЕН-БЫТЬ-НАСЛЕДНИКОМ", асд.изображение имени-типа(тп), асд.изображение имени-типа(т))
                }
             }
		}
		если вариант.переменная # пусто {
			если длина(вариант.типы) > 1 {
				основа.добавить ошибку(вариант.поз, "СЕМ-ВЫБОР-ОДИН-ТИП")
			}

			вариант.переменная^.Т := вариант.типы[0]
		}
        
		кон.операторы(вариант.тело)
	}
	если тек.если-нет # пусто {
		кон.операторы(тек.если-нет^)
	}
}

//====

фн завершающий оператор(блок: асд.СписокОператоров): Лог {
	если длина(блок.операторы) = 0 {
		вернуть ложь
	}
	пусть последний = блок.операторы[длина(блок.операторы)-1]
    
	выбор тип последний {
	когда асд.ОператорВернуть, асд.ОператорПрервать, асд.ОператорАвария:
		вернуть истина
	другое
		вернуть ложь
	}
}
