модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/лексер"

//== выражения

фн (кон: Контроль) выражение(выр: асд.Выражение) {

    выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
        если тек.объект типа асд.УказТипа {
			основа.добавить ошибку(тек.поз, "СЕМ-ТИП-В-ВЫРАЖЕНИИ")
			тек.Т := асд.ТипОшибочный{поз: тек.поз}
			вернуть
		}

		тек.Т := тек.объект^(:асд.Описание).Т

		если ~ (тек.объект типа асд.ОписаниеПеременной) {
			тек.только-чтение := истина
		}

	когда асд.УнарнаяОперация:
		кон.выражение(тек.Л)
		кон.унарное выражение(тек)

	когда асд.БинарнаяОперация:
		кон.выражение(тек.Л)
		кон.выражение(тек.П)
		кон.бинарное выражение(тек)

	когда асд.ПроверкаТипа:
		кон.выражение(тек.Л)
		кон.проверка-типа(тек)

	когда асд.Доступ:
		кон.доступ(тек)

	когда асд.Вызов:
		если тек.стд-функция # пусто {
//!			кон.вызов стандартной функции(тек)
			вернуть
		}
//!		кон.вызов(тек)

	когда асд.Развернуть:
		основа.добавить ошибку(тек.поз, "СЕМ-РАЗВОРАЧИВАНИЕ-ТОЛЬКО-ВАРИАДИК")
		тек.Т := асд.ТипОшибочный{поз: тек.поз}

	когда асд.Преобразовать:
/*!    
		если x.Caution {
			кон.cautionCast(()
		} иначе {
			кон.conversion(()
		}
*/
	когда асд.ПодтверждениеТипа:
		кон.подтверждение-типа(тек)

	когда асд.ИндексацияИлиКомпозит:
		кон.индексация или композит(тек)

	когда асд.КомпозитКласса:
		кон.конструктор класса(тек)

	когда асд.Литерал:
		выбор тек.вид {
		когда асд.Лит-Цел:
			тек.Т := асд.ТЦел64()
		когда асд.Лит-Слово:
			тек.Т := асд.ТСлово64()
		когда асд.Лит-Вещ:
			тек.Т := асд.ТВещ64()
		когда асд.Лит-Строка:
			тек.Т := асд.ТСтрока()
		когда асд.Лит-Символ:
			тек.Т := асд.ТСимвол()
		другое
			авария(строки.ф("неверный вид литерала: ni $;", тек))
		}
		тек.только-чтение := истина
	когда асд.ЛогЛитерал:
		тек.Т := асд.ТЛог()
		тек.только-чтение := истина
	другое
		авария(строки.ф("необработанное выражение: $тип;", выр))
	}
}

фн (кон: Контроль) доступ(тек: асд.Доступ) {

	если тек.объект # пусто {	// это импортированный объект
		если тек.объект типа асд.УказТипа {
			основа.добавить ошибку(тек.поз, "СЕМ-ТИП-В-ВЫРАЖЕНИИ")
			тек.Т := асд.ТипОшибочный{поз: тек.поз}
		} иначе {
			тек.Т := тек.объект^(:асд.Описание).Т
		}
		вернуть
	}
	кон.выражение(тек.Л^)

	пусть т = тек.Л^.Т^

	выбор пусть ттек: тип асд.основа(т)^ {
	когда асд.ТипКласс:
        пусть эл = ттек.атрибуты.найти(тек.имя)
		если эл = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛОСЬ-ПОЛЕ-ИЛИ-МЕТОД", тек.имя)
		} иначе {
            пусть оп = эл^.значение
        
			если оп.владелец # пусто & оп.владелец^ # кон.мод & ~ оп.экспорт {
				основа.добавить ошибку(тек.поз, "СЕМ-НЕ-ЭКСПОРТИРОВАН", оп.имя, оп.владелец^.имя)
			}
			тек.Т := оп.Т
			тек.объект := оп
		}
	когда асд.ТипВектор:
		пусть метод = асд.найти метод векторов(тек.имя)
		если метод = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-НЕ-НАЙДЕН-МЕТОД-ВЕКТОРА", тек.имя)
			тек.стд-метод := асд.СтдФункция{
                поз: тек.поз, 
                имя: "",  // отметить ошибку
                метод?: истина}
		} иначе {
			тек.стд-метод := метод
			// тек.Т - не задан
			вернуть
		}
	другое
		// TODO: выдать отдельную ошибку, если пропущен "^"
		основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-КЛАССА", асд.изображение имени-типа(т))
		тек.Т := асд.ТипОшибочный{поз: тек.Л^.поз} 
		вернуть
	}

	если тек.Т = пусто {
		тек.Т := асд.ТипОшибочный{поз: тек.Л^.поз}
	}
}

фн (кон: Контроль) подтверждение-типа(тек: асд.ПодтверждениеТипа) {

	кон.выражение(тек.Л)

	пусть т= тек.Л.Т^
	если ~ асд.тип-мб?(т) {
		основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛСЯ-МБ-ТИП", асд.изображение имени-типа(т))
		тек.Т := асд.ТипОшибочный{поз: тек.поз}
		вернуть
	}

	тек.Т := асд.основа(т)^(:асд.ТипМБ).Т
}

//== индексация

фн (кон: Контроль) индексация или композит(тек: асд.ИндексацияИлиКомпозит) {

    // если композит?
	пусть т := кон. типовое выражение(тек.Л)
	если т # пусто | похоже на композит вектора(тек.композит) {
		кон.конструктор вектора(тек.композит, т)

		если т = пусто { // ошибка уже выдана конструктором вектора
			т := асд.ТипОшибочный{поз: тек.Л.поз}
		}
		тек.Т := т
		//тек.Л = пусто
		вернуть
	}

	// это индексация
	кон.выражение(тек.Л)

	пусть т-вектора = тек.Л.Т^

	если ~ асд.индексируемый тип?(т-вектора) {
		основа.добавить ошибку(тек.Л.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-МАССИВА", асд.изображение имени-типа(т-вектора))
		тек.Т := асд.ТипОшибочный{поз: тек.поз}
	} иначе {
        пусть индекс = тек.композит.значения[0]
		тек.индекс := индекс
		кон.выражение(индекс)
		если ~ асд.целочисленный тип?(индекс.Т^) {
			основа.добавить ошибку(индекс.поз, "СЕМ-ОШ-ТИП-ИНДЕКСА", асд.изображение имени-типа(индекс.Т^))
		}
		тек.Т := асд.тип-элемента(т-вектора)
		если асд.полиморфный тип?(тек.Т^) {
			тек.Т := асд.ТипТегСлово()
		}

		если асд.вариативный тип?(т-вектора) {
			тек.только-чтение := истина
		}
	}

	если тек.Л.только-чтение | асд.строка8?(т-вектора) {
		тек.только-чтение := истина
	}
}

фн похоже на композит вектора(тек: асд.КомпозитВектора): Лог {
	вернуть тек.размер # пусто | тек.резерв # пусто | тек.умолчание # пусто |
		длина(тек.индексы) > 0 |
		длина(тек.значения) # 1
}

фн (кон: Контроль) унарное выражение(тек: асд.УнарнаяОперация) {

	выбор тек.операция {
	когда лексер.ВЫЧЕСТЬ:
		пусть т = тек.Л.Т^
		если асд.цел64?(т) | асд.слово64?(т) | асд.вещ64?(т) {
			// ok
		} иначе {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(т), лексер.для показа(тек.операция))
		}
		тек.Т := т
	когда лексер.БИТ-НЕ:
		пусть т = тек.Л.Т^
		если асд.целочисленный тип?(т) {
			// ok
		} иначе {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(т), лексер.для показа(тек.операция))
		}
		тек.Т := т
	когда лексер.НЕ:
		пусть т = тек.Л.Т^
		если ~ асд.лог?(т) {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.изображение имени-типа(т), лексер.для показа(тек.операция))
		}
		тек.Т := асд.ТЛог()

	другое
		авария(строки.ф("унарное выражение - необработанная операция: %s", лексер.для показа(тек.операция)))
	} 
}

фн (кон: Контроль) бинарное выражение(тек: асд.БинарнаяОперация) {
/*
	выбор тек.операция {
	когда лексер.ADD, лексер.ВЫЧЕСТЬ, лексер.MUL, лексер.REM, лексер.QUO:
		пусть t = тек.Л.Т
		если асд.цел64?(t) | асд.слово64?(t) | асд.вещ64?(t) {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(t), лексер.для показа(тек.операция))
		}
		тек.Т = t
	когда лексер.AND, лексер.OR:
		если ~асд.лог?(тек.Л.Т) {
			addErrorForType(тек.Л.Т, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция))
		} иначе если ~асд.лог?(тек.П.GetType()) {
			addErrorForType(тек.П.GetType(), тек.П.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(тек.П.GetType()), лексер.для показа(тек.операция))
		}
		тек.Т = асд.ТЛог()

	когда лексер.BITAND, лексер.BITOR, лексер.BITXOR:
		пусть t = тек.Л.Т
		если асд.цел64?(t) | асд.слово64?(t) | ast.IsByte(t) {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(t), лексер.для показа(тек.операция))
		}
		тек.Т = t

	когда лексер.SHL, лексер.SHR:
		пусть t = тек.Л.Т
		если ~асд.целочисленный тип?(t) {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(t), лексер.для показа(тек.операция))
		}
		пусть t2 = тек.П.GetType()
		если ~асд.целочисленный тип?(t2) {
			addErrorForType(t2, тек.П.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(t2), лексер.для показа(тек.операция))
		}
		тек.Т = t

	когда лексер.EQ, лексер.NEQ:
		пусть t = асд.основа(тек.Л.Т)
		если t = асд.ТБайт() | t = асд.ТЦел64() | t = асд.ТВещ64() | t = асд.ТСлово64() |
			t = асд.ТСимвол() | t = асд.ТСтрока() | t = асд.ТЛог() {
			checkOperandTypes(x)
		} иначе если асд.тип-класса?(t) {
			checkClassOperands(x)
		} иначе если асд.тип-мб?(t) {
			checkMayBeOperands(x)
		} иначе {
			addErrorForType(t, тек.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция))
		}

		тек.Т = асд.ТЛог()
	когда лексер.LSS, лексер.LEQ, лексер.GTR, лексер.GEQ:
		пусть t = асд.основа(тек.Л.Т)
		если t = асд.ТБайт() | t = асд.ТЦел64() | t = асд.ТВещ64() | t = асд.ТСлово64() | t = асд.ТСимвол() {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция))
		}
		тек.Т = асд.ТЛог()

	другое
		авария(строки.ф("binary expr ni: %T op=%s", x, лексер.для показа(тек.операция)))
	}
*/    
}

/*
фн checkOperandTypes(x асд.БинарнаяОперация) {
	если эквивалентные типы(тек.Л.Т, тек.П.GetType()) {
		вернуть
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция), асд.изображение имени-типа(тек.П.GetType()))

}

// Считаю, что "пусто" может быть только вторым операндом
фн checkClassOperands(x асд.БинарнаяОперация) {

	пусть l = асд.основа(тек.Л.Т).(асд.ТипКласс)
	r, ok := асд.основа(тек.П.GetType()).(асд.ТипКласс)

	если ok {
		если l = r | isDerivedClass(l, r) | isDerivedClass(r, l) {
			вернуть
		}
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция), асд.изображение имени-типа(тек.П.GetType()))
}

// Считаю, что "пусто" может быть только вторым операндом
фн checkMayBeOperands(x асд.БинарнаяОперация) {

	пусть l = асд.основа(тек.Л.Т).(асд.ТипМБ)
	пусть r = асд.основа(тек.П.GetType())

	если r = ast.NullType {
		вернуть
	} иначе если rmb, ok := r.(асд.ТипМБ); ok & эквивалентные типы(l.Typ, rmb.Typ) {
		вернуть
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), лексер.для показа(тек.операция), асд.изображение имени-типа(тек.П.GetType()))

}
*/

фн (кон: Контроль) проверка-типа(тек: асд.ПроверкаТипа) {
/*
	тек.Т = асд.ТЛог()

	пусть t = тек.Л.Т
	maybe, ok := асд.основа(t).(асд.ТипМБ)
	если ok {
		t = maybe.Typ
	}

	cl, ok := асд.основа(t).(асд.ТипКласс)
	если ~ok {
		основа.добавить ошибку(тек.Л.поз, "СЕМ-ОПЕРАЦИЯ-ТИПА", асд.изображение имени-типа(тек.Л.Т))
		вернуть
	}

	target, ok := асд.основа(x.TargetTyp).(асд.ТипКласс)
	если ~ok {
		основа.добавить ошибку(x.TargetTyp.поз, "СЕМ-ОПЕРАЦИЯ-ТИПА", асд.изображение имени-типа(x.TargetTyp))
		вернуть
	}

	если ~isDerivedClass(cl, target) {
		основа.добавить ошибку(тек.поз, "СЕМ-ДОЛЖЕН-БЫТЬ-НАСЛЕДНИКОМ", асд.изображение имени-типа(x.TargetTyp), асд.изображение имени-типа(t))
	}
*/    
}

//==== вспомогательные

фн литерал(выр: асд.Выражение): мб асд.Литерал {

	выбор пусть тек: тип выр {
	когда асд.Литерал:
		вернуть тек
	когда асд.Преобразовать:
		если тек.сделано {
			вернуть литерал(тек.Л)
		}
	}
	вернуть пусто
}

фн может быть левой частью(выр: асд.Выражение): Лог {

	если выр.только-чтение {
		вернуть ложь
	}

	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
        надо тек.объект^ типа асд.ОписаниеПеременной иначе вернуть ложь
        вернуть ~ тек.объект^(:асд.ОписаниеПеременной).одно-присваивание
	когда асд.ИндексацияИлиКомпозит:
		вернуть тек.индекс # пусто
	когда асд.Доступ:
        надо тек.объект^ типа асд.Поле иначе вернуть истина
        вернуть ~ тек.объект^(:асд.Поле).одно-присваивание
	когда асд.Преобразовать:
		вернуть может быть левой частью(тек.Л)
	другое
		вернуть ложь
	}
}

фн (кон: Контроль) проверить левую часть присваивания(выр: асд.Выражение) {
	если может быть левой частью(выр) {
		вернуть
	}
	основа.добавить ошибку(выр.поз, "СЕМ-НЕ-ПРИСВОИТЬ")
}
