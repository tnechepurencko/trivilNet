модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"

//== выражения

фн (кон: Контроль) выражение(выр: асд.Выражение) {

    выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
        если тек.объект типа асд.УказТипа {
			основа.добавить ошибку(тек.поз, "СЕМ-ТИП-В-ВЫРАЖЕНИИ")
			тек.Т := асд.ТипОшибочный{поз: тек.поз}
			вернуть
		}

		тек.Т := тек.объект^(:асд.Описание).Т

		если ~ (тек.объект типа асд.ОписаниеПеременной) {
			тек.только-чтение := истина
		}

	когда асд.УнарнаяОперация:
		кон.выражение(тек.Л)
		кон.унарное выражение(тек)

	когда асд.БинарнаяОперация:
		кон.выражение(тек.Л)
		кон.выражение(тек.П)
		кон.бинарное выражение(тек)

	когда асд.ПроверкаТипа:
		кон.выражение(тек.Л)
		кон.проверка-типа(тек)

	когда асд.Доступ:
		кон.доступ(тек)

	когда асд.Вызов:
		если тек.стд-функция # пусто {
//!			кон.вызов стандартной функции(тек)
			вернуть
		}
//!		кон.вызов(тек)

	когда асд.Развернуть:
		основа.добавить ошибку(тек.поз, "СЕМ-РАЗВОРАЧИВАНИЕ-ТОЛЬКО-ВАРИАДИК")
		тек.Т := асд.ТипОшибочный{поз: тек.поз}

	когда асд.Преобразовать:
/*!    
		если x.Caution {
			кон.cautionCast(()
		} иначе {
			кон.conversion(()
		}
*/
	когда асд.ПодтверждениеТипа:
		кон.подтверждение-типа(тек)

	когда асд.ИндексацияИлиКомпозит:
		кон.индексация или композит(тек)

	когда асд.КомпозитКласса:
		кон.конструктор класса(тек)

	когда асд.Литерал:
		выбор тек.вид {
		когда асд.Лит-Цел:
			тек.Т := асд.ТЦел64()
		когда асд.Лит-Слово:
			тек.Т := асд.ТСлово64()
		когда асд.Лит-Вещ:
			тек.Т := асд.ТВещ64()
		когда асд.Лит-Строка:
			тек.Т := асд.ТСтрока()
		когда асд.Лит-Символ:
			тек.Т := асд.ТСимвол()
		другое
			авария(строки.ф("неверный вид литерала: ni $;", тек))
		}
		тек.только-чтение := истина
	когда асд.ЛогЛитерал:
		тек.Т := асд.ТЛог()
		тек.только-чтение := истина
	другое
		авария(строки.ф("необработанное выражение: $тип;", выр))
	}
}

фн (кон: Контроль) доступ(тек: асд.Доступ) {
/*
	если x.Obj # пусто {
		// импортed object
		если _, ok := x.Obj.(асд.УказТипа); ok {
			основа.добавить ошибку(тек.поз, "СЕМ-ТИП-В-ВЫРАЖЕНИИ")
			тек.Т = ast.MakeInvalidType(тек.поз)
		} иначе {
			тек.Т = x.Obj.(асд.Описание).GetType()
		}
		вернуть
	}
	кон.выражение(тек.Л)

	пусть t = тек.Л.Т

	выбор xt := асд.основа(t).(type) {
	когда асд.ТипКласс:
		d, ok := xt.Members[x.Name]
		если ~ok {
			основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛОСЬ-ПОЛЕ-ИЛИ-МЕТОД", x.Name)
		} иначе {
			если d.GetHost() # кон.module & ~d.IsExported() {
				основа.добавить ошибку(тек.поз, "СЕМ-НЕ-ЭКСПОРТИРОВАН", d.GetName(), d.GetHost().Name)
			}
			тек.Т = d.GetType()
			x.Obj = d
		}
	когда асд.ТипВектор:
		пусть m = ast.VectorMethod(x.Name)
		если m = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-НЕ-НАЙДЕН-МЕТОД-ВЕКТОРА", x.Name)
			x.StdMethod = &ast.StdFunction{Method: истина}
			x.StdMethod.Name = "" // отметить ошибку
		} иначе {
			x.StdMethod = m
			// тек.Т - не задан
			вернуть
		}
	другое
		// TODO: выдать отдельную ошибку, если пропущен "^"
		основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-КЛАССА", асд.изображение имени-типа(t))
		тек.Т = ast.MakeInvalidType(тек.Л.поз)
		вернуть
	}

	если тек.Т = пусто {
		тек.Т = ast.MakeInvalidType(тек.Л.поз)
	}
*/    
}

фн (кон: Контроль) подтверждение-типа(тек: асд.ПодтверждениеТипа) {
/*
	кон.выражение(тек.Л)

	пусть t = тек.Л.Т
	maybe, ok := асд.основа(t).(асд.ТипМБ)
	если ~ok {
		основа.добавить ошибку(тек.поз, "СЕМ-ОЖИДАЛСЯ-МБ-ТИП", асд.изображение имени-типа(t))
		тек.Т = ast.MakeInvalidType(тек.поз)
		вернуть
	}
	тек.Т = maybe.Typ
*/    
}

//== индексация

фн (кон: Контроль) индексация или композит(тек: асд.ИндексацияИлиКомпозит) {
/*
	пусть t = кон.typeExpr(тек.Л)

	если t # пусто | похоже на композит вектора(x.Composite) {
		кон.arrayComposite(x.Composite, t)

		если t = пусто {
			t = ast.MakeInvalidType(тек.Л.поз)
		}
		тек.Т = t
		тек.Л = пусто
		вернуть
	}

	// это индексация
	кон.выражение(тек.Л)

	t = тек.Л.Т

	если ~асд.индексируемый тип?(t) {
		основа.добавить ошибку(тек.Л.поз, "СЕМ-ОЖИДАЛСЯ-ТИП-МАССИВА", асд.ТипString(t))
		тек.Т = ast.MakeInvalidType(тек.поз)
	} иначе {
		x.Index = x.Composite.Values[0]
		кон.выражение(x.Index)
		если ~асд.целочисленный тип?(x.Index.GetType()) {
			основа.добавить ошибку(x.Indeтек.поз, "СЕМ-ОШ-ТИП-ИНДЕКСА", асд.ТипString(x.Index.GetType()))
		}
		тек.Т = асд.тип-элемента(t)
		если асд.полиморфный тип?(тек.Т) {
			тек.Т = асд.ТипТегСлово()
		}

		если асд.вариативный тип?(t) {
			x.только-чтение = истина
		}
	}
	x.Composite = пусто

	если тек.Л.Isтолько-чтение() | асд.основа(t) = асд.ТСтрока()8 {
		x.только-чтение = истина
	}
*/    
}

фн похоже на композит вектора(тек: асд.КомпозитВектора): Лог {
	вернуть тек.размер # пусто | тек.резерв # пусто | тек.умолчание # пусто |
		длина(тек.индексы) > 0 |
		длина(тек.значения) # 1
}

фн (кон: Контроль) унарное выражение(тек: асд.УнарнаяОперация) {
/*
	выбор x.Op {
	когда lexer.SUB:
		пусть t = тек.Л.Т
		если ast.IsInt64(t) | ast.IsWord64(t) | ast.IsFloatType(t) {
			// ok
		} иначе {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.ТипString(тек.Л.Т), x.Op.String())
		}
		тек.Т = t
	когда lexer.BITNOT:
		пусть t = тек.Л.Т
		если асд.целочисленный тип?(t) {
			// ok
		} иначе {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.ТипString(тек.Л.Т), x.Op.String())
		}
		тек.Т = t
	когда lexer.NOT:
		если ~асд.лог?(тек.Л.Т) {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ОШ-УНАРНАЯ-ТИП",
				асд.ТипString(тек.Л.Т), x.Op.String())
		}
		тек.Т = асд.ТЛог()

	другое
		авария(строки.ф("unary expr ni: %T op=%s", x, x.Op.String()))
	}
*/    
}

фн (кон: Контроль) бинарное выражение(тек: асд.БинарнаяОперация) {
/*
	выбор x.Op {
	когда lexer.ADD, lexer.SUB, lexer.MUL, lexer.REM, lexer.QUO:
		пусть t = тек.Л.Т
		если ast.IsInt64(t) | ast.IsWord64(t) | ast.IsFloatType(t) {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(t), x.Op.String())
		}
		тек.Т = t
	когда lexer.AND, lexer.OR:
		если ~асд.лог?(тек.Л.Т) {
			addErrorForType(тек.Л.Т, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(тек.Л.Т), x.Op.String())
		} иначе если ~асд.лог?(тек.П.GetType()) {
			addErrorForType(тек.П.GetType(), тек.П.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(тек.П.GetType()), x.Op.String())
		}
		тек.Т = асд.ТЛог()

	когда lexer.BITAND, lexer.BITOR, lexer.BITXOR:
		пусть t = тек.Л.Т
		если ast.IsInt64(t) | ast.IsWord64(t) | ast.IsByte(t) {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(t), x.Op.String())
		}
		тек.Т = t

	когда lexer.SHL, lexer.SHR:
		пусть t = тек.Л.Т
		если ~асд.целочисленный тип?(t) {
			addErrorForType(t, тек.Л.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(t), x.Op.String())
		}
		пусть t2 = тек.П.GetType()
		если ~асд.целочисленный тип?(t2) {
			addErrorForType(t2, тек.П.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(t2), x.Op.String())
		}
		тек.Т = t

	когда lexer.EQ, lexer.NEQ:
		пусть t = асд.основа(тек.Л.Т)
		если t = асд.ТБайт() | t = асд.ТЦел64() | t = асд.ТВещ64() | t = асд.ТСлово64() |
			t = асд.ТСимвол() | t = асд.ТСтрока() | t = асд.ТЛог() {
			checkOperandTypes(x)
		} иначе если асд.тип-класса?(t) {
			checkClassOperands(x)
		} иначе если асд.тип-мб?(t) {
			checkMayBeOperands(x)
		} иначе {
			addErrorForType(t, тек.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(тек.Л.Т), x.Op.String())
		}

		тек.Т = асд.ТЛог()
	когда lexer.LSS, lexer.LEQ, lexer.GTR, lexer.GEQ:
		пусть t = асд.основа(тек.Л.Т)
		если t = асд.ТБайт() | t = асд.ТЦел64() | t = асд.ТВещ64() | t = асд.ТСлово64() | t = асд.ТСимвол() {
			checkOperandTypes(x)
		} иначе {
			addErrorForType(t, тек.поз, "СЕМ-ОШ-ТИП-ОПЕРАНДА",
				асд.ТипString(тек.Л.Т), x.Op.String())
		}
		тек.Т = асд.ТЛог()

	другое
		авария(строки.ф("binary expr ni: %T op=%s", x, x.Op.String()))
	}
*/    
}

/*
фн checkOperandTypes(x асд.БинарнаяОперация) {
	если эквивалентные типы(тек.Л.Т, тек.П.GetType()) {
		вернуть
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), x.Op.String(), асд.изображение имени-типа(тек.П.GetType()))

}

// Считаю, что "пусто" может быть только вторым операндом
фн checkClassOperands(x асд.БинарнаяОперация) {

	пусть l = асд.основа(тек.Л.Т).(асд.ТипКласс)
	r, ok := асд.основа(тек.П.GetType()).(асд.ТипКласс)

	если ok {
		если l = r | isDerivedClass(l, r) | isDerivedClass(r, l) {
			вернуть
		}
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), x.Op.String(), асд.изображение имени-типа(тек.П.GetType()))
}

// Считаю, что "пусто" может быть только вторым операндом
фн checkMayBeOperands(x асд.БинарнаяОперация) {

	пусть l = асд.основа(тек.Л.Т).(асд.ТипМБ)
	пусть r = асд.основа(тек.П.GetType())

	если r = ast.NullType {
		вернуть
	} иначе если rmb, ok := r.(асд.ТипМБ); ok & эквивалентные типы(l.Typ, rmb.Typ) {
		вернуть
	}
	основа.добавить ошибку(тек.поз, "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ",
		асд.изображение имени-типа(тек.Л.Т), x.Op.String(), асд.изображение имени-типа(тек.П.GetType()))

}
*/

фн (кон: Контроль) проверка-типа(тек: асд.ПроверкаТипа) {
/*
	тек.Т = асд.ТЛог()

	пусть t = тек.Л.Т
	maybe, ok := асд.основа(t).(асд.ТипМБ)
	если ok {
		t = maybe.Typ
	}

	cl, ok := асд.основа(t).(асд.ТипКласс)
	если ~ok {
		основа.добавить ошибку(тек.Л.поз, "СЕМ-ОПЕРАЦИЯ-ТИПА", асд.изображение имени-типа(тек.Л.Т))
		вернуть
	}

	target, ok := асд.основа(x.TargetTyp).(асд.ТипКласс)
	если ~ok {
		основа.добавить ошибку(x.TargetTyp.поз, "СЕМ-ОПЕРАЦИЯ-ТИПА", асд.изображение имени-типа(x.TargetTyp))
		вернуть
	}

	если ~isDerivedClass(cl, target) {
		основа.добавить ошибку(тек.поз, "СЕМ-ДОЛЖЕН-БЫТЬ-НАСЛЕДНИКОМ", асд.изображение имени-типа(x.TargetTyp), асд.изображение имени-типа(t))
	}
*/    
}

//==== вспомогательные

фн литерал(выр: асд.Выражение): мб асд.Литерал {

	выбор пусть тек: тип выр {
	когда асд.Литерал:
		вернуть тек
	когда асд.Преобразовать:
		если тек.сделано {
			вернуть литерал(тек.Л)
		}
	}
	вернуть пусто
}

фн может быть левой частью(выр: асд.Выражение): Лог {

	если выр.только-чтение {
		вернуть ложь
	}

	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
        надо тек.объект^ типа асд.ОписаниеПеременной иначе вернуть ложь
        вернуть ~ тек.объект^(:асд.ОписаниеПеременной).одно-присваивание
	когда асд.ИндексацияИлиКомпозит:
		вернуть тек.индекс # пусто
	когда асд.Доступ:
        надо тек.объект^ типа асд.Поле иначе вернуть истина
        вернуть ~ тек.объект^(:асд.Поле).одно-присваивание
	когда асд.Преобразовать:
		вернуть может быть левой частью(тек.Л)
	другое
		вернуть ложь
	}
}

фн (кон: Контроль) проверить левую часть присваивания(выр: асд.Выражение) {
	если может быть левой частью(выр) {
		вернуть
	}
	основа.добавить ошибку(выр.поз, "СЕМ-НЕ-ПРИСВОИТЬ")
}
