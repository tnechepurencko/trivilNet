модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/семантика/словарь-описаний"


тип Контроль = класс {
	мод: асд.Модуль = позже
	
    описание-проверено = словарь-описаний.Словарь{} // map[Описание]Лог
    
	Т-вернуть: мб асд.Тип := пусто
    уровень-цикла := 0
}

фн обработать*(мод: асд.Модуль) {

	пусть кон = Контроль{
		мод: мод,
	}

    цикл оп среди мод.описания {
		выбор пусть тек: тип оп {
		когда асд.ОписаниеТипа:
			кон.описание-типа(тек)
		когда асд.ОписаниеПеременной:
			кон.описание переменной(тек)
		когда асд.ОписаниеКонстанты:
			кон.описание константы(тек)
		когда асд.Функция:
			// дальше
		другое
            авария(строки.ф("неизвестное описание: $тип;", оп)) 
		}
	}

	// обойти функции
    цикл оп среди мод.описания {
        если оп типа асд.Функция {
			кон.функция(оп(:асд.Функция))
		}
	}

	если мод.вход? # пусто {
		кон.вход!(мод.вход?^)
	}
}

//== константы и переменные

фн (кон: Контроль) описание переменной(тек: асд.ОписаниеПеременной) {

	если тек.задать-позже {
		если тек.Т = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ДЛЯ-ПОЗЖЕ-НУЖЕН-ТИП")
		}
		если тек.владелец = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ПОЗЖЕ-ЛОК-ПЕРЕМЕННАЯ")
		}
	} иначе {
		кон.выражение(тек.значение^)

		если тек.Т # пусто {
			кон.проверить совместимость по присваиванию(тек.Т^, тек.значение^)
		} иначе {
			тек.Т := тек.значение^.Т
			если тек.Т = пусто {
				авария(строки.ф("assert - не задан тип переменной $;", основа.позиция для показа(тек.поз)))
			}

			если асд.тип-нет значения?(тек.Т^) {
				основа.добавить ошибку(тек.поз, "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
				вернуть
			}
			если асд.полиморфный тип?(тек.Т^) {
				основа.добавить ошибку(тек.поз, "СЕМ-СОХРАНЕНИЕ-ПОЛИМОРФНОГО")
				вернуть
			}
		}
	}
 }

фн (кон: Контроль) описание константы(тек: асд.ОписаниеКонстанты) {

	кон.выражение(тек.значение^)

	если тек.Т # пусто {
		кон.проверить совместимость по присваиванию(тек.Т^, тек.значение^)
	} иначе {
		тек.Т := тек.значение^.Т
		если тек.Т = пусто {
            авария(строки.ф("assert - не задан тип константы $;", основа.позиция для показа(тек.поз))        )    
		}
		если асд.тип-нет значения?(тек.Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
			вернуть
		}
	}
	кон.проверить константное выражение(тек.значение^)
}

//==== функции

фн (кон: Контроль) функция(тек: асд.Функция) {

	пусть тф = тек.Т(:асд.ТипФункция)

	пусть вариа = асд.ВариативныйПараметр(тф)
	если вариа # пусто & вариа^.выходной {
		основа.добавить ошибку(вариа^.поз, "СЕМ-ВАРИАТИВНЫЙ-ВЫХОДНОЙ")
	}

	если тек.тело # пусто {
		кон.Т-вернуть := тф.Т-вернуть

		кон.уровень-цикла := 0
		кон.операторы(тек.тело^)

		если кон.Т-вернуть # пусто {
			если ~кон.есть возврат из списка(тек.тело^) {
				основа.добавить ошибку(тек.поз, "СЕМ-НЕТ-ВЕРНУТЬ")
			}
		}
		кон.Т-вернуть := пусто
	}
}

//== проверка наличия "вернуть"

фн (кон: Контроль) есть возврат из списка(блок: асд.СписокОператоров): Лог {
	если длина(блок.операторы) = 0 {
		вернуть ложь
	}
	пусть последний = блок.операторы[длина(блок.операторы)-1]
    
	выбор пусть тек: тип последний {
	когда асд.ОператорВернуть:
		вернуть истина
	когда асд.ОператорНадо:
		вернуть истина
	когда асд.ОператорАвария:
		вернуть истина
	когда асд.ОператорЕсли:
		вернуть кон.есть возврат из условного(тек)
	когда асд.ОператорВыбор:
		вернуть кон.есть возврат из выбора(тек)
	когда асд.ОператорВыборПоТипу:
		вернуть кон.есть возврат из выбора по типу(тек)
	другое
		вернуть ложь
	}
}

фн (кон: Контроль) есть возврат из условного(тек: асд.ОператорЕсли): Лог {
	если ~кон.есть возврат из списка(тек.если-да) {
		вернуть ложь
	}
	если тек.если-нет = пусто {
		вернуть ложь
	}
	если тек.если-нет типа асд.ОператорЕсли {
		вернуть кон.есть возврат из условного(тек.если-нет(:асд.ОператорЕсли))
	}
	вернуть кон.есть возврат из списка(тек.если-нет(:асд.СписокОператоров))
}

фн (кон: Контроль) есть возврат из выбора(тек: асд.ОператорВыбор): Лог {
	если тек.если-нет = пусто | ~кон.есть возврат из списка(тек.если-нет^) {
		вернуть ложь
	}

    цикл вариант среди тек.варианты {
		если ~кон.есть возврат из списка(вариант.тело) {
			вернуть ложь
		}
	}
	вернуть истина
}

фн (кон: Контроль) есть возврат из выбора по типу(тек: асд.ОператорВыборПоТипу): Лог {
	если тек.если-нет = пусто | ~кон.есть возврат из списка(тек.если-нет^) {
		вернуть ложь
	}

    цикл вариант среди тек.варианты {
		если ~кон.есть возврат из списка(вариант.тело) {
			вернуть ложь
		}
	}
	вернуть истина
}

