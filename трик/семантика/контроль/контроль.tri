модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/семантика/словарь-описаний"


тип Контроль = класс {
	мод: асд.Модуль = позже
	
    описание-проверено = словарь-описаний.Словарь{} // map[Описание]Лог
    
	Т-вернуть: мб асд.Тип := пусто
    уровень-цикла := 0
}

фн обработать*(мод: асд.Модуль) {

	пусть кон = Контроль{
		мод: мод,
	}

    цикл оп среди мод.описания {
		выбор пусть тек: тип оп {
		когда асд.ОписаниеТипа:
			кон.описание-типа(тек)
		когда асд.ОписаниеПеременной:
			кон.описание переменной(тек)
		когда асд.ОписаниеКонстанты:
			кон.описание константы(тек)
		когда асд.Функция:
			// дальше
		другое
            авария(строки.ф("неизвестное описание: $тип;", оп)) 
		}
	}

	// обойти функции
    цикл оп среди мод.описания {
        если оп типа асд.Функция {
			кон.функция(оп(:асд.Функция))
		}
	}

	если мод.вход? # пусто {
		кон.вход!(мод.вход?^)
	}
}

//== константы и переменные

фн (кон: Контроль) описание переменной(тек: асд.ОписаниеПеременной) {
/*
	если тек.задать-позже {
		если тек.Т = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ДЛЯ-ПОЗЖЕ-НУЖЕН-ТИП")
		}
		если тек.владелец = пусто {
			основа.добавить ошибку(тек.поз, "СЕМ-ПОЗЖЕ-ЛОК-ПЕРЕМЕННАЯ")
		}
	} иначе {
		кон.выражение(тек.значение^)

		если тек.Т # пусто {
			кон.проверить совместимость по присваиванию(тек.Т, тек.значение)
		} иначе {
			тек.Т = тек.значение.Т
			если тек.Т = пусто {
				авария(строки.ф("assert - не задан тип переменной $;", основа.позиция для показа(тек.поз)))
			}

			если асд.тип-нет значения?(тек.Т) {
				основа.добавить ошибку(тек.поз, "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
				вернуть
			}
			если асд.полиморфный тип?(тек.Т) {
				основа.добавить ошибку(тек.поз, "СЕМ-СОХРАНЕНИЕ-ПОЛИМОРФНОГО")
				вернуть
			}
		}
	}
*/    
}

фн (кон: Контроль) описание константы(тек: асд.ОписаниеКонстанты) {
/*
	кон.выражение(тек.значение)

	если тек.Т # пусто {
		кон.проверить совместимость по присваиванию(тек.Т, тек.значение)
	} иначе {
		тек.Т = тек.значение.Т
		если тек.Т = пусто {
            авария(строки.ф("assert - не задан тип константы $;", основа.позиция для показа(тек.поз))        )    
		}
		если асд.тип-нет значения?(тек.Т) {
			основа.добавить ошибку(тек.поз, "СЕМ-ФН-НЕТ-ЗНАЧЕНИЯ")
			вернуть
		}
	}
	кон.проверить константное выражение(тек.значение)
*/    
}

//==== функции

фн (кон: Контроль) функция(тек: асд.Функция) {

	пусть тф = тек.Т^(:асд.ТипФункция)

	пусть вариа = асд.ВариативныйПараметр(тф)
	если вариа # пусто & вариа^.выходной {
		основа.добавить ошибку(вариа^.поз, "СЕМ-ВАРИАТИВНЫЙ-ВЫХОДНОЙ")
	}

	если тек.тело # пусто {
		кон.Т-вернуть := тф.Т-вернуть

		кон.уровень-цикла := 0
		кон.операторы(тек.тело^)

/*
		если кон.вернутьTyp # пусто {
			если ~кон.seqHasвернуть(f.Seq) {
				основа.добавить ошибку(f.поз, "СЕМ-НЕТ-ВЕРНУТЬ")
			}
		}
*/
		кон.Т-вернуть := пусто
	}
}

//== проверка наличия "вернуть"
/*
фн (кон: Контроль) seqHasвернуть(s асд.СписокОператоров) Лог {
	если длина(s.Statements) = 0 {
		вернуть ложь
	}
	пусть last = s.Statements[len(s.Statements)-1]
	выбор x := lасд.(type) {
	когда асд.ОператорВернуть:
		вернуть истина
	когда асд.ОператорНадо:
		вернуть истина
	когда асд.ОператорАвария:
		вернуть истина
	когда асд.ОператорЕсли:
		вернуть кон.ifHasвернуть(x)
	когда асд.ОператорВыбор:
		вернуть кон.selectHasвернуть(x)
	когда асд.ОператорВыборType:
		вернуть кон.selectTypeHasвернуть(x)
	другое
		вернуть ложь
	}
}

фн (кон: Контроль) ifHasвернуть(x асд.ОператорЕсли) Лог {
	если ~кон.seqHasвернуть(x.если-да) {
		вернуть ложь
	}
	если x.если-нет = пусто {
		вернуть ложь
	}
	если elsif, ok := x.если-нет.(асд.ОператорЕсли); ok {
		вернуть кон.ifHasвернуть(elsif)
	}
	вернуть кон.seqHasвернуть(x.если-нет.(асд.СписокОператоров))
}

фн (кон: Контроль) selectHasвернуть(x асд.ОператорВыбор) Лог {
	если x.если-нет = пусто | ~кон.seqHasвернуть(x.если-нет) {
		вернуть ложь
	}

	пока _, c := range x.Cases {
		если ~кон.seqHasвернуть(c.Seq) {
			вернуть ложь
		}
	}

	вернуть истина
}

фн (кон: Контроль) selectTypeHasвернуть(x асд.ОператорВыборType) Лог {
	если x.если-нет = пусто | ~кон.seqHasвернуть(x.если-нет) {
		вернуть ложь
	}

	пока _, c := range x.Cases {
		если ~кон.seqHasвернуть(c.Seq) {
			вернуть ложь
		}
	}

	вернуть истина
}

*/