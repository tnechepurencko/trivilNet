модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"

фн (кон: Контроль) вызов(тек: асд.Вызов) {
	кон.выражение(тек.Л)

	если тек.Л типа асд.Доступ {
        пусть доступ = тек.Л(:асд.Доступ)
        если доступ.стд-метод # пусто {
            тек.стд-функция := доступ.стд-метод
            тек.стд-метод-Л := доступ.Л // убираю лишний Доступ
            кон.вызов стандартной функции(тек)
            вернуть
        }    
	}

	если ~ (тек.Л.Т типа асд.ТипФункция) {

		если ~асд.ошибочный тип?(тек.Л.Т^) {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ВЫЗОВ-НЕ-ФУНКТИП", асд.изображение-типа(тек.Л.Т))
		}
        тек.Т := асд.ТипОшибочный{поз: тек.Л.поз}
		вернуть
	}

	пусть тф = тек.Л.Т(:асд.ТипФункция)


	если тф.Т-вернуть = пусто {
		тек.Т := асд.ТипНетЗначения()
	} иначе {
		тек.Т := тф.Т-вернуть
	}

	пусть вар-пар = асд.ВариативныйПараметр(тф)
	пусть число-нормальных := длина(тф.параметры)

	если вар-пар = пусто {
		если длина(тек.аргументы) # число-нормальных {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ЧИСЛО-АРГУМЕНТОВ", длина(тек.аргументы), число-нормальных)
			вернуть
		}
	} иначе {
		число-нормальных--
		если длина(тек.аргументы) < число-нормальных {
			основа.добавить ошибку(тек.Л.поз, "СЕМ-ВАРИАДИК-ЧИСЛО-АРГУМЕНТОВ", число-нормальных, длина(тек.аргументы))
			вернуть
		}
	}

    пусть № := 0
	пока № < число-нормальных {
		пусть пар = тф.параметры[№]
		кон.выражение(тек.аргументы[№])
		если пар.выходной {
			если ~эквивалентные типы(пар.Т, тек.аргументы[№].Т) {
				основа.добавить ошибку(тек.аргументы[№].поз, "СЕМ-ВЫХОДНОй-ТИПЫ-НЕ-РАВНЫ")
			}
			кон.проверить левую часть присваивания(тек.аргументы[№])
		} иначе {
			кон.проверить совместимость по присваиванию(пар.Т^, тек.аргументы[№])
		}
        №++
	}

    надо вар-пар # пусто иначе вернуть

	пусть вар-Т = вар-пар^.Т(:асд.ТипВариативный)
	если кон.проверить разворачивание(тек.аргументы, число-нормальных, вар-Т.Т-элемента) {
		// проверено
	} иначе {
        пусть № := число-нормальных
		пока № < длина(тек.аргументы) {
			кон.выражение(тек.аргументы[№])
			кон.проверить совместимость по присваиванию(вар-Т.Т-элемента, тек.аргументы[№])
            №++
		}
	}
 }

фн (кон: Контроль) проверить разворачивание(аргументы: асд.Выражения, начало: Цел64, Т-элемента: асд.Тип): Лог {

    пусть № := начало
	пока № < длина(аргументы) {
    
		если аргументы[№] типа асд.Развернуть {
        
            пусть раз = аргументы[№](:асд.Развернуть)

			кон.выражение(раз.Л)

			если № # начало | длина(аргументы) - начало > 1 {
				основа.добавить ошибку(раз.поз, "СЕМ-ОДНО-РАЗВОРАЧИВАНИЕ")
			}
            
            выбор пусть т: тип асд.основа(раз.Л.Т)^ {
			когда асд.ТипВектор:
				если ~эквивалентные типы(Т-элемента, т.Т-элемента) {
					основа.добавить ошибку(раз.поз, "СЕМ-ТИПЫ-ЭЛЕМЕНТОВ-НЕ-СОВПАДАЮТ",
						асд.изображение-типа(Т-элемента), асд.изображение-типа(т.Т-элемента))
				}
			когда асд.ТипВариативный:
				если ~эквивалентные типы(Т-элемента, т.Т-элемента) {
					основа.добавить ошибку(раз.поз, "СЕМ-ТИПЫ-ЭЛЕМЕНТОВ-НЕ-СОВПАДАЮТ",
						асд.изображение-типа(Т-элемента), асд.изображение-типа(т.Т-элемента))
				}
			другое
				если асд.строка8?(раз.Л.Т^) {
					если ~эквивалентные типы(Т-элемента, асд.ТБайт()) {
						основа.добавить ошибку(раз.поз, "СЕМ-ТИПЫ-ЭЛЕМЕНТОВ-НЕ-СОВПАДАЮТ",
							асд.изображение-типа(Т-элемента), асд.ТБайт().имя)
					}
				} иначе {
					основа.добавить ошибку(раз.поз, "СЕМ-ОШ-ТИП-РАЗВЕРНУТЬ", асд.изображение-типа(раз.Л.Т))
				}
			}
			вернуть истина
		}
        №++
	}

	вернуть ложь
}

//== стд. функции

фн (кон: Контроль) вызов стандартной функции(тек: асд.Вызов) {

	выбор тек.стд-функция^.имя {
	когда "":
    	тек.Т := асд.ТипОшибочный{поз: тек.поз}
		вернуть
	когда асд.СтдДлина:
		кон.вызов стд длина(тек)
	когда асд.СтдТег:
		кон.вызов стд тег(тек)
	когда асд.СтдНечто:
		кон.вызов стд нечто(тек)

	когда асд.ВекторДобавить:
		кон.вызов вектор-добавить(тек)

	другое
    	авария(строки.ф("необработанная стандартная функция: $;", тек.стд-функция^.имя))
	}
}


фн (кон: Контроль) вызов стд длина(тек: асд.Вызов) {
	тек.Т := асд.ТЦел64()

	если длина(тек.аргументы) # 1 {
		основа.добавить ошибку(тек.поз, "СЕМ-СТДФУНК-ОШ-ЧИСЛО-АРГ", тек.стд-функция^.имя, "1")
		вернуть
	}

	кон.выражение(тек.аргументы[0])

	пусть т = асд.основа(тек.аргументы[0].Т)^

	если асд.индексируемый тип?(т) | асд.строка?(т) {
		// ok
	} иначе {
		основа.добавить ошибку(тек.поз, "СЕМ-СТД-ДЛИНА-ОШ-ТИП-АРГ", тек.стд-функция^.имя)
	}
}

фн (кон: Контроль) вызов стд тег(тек: асд.Вызов) {
	тек.Т := асд.ТСлово64()

	если длина(тек.аргументы) # 1 {
		основа.добавить ошибку(тек.поз, "СЕМ-СТДФУНК-ОШ-ЧИСЛО-АРГ", тек.стд-функция^.имя, "1")
		вернуть
	}

	пусть т = кон.типовое выражение(тек.аргументы[0])

	если т # пусто {
		пусть пред = тек.аргументы[0]
		тек.аргументы[0] := асд.ОперандТип{
			поз: пред.поз, 
            Т: т, 
            только-чтение: истина,
		}
	} иначе {
		кон.выражение(тек.аргументы[0])

		если ~асд.полиморфный тип?(тек.аргументы[0].Т^) {
			основа.добавить ошибку(тек.поз, "СЕМ-СТД-ТЕГ-ОШ-АРГ")
			вернуть
		}
	}
}

фн (кон: Контроль) вызов стд нечто(тек: асд.Вызов) {
	тек.Т := асд.ТСлово64()

	если длина(тек.аргументы) # 1 {
		основа.добавить ошибку(тек.поз, "СЕМ-СТДФУНК-ОШ-ЧИСЛО-АРГ", тек.стд-функция^.имя, "1")
		вернуть
	}

	кон.выражение(тек.аргументы[0])

	если ~асд.полиморфный тип?(тек.аргументы[0].Т^) {
		основа.добавить ошибку(тек.поз, "СЕМ-СТД-НЕЧТО-ОШ-АРГ")
		вернуть
	}
}

//== векторные

фн (кон: Контроль) вызов вектор-добавить(тек: асд.Вызов) {

	// Тип левой части уже проверен, см. вызов
	пусть тв = асд.основа(тек.стд-метод-Л^.Т)(:асд.ТипВектор)

	если кон.проверить разворачивание(тек.аргументы, 0, тв.Т-элемента) {
		// проверено
	} иначе {
        цикл арг среди тек.аргументы {
			кон.выражение(арг)
			кон.проверить совместимость по присваиванию(тв.Т-элемента, арг)
		}
	}
	тек.Т := асд.ТипНетЗначения()
}
