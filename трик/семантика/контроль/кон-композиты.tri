модуль контроль

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/семантика/контроль/словарь-цел-цел"

фн (кон: Контроль) типовое выражение(выр: асд.Выражение): мб асд.Тип {

	выбор пусть тек: тип выр {
	когда асд.ОперандИдент:
		надо тек.объект типа асд.УказТипа иначе вернуть пусто
		вернуть тек.объект^(:асд.Тип)
	когда асд.Доступ:
		надо тек.объект типа асд.УказТипа иначе вернуть пусто
		вернуть тек.объект^(:асд.Тип)
	}
	вернуть пусто
}

//== конструктор вектора

фн (кон: Контроль) конструктор вектора(композит: асд.КомпозитВектора, т: мб асд.Тип) {

    композит.Т := т
	пусть т-элемента =  тип-элемента вектора(т, композит.поз)

	если композит.размер # пусто {
		кон.выражение(композит.размер^)
		кон.проверить совместимость по присваиванию(асд.ТЦел64(), композит.размер^)
	}

	если композит.резерв # пусто {
		кон.выражение(композит.резерв^)
		кон.проверить совместимость по присваиванию(асд.ТЦел64(), композит.резерв^)
	}

	если композит.умолчание # пусто {
		кон.выражение(композит.умолчание^)
		кон.проверить совместимость по присваиванию(т-элемента, композит.умолчание^)
	}

    цикл индекс среди композит.индексы {
		кон.выражение(индекс)
		кон.проверить совместимость по присваиванию(асд.ТЦел64(), индекс)
		кон.проверить константное выражение(индекс)
	}

    цикл значение среди композит.значения {
		кон.выражение(значение)
        кон.проверить совместимость по присваиванию(т-элемента, значение)
	}

	если композит.умолчание = пусто & (композит.размер # пусто | длина(композит.индексы) > 0) {
		// TODO: если длина не задана явно, можно проверить, что индексы без дырок
		основа.добавить ошибку(композит.поз, "СЕМ-КОН-ВЕКТОРА-НЕТ-УМОЛЧАНИЯ")
	}

	кон.проверить индексы вектора(композит)
}

фн тип-элемента вектора(т: мб асд.Тип, поз: Цел64): асд.Тип {
	если т = пусто {
		основа.добавить ошибку(поз, "СЕМ-КОНСТРУКТОР-НЕТ-ТИПА")
	} иначе если ~асд.индексируемый тип?(т^) {
		основа.добавить ошибку(поз, "СЕМ-КОН-ВЕКТОРА-ОШ-ТИП")
	} иначе {
		вернуть асд.тип-элемента(т^)
	}
    вернуть асд.ТипОшибочный{поз: поз}
}

фн (кон: Контроль) проверить индексы вектора(композит: асд.КомпозитВектора) {

	// если были ошибки, не пытаюсь проверить индексы и длину
    надо основа.число ошибок() = 0 иначе вернуть

	если длина(композит.индексы) = 0 {
		вернуть
	}

	если композит.размер # пусто & кон.это константное выражение(композит.размер^) {
		композит.число-элементов := кон.вычислить целую константу(композит.размер^)
		если композит.число-элементов < 0 {
			основа.добавить ошибку(композит.размер^.поз, "СЕМ-КОН-ВЕКТОРА-ОШ-ДЛИНА")
		}
	}

    пусть все-индексы = словарь-цел-цел.Словарь{} // [№]Позиция
	пусть макс-№ := -1

    цикл индекс среди композит.индексы {
    
		пусть № = кон.вычислить целую константу(индекс)

        пусть эл = все-индексы.найти(№)
		если эл # пусто {
			основа.добавить ошибку(индекс.поз, "СЕМ-КОН-ВЕКТОРА-ИНДЕКС-ДУБЛЬ", №, основа.позиция для показа(эл^.значение))
		} иначе {
            все-индексы.добавить(№, индекс.поз)
		}

		если № > макс-№ {
			макс-№ := №
		}
		если № < 0 | композит.число-элементов >= 0 & № >= композит.число-элементов {
			основа.добавить ошибку(индекс.поз, "СЕМ-КОН-ВЕКТОРА-ИНДЕКС-ДИАП", композит.число-элементов, №)
		}
	}

	композит.макс-индекс := макс-№
}

//== конструктор класса

фн (кон: Контроль) конструктор класса(композит: асд.КомпозитКласса) {

	пусть т = кон.типовое выражение(композит.Л)

	если т = пусто {
		основа.добавить ошибку(композит.поз, "СЕМ-КОНСТРУКТОР-НЕТ-ТИПА")
		композит.Т := асд.ТипОшибочный{поз: композит.Л.поз}
		вернуть
	}

	цикл пара среди композит.значения {
		кон.выражение(пара.В)
	}

	если ~ асд.тип-класса?(т^) {
		основа.добавить ошибку(композит.поз, "СЕМ-КЛАСС-КОМПОЗИТ-ОШ-ТИП")
		композит.Т := асд.ТипОшибочный{поз: композит.Л.поз}
        вернуть
	} иначе {
		композит.Т := т
	}

	пусть тк = асд.основа(т^)^(:асд.ТипКласс)

	//=== проверяю поля и типы
    
    // словарь для проверки поздней инициализации
    пусть задано = асд.Словарь{} // map[Строка]Описание - нужен только признак наличия
    
    цикл пара среди композит.значения {
        пусть эл = тк.атрибуты.найти(пара.имя-поля)
        
		если эл = пусто {
			основа.добавить ошибку(пара.поз, "СЕМ-КЛАСС-КОМПОЗИТ-НЕТ-ПОЛЯ", пара.имя-поля)
		} иначе {
            пусть атрибут = эл^.значение 
			если ~ (атрибут типа асд.Поле) {
				основа.добавить ошибку(пара.поз, "СЕМ-КЛАСС-КОМПОЗИТ-НЕ-ПОЛE")
			} иначе если атрибут.владелец^ # кон.мод & ~ атрибут.экспорт {
				основа.добавить ошибку(пара.поз, "СЕМ-НЕ-ЭКСПОРТИРОВАН", атрибут.имя, атрибут.владелец^.имя)
			} иначе {
                пусть поле = атрибут(:асд.Поле)
				задано.добавить(пара.имя-поля, поле) 
                пара.поле := поле
				кон.проверить совместимость по присваиванию(поле.Т^, пара.В)
			}
		}
	}
    
	// проверяю позднюю инициализацию
    пусть и = тк.атрибуты.начать()
    пока и.элемент? # пусто {
        пусть атрибут = и.элемент?^.значение 
        если атрибут типа асд.Поле & атрибут(:асд.Поле).задать-позже {
            пусть эл = задано.найти(атрибут.имя)
            если эл = пусто {
				основа.добавить ошибку(композит.поз, "СЕМ-НЕТ-ПОЗЖЕ-ПОЛЯ", атрибут.имя)
            }
        }
        и.следующий()
    }    
}
