модуль имена

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"


//=== указание типа

фн (им: Имена) указание-типа(т: асд.Тип) {

    если т типа асд.ТипМБ {
        пусть т-мб = т(:асд.ТипМБ)
		им.указание-типа(т-мб .Т)

		если ~ асд.ссылочный тип?(т-мб.Т) {
			основа.добавить ошибку(т-мб.поз, "СЕМ-МБ-ТИП-НЕ-ССЫЛКА", асд.изображение-типа(т-мб.Т))
		}
		вернуть
	}
    
    надо т типа асд.УказТипа 
    иначе {
        если т типа асд.ТипВариативный {
			им.указание-типа(т(:асд.ТипВариативный).Т-элемента)
		}
		вернуть
	}
    
    пусть указ = т(:асд.УказТипа )
    
	если указ.Т # пусто {
		вернуть // уже сделано
	}

	пусть оп-типа = им.найти описание-типа(указ)

    указ.оп-типа := оп-типа
	указ.Т := оп-типа.Т

	если указ.Т = пусто {
		авария("assert: тип должен быть найден")
	}
}

фн (им: Имена) найти описание-типа(указ: асд.УказТипа): асд.ОписаниеТипа {
	если указ.имя-модуля = "" {
		вернуть им.найти локальное описание-типа(указ.имя-типа, указ.поз)
	} иначе {
		вернуть им.найти описание-типа в модуле(указ.имя-модуля, указ.имя-типа, указ.поз)
	}
}

фн (им: Имена) найти локальное описание-типа(имя: Строка, поз: Цел64): асд.ОписаниеТипа {

	пусть оп = найти в области(им.область, имя)

	если оп = пусто {
		основа.добавить ошибку(поз, "СЕМ-НЕ-НАЙДЕНО", имя)
		пусть оп-типа = им.сделать ошибочное описание-типа(имя, поз)
		добавить в область(имя, оп-типа, им.область)
		вернуть оп-типа
	}

    если ~ (оп типа асд.ОписаниеТипа) {
		основа.добавить ошибку(поз, "СЕМ-ДОЛЖЕН-БЫТЬ-ТИП", имя)
		вернуть им.сделать ошибочное описание-типа(имя, поз)
	}

	вернуть оп(:асд.ОписаниеТипа)
}

фн (им: Имена) найти описание-типа в модуле(имя-модуля: Строка, имя: Строка, поз: Цел64): асд.ОписаниеТипа {

	пусть оп1 = найти в области(им.мод.область, имя-модуля)

	если оп1 = пусто {
		основа.добавить ошибку(поз, "СЕМ-НЕ-НАЙДЕН-МОДУЛЬ", имя-модуля)
		вернуть им.сделать ошибочное описание-типа(имя, поз)
	}

	если ~ (оп1 типа асд.Модуль) {
		основа.добавить ошибку(поз, "СЕМ-ДОЛЖЕН-БЫТЬ-МОДУЛЬ", имя-модуля)
		вернуть им.сделать ошибочное описание-типа(имя, поз)
	}

    пусть мод = оп1(:асд.Модуль)
    
    им.проверить что импортирован(мод, поз)

    пусть эл = мод.область.имена.найти(имя)
	если эл = пусто {
		основа.добавить ошибку(поз, "СЕМ-НЕ-НАЙДЕНО-В-МОДУЛЕ", мод.имя, имя)
		пусть оп-типа = им.сделать ошибочное описание-типа(имя, поз)
		добавить в область(имя, оп-типа, им.область) // добавить в модуль?
		вернуть оп-типа
	}

    пусть оп2 = эл^.значение
	если ~ (оп2 типа асд.ОписаниеТипа) {
		основа.добавить ошибку(поз, "СЕМ-ДОЛЖЕН-БЫТЬ-ТИП", имя)
		вернуть им.сделать ошибочное описание-типа(имя, поз)
	}

	если ~ оп2.экспорт {
		основа.добавить ошибку(поз, "СЕМ-НЕ-ЭКСПОРТИРОВАН", имя, мод.имя)
	}

	вернуть оп2(:асд.ОписаниеТипа)
}

фн (им: Имена) сделать ошибочное описание-типа(имя: Строка, поз: Цел64): асд.ОписаниеТипа {
	вернуть асд.ОписаниеТипа{
        поз: поз,
        имя: имя,
        Т: асд.ТипОшибочный{поз: поз},
        владелец: им.мод,
        экспорт: истина, 
	}
}

//== типы

фн (им: Имена) описание-типа(оп: асд.ОписаниеТипа) {

	выбор пусть тек: тип оп.Т^ {
	когда асд.ТипВектор:
		им.указание-типа(тек.Т-элемента)
        
		// проверяю на []мб Т - это самая длинная в Тривиле цепочка,
		// если будут анонимные типы вектора, надо переделывать
        пусть т := тек.Т-элемента
        если т типа асд.ТипМБ {
            пусть м = т(:асд.ТипМБ)
        	им.указание-типа(м.Т)
            т := м.Т
		}
        если ~ асд.тип-класса?(т) {
            // описание вектора типа класса не приводит к рекурсии
        	им.обработать описание под-типа(т)
        }
        
	когда асд.ТипКласс:
		если тек.Т-базовый # пусто {
			им.указание-типа(тек.Т-базовый^)
			им.обработать описание под-типа(тек.Т-базовый^)
		}
        цикл поле среди тек.поля {
			если поле.Т # пусто {
				им.указание-типа(поле.Т^)
			}
			если ~ поле.задать-позже {
				им.выражение(поле.значение^)
			}
		}
	когда асд.ТипМБ:
		им.указание-типа(тек.Т)
		им.обработать описание под-типа(тек.Т)

		если ~ асд.ссылочный тип?(тек.Т) {
			основа.добавить ошибку(тек.поз, "СЕМ-МБ-ТИП-НЕ-ССЫЛКА", асд.изображение-типа(тек.Т))
		}

	когда асд.УказТипа:
		им.указание-типа(тек)

        пусть оп = тек.оп-типа^
        пусть эл = им.обработано.найти(оп)
        если эл # пусто {
            если ~ эл^.значение { // не завершено описание
                основа.добавить ошибку(оп.поз, "СЕМ-РЕКУРСИВНОЕ-ОПРЕДЕЛЕНИЕ", оп.имя)
            }
        } иначе если оп.владелец # пусто & оп.владелец^ = им.мод {
          	им.описание(оп)  
        }

	когда асд.ТипОшибочный:
        // ничего
	другое
        авария(строки.ф("неизвестный тип: $тип;", оп.Т^)) 
	}
 }

// Для проверки рекурсивного описания типа
фн (им: Имена) обработать описание под-типа(т: асд.Тип) {
    надо т типа асд.УказТипа иначе вернуть

    пусть указ = асд.непосредственное указание-типа(т)
    пусть оп-типа = указ.оп-типа^
   
    если оп-типа.владелец # пусто & оп-типа.владелец^ = им.мод {
			им.описание(оп-типа)
	}
}

