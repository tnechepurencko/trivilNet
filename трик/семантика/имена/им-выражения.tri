модуль имена

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"

фн (им: Имена) выражение(выр: асд.Выражение) {

	выбор пусть тек: тип выр  {
	когда асд.ОперандИдент:
		им.идент(тек)

	когда асд.УнарнаяОперация:
		им.выражение(тек.Л)

	когда асд.БинарнаяОперация:
		им.выражение(тек.Л)
		им.выражение(тек.П)

	когда асд.ПроверкаТипа:
		им.выражение(тек.Л)
		им.указание-типа(тек.цель)

	когда асд.Доступ:
		им.выражение(тек.Л^)
		им.проверить доступ к импортированному(тек)
		// проверка поля/метода делается на контроле типов

	когда асд.Вызов:
		им.выражение(тек.Л)
        цикл арг среди тек.аргументы {
			им.выражение(арг)
		}
		им.проверить стд функцию(тек)

	когда асд.Развернуть:
		им.выражение(тек.Л)

	когда асд.Преобразовать:
		им.выражение(тек.Л)
		им.указание-типа(тек.цель)

	когда асд.ПодтверждениеТипа:
		им.выражение(тек.Л)

	когда асд.ИндексацияИлиКомпозит:
		им.выражение(тек.Л)
		если тек.индекс # пусто {
			им.выражение(тек.индекс^)
		}

		если тек.композит.размер # пусто {
			им.выражение(тек.композит.размер^)
		}
		если тек.композит.резерв # пусто {
			им.выражение(тек.композит.резерв^)
		}
		если тек.композит.умолчание # пусто {
			им.выражение(тек.композит.умолчание^)
		}

		цикл в среди тек.композит.индексы {
			им.выражение(в)
		}
		цикл в среди тек.композит.значения {
			им.выражение(в)
		}
        
	когда асд.КомпозитКласса:
		им.выражение(тек.Л)

		цикл пара среди тек.значения {
			им.выражение(пара.В)
		}

	когда асд.Литерал:
		//nothing

	другое
        авария(строки.ф("неизвестное выражение: $тип;", выр)) 
	}
 }

фн (им: Имена) идент(тек: асд.ОперандИдент) {

	пусть оп = найти описание(им.область, тек.имя, тек.поз)
    
    если оп типа асд.ОписаниеТипа {
            тек.объект :=сделать указ-типа(оп(:асд.ОписаниеТипа), тек.поз)
    } иначе {
            тек.объект := оп
    }

	если оп.владелец # пусто & оп.владелец^ = им.мод {
		им.описание(оп)
	}
}

// Возврашает УказТипа для описания типа
фн сделать указ-типа(оп-типа: асд.ОписаниеТипа, поз: Цел64): асд.УказТипа {
	вернуть асд.УказТипа{
        поз: поз,
        имя-типа: оп-типа.имя,
		имя-модуля: "",
        оп-типа: оп-типа,
        Т: оп-типа.Т,
	}
}

фн (им: Имена) проверить доступ к импортированному(тек: асд.Доступ) {
/*
	ident, ok := тек.Л.(асд.ОперандИдент)
	если ~ok {
		вернуть
	}

	m, ok := ident.Obj.(асд.Модуль)
	если ~ok {
		вернуть
	}

	им.checkImported(m, тек.Pos)

	если d, ok := m.Inner.Names[тек.Name]; ok {
		если ~d.IsExported() {
			env.AddError(тек.Pos, "СЕМ-НЕ-ЭКСПОРТИРОВАН", тек.Name, m.Name)
		}

		если td, ok := d.(асд.ТипDecl); ok {
			тек.Obj = makeTypeRef(td, тек.Pos)
		} иначе {
			тек.Obj = d
		}

	} иначе {
		пусть inv = &ast.InvalidDecl{
			DeclBase: ast.DeclBase{Pos: тек.Pos, Name: тек.Name},
		}
		тек.Obj = inv
		m.Inner.Names[тек.Name] = inv
		env.AddError(тек.Pos, "СЕМ-НЕ-НАЙДЕНО-В-МОДУЛЕ", m.Name, тек.Name)
		//TODO: add test пока this error
	}
	тек.Л = пусто
*/    
}

фн (им: Имена) проверить стд функцию(тек: асд.Вызов) {
/*
	ident, ok := тек.Л.(асд.ОперандИдент)
	если ~ok {
		вернуть
	}

	если ident.Obj = пусто {
		вернуть
	}

	stdf, ok := ident.Obj.(асд.StdFunction)
	если ~ok {
		вернуть
	}

	тек.StdFunc = stdf
	тек.Л = пусто
*/    
}
