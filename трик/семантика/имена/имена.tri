модуль имена

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/семантика/словарь-описаний"

тип Имена = класс {
	мод: асд.Модуль = позже
    область: асд.Область := позже
    
    // ложь - идет обработка, истина - обработка завершена
    обработано = словарь-описаний.Словарь{} // [Описание]Лог
    
	порядок = асд.Описания[] // список описания в правильном порядке
}

фн обработать*(мод: асд.Модуль) {

	пусть им = Имена{
		мод: мод,
		область:  мод.область,
	}

	//==== добавление имен импортированных модулей
    цикл имп среди мод.импорты {
		добавить в область(имп.мод.имя, имп.мод, мод.область)
        
		// добавляю для проверки наличия импорта в исходном файле
        цикл № среди имп.номера-исходников {
			добавить в область(имя для проверки импорта(имп.мод, №), имп.мод, мод.область)
		}
	}

	//=== добавление имен в область
    цикл оп среди мод.описания {
		выбор пусть тек: тип оп  {
		когда асд.ОписаниеТипа:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.ОписаниеПеременной:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.ОписаниеКонстанты:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.Функция:
			если тек.получатель = пусто {
				добавить в область(тек.имя, тек, мод.область)
			}
		другое
            авария(строки.ф("неизвестное описание 1: $тип;", оп)) 
		}
	}

	надо им.область = мод.область иначе авария("assert - должна быть область модуля")

	// обойти описания, кроме функций
    цикл оп среди мод.описания {
		им.описание(оп)
	}

	// обойти Функция
    цикл оп среди мод.описания {
		если оп типа асд.Функция {
			им.функция(оп(:асд.Функция))
            им.порядок.добавить(оп)
		}
	}

	если мод.вход? # пусто {
		им.вход!(мод.вход?^)
	}
	//	show(m.Decls)
	//	show(им.decls)

	// Меняем порядок описаний - определение до использования
    мод.описания := им.порядок
}

/* Отладочное, временно оставляю
фн show(decls []асд.Описание) {
	пусть s = make([]Строка, len(decls))
	пока i, d := range decls {
		s[i] = d.GetName()
	}
	fmt.Printf("%v\n", Строкаs.Join(s, ","))
}
*/

// Обрабатывает описания, кроме функций
// Проверяет рекурсивные описания, задает порядок описаний
фн (им: Имена) описание(оп: асд.Описание) {

    если оп типа асд.Функция {
		вернуть
	}

    пусть эл = им.обработано.найти(оп)
	если эл # пусто {
		если ~ эл^.значение { // не завершено описание
			основа.добавить ошибку(оп.поз, "СЕМ-РЕКУРСИВНОЕ-ОПРЕДЕЛЕНИЕ", оп.имя)
		}
		вернуть
	}

    им.обработано.добавить(оп, ложь)

	выбор пусть тек: тип оп {
	когда асд.ОписаниеТипа:
		им.описание-типа(тек)
	когда асд.ОписаниеКонстанты:
		им.описание константы(тек)
	когда асд.ОписаниеПеременной:
		им.описание переменной(тек)
	когда асд.ОшОписание:
		// игнорирую
	другое
        авария(строки.ф("неизвестное описание 2: $тип;", оп)) 
	}

    им.обработано.добавить(оп, истина)
    им.порядок.добавить(оп)
}

//=== константы и переменные

фн (им: Имена) описание переменной(тек: асд.ОписаниеПеременной) {
	
    если тек.Т # пусто {
		им.указание-типа(тек.Т^)
	}
	если ~ тек.задать-позже {
		им.выражение(тек.значение^)
	}
}

фн (им: Имена) описание константы(тек: асд.ОписаниеКонстанты) {
	если тек.Т # пусто {
		им.указание-типа(тек.Т^)
	}
	им.выражение(тек.значение^)
}

//=== Функция

фн (им: Имена) функция(ф: асд.Функция) {

	пусть есть-тело = ~ ф.внешняя

	если есть-тело {
        пусть область = асд.новая область(им.область)
        ф.тело^.область := область
        им.область := область
	}

	если ф.получатель # пусто {
		им.указание-типа(ф.получатель^.Т^)

		им.добавить метод к типу(ф)

		если есть-тело {
			им.добавить переменную для параметра(ф.получатель^)
		}
	}

	пусть типф = ф.Т(:асд.ТипФункция)

	цикл пар среди типф.параметры {
		им.указание-типа(пар.Т^)
		если есть-тело {
			им.добавить переменную для параметра(пар)
		}
	}

	если типф.Т-вернуть # пусто {
		им.указание-типа(типф.Т-вернуть^)
	}

	если есть-тело {
		им.операторы(ф.тело^)
	}
}

фн (им: Имена) добавить метод к типу(ф: асд.Функция) {

    пусть получатель = ф.получатель^
	пусть тип-получателя = получатель.Т(:асд.УказТипа)

	надо тип-получателя.Т типа асд.ТипКласс иначе {
		основа.добавить ошибку(получатель.поз, "СЕМ-ПОЛУЧАТЕЛЬ-НЕ-КЛАСС")
		вернуть
	}

    пусть кл = тип-получателя.Т(:асд.ТипКласс)
	кл.методы.добавить(ф)
}

фн (им: Имена) добавить переменную для параметра(пар: асд.Параметр) {
    пусть пер = асд.ОписаниеПеременной{
        поз: пар.поз,
        имя: пар.имя, 
        Т: пар.Т,
        выходной-параметр: пар.выходной,
    }
	добавить в область(пер.имя, пер, им.область)
}

фн (им: Имена) вход!(тек: асд.Вход) {
	им.операторы(тек.тело)
}

