модуль имена

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/семантика/имена/словарь-описаний"

тип Имена = класс {
	мод: асд.Модуль = позже
    область: асд.Область := позже
    
    // ложь - идет обработка, истина - обработка завершена
    обработано = словарь-описаний.Словарь{} // [Описание]Лог
    
	порядок = асд.Описания[] // список описания в правильном порядке
}

фн обработать*(мод: асд.Модуль) {

	пусть им = Имена{
		мод: мод,
		область:  мод.область,
	}

	//==== добавление имен импортированных модулей
    цикл имп среди мод.импорты {
		добавить в область(имп.мод.имя, имп.мод, мод.область)
        
		// добавляю для проверки наличия импорта в исходном файле
        цикл № среди имп.номера-исходников {
			добавить в область(имя для проверки импорта(имп.мод, №), имп.мод, мод.область)
		}
	}

	//=== добавление имен в область
    цикл оп среди мод.описания {
		выбор пусть тек: тип оп  {
		когда асд.ОписаниеТипа:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.ОписаниеПеременной:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.ОписаниеКонстанты:
			добавить в область(тек.имя, тек, мод.область)
		когда асд.Функция:
			если тек.получатель = пусто {
				добавить в область(тек.имя, тек, мод.область)
			}
		другое
            авария(строки.ф("не известное описание 1: $тип;", оп)) 
		}
	}

	надо им.область = мод.область иначе авария("assert - должна быть область модуля")

	// обойти описания, кроме функций
    цикл оп среди мод.описания {
		им.описание(оп)
	}

	// обойти Функция
    цикл оп среди мод.описания {
		если оп типа асд.Функция {
			им.функция(оп(:асд.Функция))
            им.порядок.добавить(оп)
		}
	}

	если мод.вход? # пусто {
		им.вход!(мод.вход?^)
	}
	//	show(m.Decls)
	//	show(им.decls)

	// Меняем порядок описаний - определение до использования
    мод.описания := им.порядок
}

/* Отладочное, временно оставляю
фн show(decls []асд.Описание) {
	пусть s = make([]Строка, len(decls))
	пока i, d := range decls {
		s[i] = d.GetName()
	}
	fmt.Printf("%v\n", Строкаs.Join(s, ","))
}
*/

// Обрабатывает описания, кроме функций
// Проверяет рекурсивные описания, задает порядок описаний
фн (им: Имена) описание(оп: асд.Описание) {

    если оп типа асд.Функция {
		вернуть
	}

    пусть эл = им.обработано.найти(оп)
	если эл # пусто {
		если ~ эл^.значение {
			основа.добавить ошибку(оп.поз, "СЕМ-РЕКУРСИВНОЕ-ОПРЕДЕЛЕНИЕ", оп.имя)
		}
		вернуть
	}

    им.обработано.добавить(оп, ложь)

	выбор пусть тек: тип оп {
	когда асд.ОписаниеТипа:
		им.описание-типа(тек)
	когда асд.ОписаниеКонстанты:
		им.описание константы(тек)
	когда асд.ОписаниеПеременной:
		им.описание переменной(тек)
	когда асд.ОшОписание:
		// игнорирую
	другое
        авария(строки.ф("не известное описание 2: $тип;", оп)) 
	}

    им.обработано.добавить(оп, ложь)
    им.порядок.добавить(оп)
}

//=== константы и переменные

фн (им: Имена) описание переменной(тек: асд.ОписаниеПеременной) {
	
    если тек.Т # пусто {
		им.указание-типа(тек.Т^)
	}
	если ~ тек.задать-позже {
		им.выражение(тек.значение^)
	}
}

фн (им: Имена) описание константы(тек: асд.ОписаниеКонстанты) {
	если тек.Т # пусто {
		им.указание-типа(тек.Т^)
	}
	им.выражение(тек.значение^)
}

//=== Функция

фн (им: Имена) функция(ф: асд.Функция) {

	пусть есть-тело = ~ ф.внешняя

	если есть-тело {
        пусть область = асд.новая область(им.область)
        ф.тело^.область := область
        им.область := область
	}

	если ф.получатель # пусто {
		им.указание-типа(ф.получатель^.Т^)

		им.добавить метод к типу(ф)

		если есть-тело {
			им.добавить переменную для параметра(ф.получатель^)
		}
	}

	пусть типф = ф.Т^(:асд.ТипФункция)

	цикл пар среди типф.параметры {
		им.указание-типа(пар.Т^)
		если есть-тело {
			им.добавить переменную для параметра(пар)
		}
	}

	если типф.Т-вернуть # пусто {
		им.указание-типа(типф.Т-вернуть^)
	}

	если есть-тело {
		им.операторы(ф.тело^)
	}
}

фн (им: Имена) добавить метод к типу(ф: асд.Функция) {

    пусть получатель = ф.получатель^
	пусть тип-получателя = получатель.Т^(:асд.УказТипа)

	надо тип-получателя.Т^ типа асд.ТипКласс иначе {
		основа.добавить ошибку(получатель.поз, "СЕМ-ПОЛУЧАТЕЛЬ-НЕ-КЛАСС")
		вернуть
	}

    пусть кл = тип-получателя.Т^(:асд.ТипКласс)
	кл.методы.добавить(ф)
}

фн (им: Имена) добавить переменную для параметра(пар: асд.Параметр) {
    пусть пер = асд.ОписаниеПеременной{
        поз: пар.поз,
        имя: пар.имя, 
        Т: пар.Т,
        выходной-параметр: пар.выходной,
    }
	добавить в область(пер.имя, пер, им.область)
}

фн (им: Имена) вход!(тек: асд.Вход) {
	им.операторы(тек.тело)
}

//== statements

фн (им: Имена) операторы(тело: асд.СписокОператоров) {
/*
	пока _, s := range seq.Statements {
		им.оператор(seq, s)
	}

	если им.scope = seq.Inner {
		им.scope = seq.Inner.Outer
	}
*/    
}

/*
фн (им: Имена) lookStatement(seq асд.ОператорSeq, s ast.Statement) {
	выбор x := s.(тип) {
	когда асд.ОператорSeq:
		им.операторы(x)
	когда асд.ВыражениеStatement:
		им.выражение(x.X)
	когда асд.ОписаниеStatement:
		им.локальное описание(seq, x.D)
	когда асд.ОператорПрисвоить:
		им.выражение(x.L)
		им.выражение(x.R)
	когда асд.ОператорУвеличить:
		им.выражение(x.L)
	когда асд.ОператорУменьшить:
		им.выражение(x.L)
	когда асд.ОператорЕсли:
		им.выражение(x.Cond)
		им.операторы(x.Then)
		если x.Else # пусто {
			им.оператор(пусто, x.Else)
		}
	когда асд.ОператорПока:
		им.выражение(x.Cond)
		им.операторы(x.Seq)
	когда асд.ОператорЦикл:
		им.выражение(x.Expr)
		если x.IndexVar # пусто {
			x.IndexVar.Later = истина
			им.локальное описание(x.Seq, x.IndexVar)
		}
		если x.ElementVar # пусто {
			x.ElementVar.Later = истина
			им.локальное описание(x.Seq, x.ElementVar)
		}
		им.операторы(x.Seq)
	когда асд.ОператорНадо:
		им.выражение(x.Cond)
		им.оператор(пусто, x.Else)
	когда асд.ОператорВыбор:
		им.lookSelect(x)
	когда асд.ОператорВыборType:
		им.lookSelectType(x)
	когда асд.ОператорВернуть:
		если x.X # пусто {
			им.выражение(x.X)
		}
	когда асд.ОператорПрервать:
		//nothing
	когда асд.ОператорАвария:
		им.выражение(x.X)

	другое
		panic(fmt.Sprintf("statement: ni %T", s))
	}
}
*/    

/*
фн (им: Имена) lookLocalDecl(seq асд.ОператорSeq, decl асд.Описание) {
	если им.scope # seq.Inner {
		seq.Inner = ast.NewScope(им.scope)
		им.scope = seq.Inner
	}
	выбор x := decl.(тип) {
	когда асд.ОписаниеПеременной:
		им.описание переменной(x)
		добавить в область(x.Name, x, им.scope)
	другое
		panic(fmt.Sprintf("local decl: ni %T", decl))
	}
	//ast.ShowScopes("", им.scope)
}

фн (им: Имена) lookSelect(x асд.ОператорВыбор) {
	если x.X # пусто {
		им.выражение(x.X)
	}

	пока _, c := range x.Cases {
		пока _, e := range c.Exprs {
			им.выражение(e)
		}
		им.операторы(c.Seq)
	}
	если x.Else # пусто {
		им.операторы(x.Else)
	}
}

фн (им: Имена) lookSelectType(x асд.ОператорВыборType) {
	им.выражение(x.X)

	пока _, c := range x.Cases {
		пока _, t := range c.Types {
			им.указание-типа(t)
		}
		если c.Var # пусто {
			c.Var.Later = истина
			им.локальное описание(c.Seq, c.Var)
		}

		им.операторы(c.Seq)
	}
	если x.Else # пусто {
		им.операторы(x.Else)
	}
}
*/