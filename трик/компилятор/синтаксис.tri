модуль компилятор

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/асд"
импорт "трик/основа"
импорт "трик/парсер"
импорт "трик/асд/асд-показ"
импорт "трик/компилятор/словарь-импорты"

фн (сб: Сборка) разобратьМодуль(главный?: Лог, список: Исходники): асд.Модуль {

	пусть модули = сб.разобрать исходники(главный?, список)

	если основа.число ошибок() > 0 {
		вернуть модули[0]
	}

	если основа.число ошибок() = 0 {
		слить модули(модули)
	}

	пусть мод = модули[0]


	если основа.число ошибок() = 0 & основа.показать АСД после парсера() {
        вывод.ф("$;\n", асд-показ.с-модуль(мод))
	}

	надо основа.число ошибок() = 0 иначе вернуть мод

	цикл имп среди мод.импорты {
		сб.импортировать(имп)
	}

    мод.папка-модуля := список[0].путь-папки

	вернуть мод
}

фн (сб: Сборка) разобрать исходники(главный?: Лог, список: Исходники): Модули {

	пусть модули = Модули[]
	пусть имя-модуля := ""

	цикл исх среди список {

		пусть мод = сб.разобрать файл(исх)
        модули.добавить(мод)

		если длина(модули) = 1 {
			имя-модуля := мод.имя

			// для головного модуля не проверяю соответствие имени папки 
			если ~ главный? & мод.имя # исх.имя папки() {
				основа.добавить ошибку(мод.поз, "ОКР-ОШ-ИМЯ-МОДУЛЯ", мод.имя, исх.имя папки())
			}
		} иначе если имя-модуля # мод.имя {
			основа.добавить ошибку(мод.поз, "ОКР-ОШ-МОДУЛИ-В-ПАПКЕ", имя-модуля, мод.имя, исх.путь-папки)
		}

		если мод.настройка # пусто {
            модули.добавить(сб.сделать реплику(мод)...)
		}
	}

	вернуть модули
}

фн (сб: Сборка) разобрать файл(исх: основа.Исходник): асд.Модуль {

	если основа.отладка сборки() {
		вывод.ф("Синтаксис: '$;'\n", исх.путь-файла)
	}

    пусть мод = парсер.разобрать(исх)

	вернуть мод
}

// Сливает несколько модулей исходных файлов в один.
// Вызывается даже если модуль один - нужно подготовить импорт
фн слить модули(модули: Модули) {

	если основа.отладка сборки() & длина(модули) > 1 {
    
		пусть список = Строки[выделить: длина(модули)]
		цикл [№]мод среди модули {
            пусть исх = основа.исходник по позиции(мод.поз)
            список.добавить(исх.имя-файла)
		}
		вывод.ф("Слияние '$;': $;\n", модули[0].имя, строки.соединить(" + ", список...))
	}

	пусть общий = модули[0]


	// соединить импорт
	пусть №-исх  := основа.номер исходника(общий.поз)
    пусть все-импорты = словарь-импорты.Словарь{}
    
    цикл имп среди общий.импорты {
        имп.номера-исходников.добавить(№-исх)
        все-импорты.добавить(имп.путь-импорта, имп)
	}

    пусть № := 1
    пока № < длина(модули) {
        пусть мод = модули[№]
        пусть №-исх = основа.номер исходника(мод.поз)
        цикл имп среди мод.импорты {
            пусть эл = все-импорты.найти(имп.путь-импорта)
			если эл # пусто {
                пусть имп-общий = эл^.значение
                имп-общий.номера-исходников.добавить(№-исх)
			} иначе {
                имп.номера-исходников.добавить(№-исх)
                все-импорты.добавить(имп.путь-импорта, имп)
                общий.импорты.добавить(имп)
			}
		}
        №++
	}

	/* отладка
    цикл имп среди общий.импорты {
		вывод.ф("! $; $;\n", имп.путь-импорта, имп.номера-исходников)
	}
	*/

	// соединить описания
    № := 1
    пока № < длина(модули) {

		пусть мод = модули[№]

        общий.описания.добавить(мод.описания...)
        
		если мод.вход? # пусто {
			если общий.вход? # пусто {
				основа.добавить ошибку(общий.вход?^.поз, "ПАР-ДУБЛЬ-ВХОД", основа.позиция для показа(мод.вход?^.поз))
			} иначе {
				общий.вход? := мод.вход?
			}
		}
        №++
	}
    асд.установить владельца(общий)
}

