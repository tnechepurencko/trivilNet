модуль компилятор

импорт "стд::вывод"

импорт "трик/асд"
импорт "трик/асд/асд-показ"
импорт "трик/основа"
импорт "трик/компилятор/словарь-модули"
импорт "трик/компилятор/словарь-состояние"
импорт "трик/семантика"
импорт "трик/сиген"

тип Строки = []Строка
тип Исходники = основа.Исходники
тип Модули = []асд.Модуль

тип Сборка = класс {
    главный: мб асд.Модуль := пусто
    
	импортированные = словарь-модули.Словарь{} // [Строка]мб Модуль

	//testModulePath Строка // импорт путь для тестируемого модуля

	// упорядоченный список для обработки, головной модуль - стоит последним
	список = Модули[]
    состояние = словарь-состояние.Словарь{} // [асд.Модуль]Цел64

	// Путь к папке для модуля, только для создания интерфейса модуля
	//folders map[*асд.Модуль]Строка
}


фн компилировать*(исходный-путь: Строка) {
    //вывод.ф("компилировать: $;\n", исходный-путь)
    
    пусть список = основа.подготовить исходники по пути(исходный-путь)
    надо основа.число ошибок() = 0 иначе вернуть        
    
    пусть исх = список[0]
    надо исх.ошибка = пусто
    иначе {
        // TODO: общая ошибка должна быть уже выдана
        вывод.ф("$;\n", исх.ошибка^.сообщение())
        вернуть
    }

	пусть сб = Сборка{
		//imported: make(map[string]*ast.Module),
		//folders:  make(map[*ast.Module]string),
	}

    сб.главный := сб.разобратьМодуль(истина, список)
   
    надо основа.число ошибок() = 0 иначе вернуть   
    
	сб.обработать()
}

фн (сб: Сборка) обработать() {

	сб.построить список(сб.главный^, сб.главный^.поз)
	цикл мод среди сб.список {

		если основа.число ошибок() # 0 {
			прервать
		}

		сб.анализ и генерация(мод)
	}
/*
	если основа.число ошибок() = 0 & *env.DoGen & *env.BuildExe {
		genc.BuildExe(cc.list)
	}
*/    
}

//==== анализ и генерация

фн (сб: Сборка) анализ и генерация(мод: асд.Модуль) {

	если основа.отладка сборки() {
		вывод.ф("Анализ и генерация: '$;'\n", мод.имя)
	}

    асд.задать обрабатываемый-модуль(мод) // для улучшения сообщений об ошибкаъ
	семантика.семантический анализ(мод)
    асд.задать обрабатываемый-модуль(пусто)

	надо основа.число ошибок() = 0 иначе вернуть
    

	если основа.показать АСД после семантики() {
        вывод.ф("$;\n", асд-показ.с-модуль(мод))
	}

/*
	если *env.MakeDef & m # cc.main {
		makeDef(m, cc.folders[m])
	}
*/
	если основа.включить генерацию() {
		сиген.построить код(мод, мод = сб.главный^)
	}
}

//=== построение упорядоченного списка

конст (
	обработка-идет = 1
	обработка-завершена = 2
)

фн (сб: Сборка) построить список(мод: асд.Модуль, поз: Цел64) {

    пусть эл = сб.состояние.найти(мод)
    если эл # пусто {
        если эл^.значение = обработка-идет {
			основа.добавить ошибку(поз, "СЕМ-ЦИКЛ-ИМПОРТА", мод.имя)
            сб.состояние.добавить(мод, обработка-завершена)
		}
		вернуть
	}

    сб.состояние.добавить(мод, обработка-идет)
    
    цикл имп среди мод.импорты {
        сб.построить список(имп.мод, имп.поз)
	}

    сб.состояние.добавить(мод, обработка-завершена)
    сб.список.добавить(мод)
}
