модуль компилятор

импорт "стд::вывод"

импорт "трик/асд"
импорт "трик/асд/асд-показ"
импорт "трик/основа"
импорт "трик/компилятор/словарь-модули"
импорт "трик/компилятор/словарь-состояние"
импорт "трик/семантика"
импорт "трик/сиген"

тип Строки = []Строка
тип Исходники = основа.Исходники
тип Модули = []асд.Модуль

тип Сборка = класс {
    главный: мб асд.Модуль := пусто
	импортированные = словарь-модули.Словарь{} // [Строка]мб Модуль

	// упорядоченный список для обработки, головной модуль - стоит последним
	список = Модули[]
    состояние = словарь-состояние.Словарь{} // [асд.Модуль]Цел64

	путь-тестируемого := ""  // путь импорта для тестируемого модуля
}

фн компилировать*(исходный-путь: Строка) {
    //вывод.ф("компилировать: $;\n", исходный-путь)
    
    пусть список = основа.подготовить исходники по пути(исходный-путь)
    надо основа.число ошибок() = 0 иначе вернуть        
    
    пусть исх = список[0]
    надо исх.ошибка = пусто
    иначе {
        // TODO: общая ошибка должна быть уже выдана
        вывод.ф("$;\n", исх.ошибка^.сообщение())
        вернуть
    }

	пусть сб = Сборка{}

    сб.главный := сб.разобратьМодуль(истина, список)
   
    надо основа.число ошибок() = 0 иначе вернуть   
    
	сб.обработать()
}

фн (сб: Сборка) обработать() {

	сб.построить список(сб.главный^, сб.главный^.поз)
	цикл мод среди сб.список {

		надо основа.число ошибок() = 0 иначе прервать

		сб.анализ и генерация(мод)
	}
	надо основа.число ошибок() = 0 иначе вернуть

	если основа.построить исполняемую программу() {
    
        если основа.отладка сборки() {
            вывод.ф("Сборка исполняемой программы: '$;'\n", сб.главный^.имя)
        }   
    
		сиген.построить исполняемый файл(сб.список)
	}
}

//==== анализ и генерация

фн (сб: Сборка) анализ и генерация(мод: асд.Модуль) {

	если основа.отладка сборки() {
		вывод.ф("Анализ и генерация: '$;'\n", мод.имя)
	}

    асд.задать обрабатываемый-модуль(мод) // для улучшения сообщений об ошибкаъ
	семантика.семантический анализ(мод)
    асд.задать обрабатываемый-модуль(пусто)

	надо основа.число ошибок() = 0 иначе вернуть
    

	если основа.показать АСД после семантики() {
        вывод.ф("$;\n", асд-показ.с-модуль(мод))
	}

	если основа.построить документацию модуля() & мод # сб.главный^ {
        построить документацию(мод)
	}

	если основа.включить генерацию() {
		сиген.построить код(мод, мод = сб.главный^)
	}
}

//=== построение упорядоченного списка

конст (
	обработка-идет = 1
	обработка-завершена = 2
)

фн (сб: Сборка) построить список(мод: асд.Модуль, поз: Цел64) {

    пусть эл = сб.состояние.найти(мод)
    если эл # пусто {
        если эл^.значение = обработка-идет {
			основа.добавить ошибку(поз, "СЕМ-ЦИКЛ-ИМПОРТА", мод.имя)
            сб.состояние.добавить(мод, обработка-завершена)
		}
		вернуть
	}

    сб.состояние.добавить(мод, обработка-идет)
    
    цикл имп среди мод.импорты {
        сб.построить список(имп.мод, имп.поз)
	}

    сб.состояние.добавить(мод, обработка-завершена)
    сб.список.добавить(мод)
}
