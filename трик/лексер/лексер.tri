модуль лексер

импорт "стд::вывод"
импорт "стд::юникод/utf8"
импорт "стд::юникод"

//импорт "стд::строки"

импорт "трик/основа"

тип Лексер = класс {
    // результат работы Лексер.лексема:
    лек* := НЕОП
    поз* := 0
    изо* := "" // изображение лексемы для идентов, строк, чисел

    исходник: основа.Исходник = позже
    байты: основа.Байты = позже
    декодер: utf8.Декодер = позже
    
    сим: Символ := ' ' // текущий символ (unicode)
    нач-сим := 0  // начало лексемы
    №-байта := 0 // позиция чтения (байты)
    №-сим := 0  // номер символа
}

конст КФ = 0x7F(:Символ) // используется как конец файла

фн начать*(исходник: основа.Исходник): Лексер {
    пусть ле = Лексер{
        исходник: исходник,
        байты: исходник.байты,
        декодер: utf8.декодер(исходник.байты),
    }

	// пропустить BOM, если есть
    если длина(ле.байты) >= 3 &  ле.байты[0] = 0xEF(:Байт) & ле.байты[1] = 0xBB(:Байт) & ле.байты[2] = 0xBF(:Байт) {
        ле.№-байта := 3
    }
    
    исходник.начало строки(ле.№-сим)
    ле.символ()
    
    вернуть ле
}

фн (ле: Лексер) ошибка(№-сим: Цел64, код: Строка, аргументы: ...*) {
    основа.добавить ошибку(ле.исходник.позиция(№-сим), код, аргументы...)
}

// Извлекает следующий unicode символ
фн (ле: Лексер) символ() {
    надо ле.№-байта < длина(ле.байты) 
    иначе { 
        ле.нач-сим := длина(ле.байты)
        ле.исходник.начало строки(ле.№-сим)
        ле.сим := КФ
        вернуть
    }
    
    ле.нач-сим := ле.№-байта
    пусть сим := ле.байты[ле.№-байта](:Символ)
    пусть байтов := 1 // число байтов в символе
    
    выбор {
    когда сим = 0(:Символ):
        ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", 0(:Символ))
        ле.№-сим++
    когда сим = '\n':
        ле.№-сим++
        ле.исходник.начало строки(ле.№-сим)        
    когда сим = '\r':
			сим := '\n'
            ле.№-сим++
            если ле.№-байта + 1 < длина(ле.байты) & ле.байты[ле.№-байта + 1](:Символ) = '\n' {
                ле.№-сим++
                байтов := 2
			}
            ле.исходник.начало строки(ле.№-сим)        
    когда сим >= 0x80(:Символ):
        ле.декодер.№ := ле.№-байта
        сим := ле.декодер.символ()
        байтов := ле.декодер.число-байтов
        ле.№-сим++
        если сим = utf8.Недоп-символ {
            ле.ошибка(ле.№-сим, "ЛЕК-UTF8")
        }
    другое // это 7-битный символ
        ле.№-сим++
    }

    ле.сим := сим
    ле.№-байта := ле.№-байта + байтов
}

фн (ле: Лексер) посмотреть байт(): Байт {
    надо ле.№-байта < длина(ле.байты) иначе вернуть 0
    вернуть ле.байты[ле.№-байта]
}

//==== предикаты =====

фн это буква?(сим: Символ): Лог {
    вернуть сим >= 0x80(:Символ) & юникод.буква?(сим)
        | сим = '_' | сим = '№' 
        | сим >= 'a' & сим <= 'z'
        | сим >= 'A' & сим <= 'Z'
}

фн это цифра?(сим: Символ): Лог {
    вернуть сим >= '0' & сим <= '9'
}

//==== разбор лексем =====

фн (ле: Лексер) пропустить пробелы() {
    пока ле.сим = ' ' | ле.сим = '\t' {
        ле.символ()
    }
}

/*
фн (ле: Лексер) равно что-то(лек0, лек1 Лексема) Лексема {
	если ле.сим = '=' {
		ле.символ()
		вернуть лек1
	}
	вернуть лек0
}
*/

фн (ле: Лексер) проверить след(лек0: Лексема, след: Символ, лек1: Лексема): Лексема {
	если ле.сим = след {
		ле.символ()
		вернуть лек1
	}
	вернуть лек0
}

фн (ле: Лексер) лексема*() {
    ле.пропустить пробелы()

    ле.поз := ле.исходник.позиция(ле.№-сим)
    ле.изо := ""
    пусть сим = ле.сим
    
    если это буква?(сим) {
    //!
        вернуть
    }
    если это цифра?(сим) {
    //!
        вернуть
    }
   
    ле.символ() // всегда сдвигаюсь
    выбор сим {
    когда КФ: ле.лек := КОН-ФАЙЛ
    когда '\n':
		// пропускаем все концы строк
		пока ле.сим = '\n' {
				ле.символ()
		}
		ле.лек := КОН-СТР
/*            
		когда '"':
			ле.лек := STRING
			lit = s.scanString('"')
		когда '\'':
			ле.лек := SYMBOL
			lit = s.scanSymbol('\'')
		когда '@':
			ле.лек := MODIFIER
			lit = s.scanModifier()
*/            
	когда ':':
        выбор ле.сим  {
		когда '=':
			ле.лек := ПРИСВОИТЬ
			ле.символ()
		когда '&':
			ле.лек := БИТ-И
			ле.символ()
		когда '|':
			ле.лек := БИТ-ИЛИ
			ле.символ()
		когда '\\':
			ле.лек := БИТ-ИСК-ИЛИ
			ле.символ()
		когда '~':
			ле.лек := БИТ-НЕ
			ле.символ()
		другое
			ле.лек := ДВОЕТОЧИЕ
		}
	когда '.':
		ле.лек := ТОЧКА
		если ле.сим = '.' & ле.посмотреть байт() = '.'(:Байт) {
				ле.символ()
				ле.символ() // взять третью  '.'
				ле.лек := ТРОЕТОЧИЕ
		}
    когда ',': 
        ле.лек := ЗАПЯТАЯ
    когда ';': 
        ле.лек := ТОЧКА-ЗАП
        ле.изо := ";"
	когда '(':
		ле.лек := ле.проверить след(КРУГ-Л, ':', КОНВЕРСИЯ)
	когда ')':
		ле.лек := КРУГ-П
	когда '[':
		ле.лек := КВАД-Л
	когда ']':
		ле.лек := КВАД-П
	когда '{':
		ле.лек := ФИГ-Л
	когда '}':
		ле.лек := ФИГ-П
	когда '+':
		ле.лек := ле.проверить след(СЛОЖИТЬ, '+', УВЕЛИЧИТЬ)
	когда '-':
		ле.лек := ле.проверить след(ВЫЧЕСТЬ, '-', УМЕНЬШИТЬ)
	когда '*':
		ле.лек := УМНОЖИТЬ
	когда '/':
		если ле.сим = '/' {
			ле.лек := КОММЕНТ-СТРОКА
//!				ofs := s.scanLineComment()
//				lit = string(s.src[ofs:s.offset])
		} иначе если ле.сим = '*' {
			ле.лек := КОММЕНТ-БЛОК
//!				ofs := s.scanBlockComment()
//				lit = string(s.src[ofs:s.offset])
		} иначе {
			ле.лек := ДЕЛИТЬ
		}
	когда '%':
		ле.лек := ОСТАТОК
	когда '^':
		ле.лек := НЕ-ПУСТО
	когда '<':
		выбор ле.сим {
		когда '=':
			ле.лек := МЕНЬШЕ-РАВНО
			ле.символ()
		когда '<':
			ле.лек := СДВИГ-Л
			ле.символ()
		другое
			ле.лек := МЕНЬШЕ
		}
	когда '>':
		выбор ле.сим {
		когда '=':
			ле.лек := БОЛЬШЕ-РАВНО
			ле.символ()
		когда '>':
			ле.лек := СДВИГ-П
			ле.символ()
		другое
			ле.лек := БОЛЬШЕ
		}
	когда '=':
		ле.лек := РАВНО
	когда '#':
		ле.лек := НЕ-РАВНО
	когда '~':
		ле.лек := НЕ
	когда '&':
		ле.лек := И
	когда '|':
		ле.лек := ИЛИ 
	другое
        ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", сим(:Строка))
		ле.лек := НЕОП
        ле.изо := сим(:Строка)
	}

}

