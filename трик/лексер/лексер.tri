модуль лексер

импорт "стд::вывод"
импорт "стд::строки"
импорт "стд::юникод/utf8"
импорт "стд::юникод"

импорт "трик/основа"

тип Лексер = класс {
    // результат работы Лексер.лексема:
    лек* := НЕОП
    поз* := 0
    изо* := "" // изображение лексемы для идентов, строк, чисел

    исходник: основа.Исходник = позже
    байты: основа.Байты = позже
    декодер: utf8.Декодер = позже
    
    сим: Символ := ' ' // текущий символ (unicode)
    нач-байт := 0  // начало лексемы
    №-байта := 0 // позиция чтения (байты)
    №-сим := 0  // номер символа
}

конст КФ = 0x7F(:Символ) // используется как конец файла

фн начать*(исходник: основа.Исходник): Лексер {
    пусть ле = Лексер{
        исходник: исходник,
        байты: исходник.байты,
        декодер: utf8.декодер(исходник.байты),
    }

	// пропустить BOM, если есть
    если длина(ле.байты) >= 3 &  ле.байты[0] = 0xEF(:Байт) & ле.байты[1] = 0xBB(:Байт) & ле.байты[2] = 0xBF(:Байт) {
        ле.№-байта := 3
    }
    
    исходник.начало строки(ле.№-сим)
    ле.символ()
    
    вернуть ле
}

фн (ле: Лексер) ошибка(№-сим: Цел64, код: Строка, аргументы: ...*) {
    основа.добавить ошибку(ле.исходник.позиция(№-сим), код, аргументы...)
}

// Извлекает следующий unicode символ
фн (ле: Лексер) символ() {
    надо ле.№-байта < длина(ле.байты) 
    иначе { 
        ле.нач-байт := длина(ле.байты)
        ле.исходник.начало строки(ле.№-сим)
        ле.сим := КФ
        вернуть
    }
    
    ле.нач-байт := ле.№-байта
    пусть сим := ле.байты[ле.№-байта](:Символ)
    пусть байтов := 1 // число байтов в символе
    
    выбор {
    когда сим = 0(:Символ):
        ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", 0(:Символ))
        ле.№-сим++
    когда сим = '\n':
        ле.№-сим++
        ле.исходник.начало строки(ле.№-сим)        
    когда сим = '\r':
			сим := '\n'
            ле.№-сим++
            если ле.№-байта + 1 < длина(ле.байты) & ле.байты[ле.№-байта + 1](:Символ) = '\n' {
                ле.№-сим++
                байтов := 2
			}
            ле.исходник.начало строки(ле.№-сим)        
    когда сим >= 0x80(:Символ):
        ле.декодер.№ := ле.№-байта
        сим := ле.декодер.символ()
        байтов := ле.декодер.число-байтов
        ле.№-сим++
        если сим = utf8.Недоп-символ {
            ле.ошибка(ле.№-сим, "ЛЕК-UTF8")
        }
    другое // это 7-битный символ
        ле.№-сим++
    }

    ле.сим := сим
    ле.№-байта := ле.№-байта + байтов
}

фн (ле: Лексер) посмотреть байт(): Байт {
    надо ле.№-байта < длина(ле.байты) иначе вернуть 0
    вернуть ле.байты[ле.№-байта]
}

//==== предикаты =====

фн это буква?(сим: Символ): Лог {
    вернуть сим >= 0x80(:Символ) & юникод.буква?(сим)
        | сим = '_' | сим = '№' 
        | сим >= 'a' & сим <= 'z'
        | сим >= 'A' & сим <= 'Z'
}

фн это цифра?(сим: Символ): Лог {
    вернуть сим >= '0' & сим <= '9'
}

фн это цифра16?(сим: Символ): Лог {
    вернуть сим >= '0' & сим <= '9'
        |  сим >= 'A' & сим <= 'F'
        |  сим >= 'a' & сим <= 'f'
}


//====  иденты и ключевые слова ====

фн (ле: Лексер) идентификатор()  {

    ле.лек := ИДЕНТ

	пусть нач-байт = ле.нач-байт
	пусть начало-слова := ле.нач-байт
    
	// переменные для сохранеения состояние после слова
	пусть сох-сим := 0(:Символ)
    пусть сох-нач-байт := 0
    пусть сох-№-байта := 0
    пусть сох-№-сим := 0

	пока истина {
		пока истина {
			ле.символ()
			если ~ это буква?(ле.сим) & ~ это цифра?(ле.сим) {
				прервать
			}
		}

		если ле.сим = '-' {
            пусть _сим = ле.сим
            пусть _нач-байт = ле.нач-байт
            пусть _№-байта = ле.№-байта
            пусть _№-сим = ле.№-сим
			ле.символ()
			если ~ это буква?(ле.сим) {
				ле.сим := _сим
                ле.нач-байт := _нач-байт
                ле.№-байта := _№-байта
                ле.№-сим := _№-сим
				прервать
			}
		} иначе если ле.сим = '!' | ле.сим = '?' {
			ле.символ()
			прервать
		} иначе {
			// это пробел или не часть идентификатора, проверяю последнее слово на ключевое
            ле.изо := строки.извлечь из байтов(ле.байты, начало-слова, ле.нач-байт - начало-слова)
            ле.лек := проверить на ключевое(ле.изо)
            
			если ле.лек # ИДЕНТ {
				если начало-слова = нач-байт {
					// первое слово - ключевое
					вернуть
				} иначе {
					// второе слово - ключевое, возвращаю предыдущую часть
					// ключевое слово будет взято следующим вызовом
                    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, сох-нач-байт - нач-байт)
    
                    // восстанавливаю состояние
					ле.сим := сох-сим
                    ле.нач-байт := сох-нач-байт
                    ле.№-байта := сох-№-байта
                    ле.№-сим := сох-№-сим
					вернуть 
				}
			}

			если ле.сим # ' ' {
				прервать
			}

            // сохраняю состояние после слова
            сох-сим := ле.сим
            сох-нач-байт := ле.нач-байт
            сох-№-байта := ле.№-байта
            сох-№-сим := ле.№-сим

			ле.символ()
			если ~ это буква?(ле.сим) {
                // восстанавливаю состояние
                ле.сим := сох-сим
                ле.нач-байт := сох-нач-байт
                ле.№-байта := сох-№-байта
                ле.№-сим := сох-№-сим

				прервать
			}
			начало-слова := ле.нач-байт
		}
	}

    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт)
}

//==== комментарии =====

// Возвращает начало (на всякий случай)
фн (ле: Лексер) строчный комментарий() {
	// Первый '/' уже взят
	пусть нач-байт = ле.нач-байт - 1
	ле.символ()
	пока ле.сим # '\n' & ле.сим # КФ {
		ле.символ()
	}
	если ле.сим = '\n' {
		ле.символ() // перешли на след. символ после комментария
	}
	ле.лек := КОММЕНТ-СТРОКА
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт)
}

фн (ле: Лексер) блочный комментарий() {
	// '/' уже взят
	пусть нач-байт = ле.нач-байт - 1
    пусть нач-сим = ле.№-сим - 1
	ле.символ() // '*'
	пока истина {
		если ле.сим = КФ {
			ле.ошибка(нач-сим, "ЛЕК-НЕТ-*/")
			прервать
		}
		пусть сим = ле.сим
		ле.символ()
		если сим = '*' & ле.сим = '/' {
			ле.символ()
			прервать
		} иначе если сим = '/' & ле.сим = '*' {
			ле.блочный комментарий()
		}
	}
    ле.лек := КОММЕНТ-БЛОК
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт)  
}

//==== модификатор =====

фн (ле: Лексер) модификатор() {
	пусть нач-байт = ле.нач-байт - 1
    пусть нач-сим = ле.№-сим - 1    

	надо это буква?(ле.сим) 
    иначе {
		ле.ошибка(нач-сим, "ЛЕК-МОДИФИКАТОР")
		вернуть
	}

	пока это буква?(ле.сим) {
		ле.символ()
	}

    ле.лек := МОДИФИКАТОР
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт)  
}

//==== строки и символы =====

// изо - без кавычек
фн (ле: Лексер) строковый литерал(кавычка: Символ) {

    ле.лек := СТРОКА

	// первая кавычка уже взята
	пусть нач-байт = ле.нач-байт
    пусть нач-сим = ле.№-сим    

	пока истина {
		пусть сим = ле.сим
		если сим = '\n' | сим = КФ {
			ле.ошибка(нач-сим, "ЛЕК-СТРОКА-ЗАВЕРШЕНИЕ")
			прервать
		}
		ле.символ()
		если сим = кавычка {
			прервать
		}
		если сим < ' ' {
			ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", сим(:Байт))
		} иначе если сим = '\\' {
            ле.escape(кавычка)
		}
	}

	если нач-байт >= ле.нач-байт {
        // ошибка уже выдана
        ле.изо := "~"
		вернуть 
	}

    // без кавычек
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - 1 - нач-байт)  
}

фн (ле: Лексер) символьный литерал(кавычка: Символ) {

    ле.лек := СИМВОЛ

	// первая кавычка уже взята
	пусть нач-байт = ле.нач-байт
    пусть нач-сим = ле.№-сим   

	пусть нет-ошибок := истина
	пусть кол-во := 0

	пока истина {
		пусть сим = ле.сим
		если сим = '\n' | сим = КФ {
			если нет-ошибок {
				ле.ошибка(нач-сим, "ЛЕК-СТРОКА-ЗАВЕРШЕНИЕ")
				нет-ошибок := ложь
			}
			прервать
		}
		ле.символ()
		если сим = кавычка {
			прервать
		}
		кол-во++
		если сим < ' ' {
			ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", сим(:Байт))
			нет-ошибок := ложь
		} иначе если сим = '\\' {
			если ~ле.escape(кавычка) {
				нет-ошибок := ложь
			}
		}
	}

	если нет-ошибок & кол-во # 1 {
        ле.ошибка(нач-сим, "ЛЕК-ОШ-ДЛИНА-СИМВОЛА")
	}

	если ~нет-ошибок & нач-байт >= ле.нач-байт  {
        // ошибка уже выдана
        ле.изо := "~"
		вернуть
    }

    // без кавычек
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - 1 - нач-байт)  
}


// Сканирует escape-последовательность. Возвращает истину в случае лексической правильности
// Не проверяет корректность юникод символа
фн (ле: Лексер) escape(кавычка: Символ): Лог {

    пусть нач-сим = ле.№-сим  

	пусть № := 0
	выбор ле.сим {
	когда 'n', 'r', 't', '\'', '"', '\\':
		ле.символ()
		вернуть истина
	когда 'u': // \uABCD
		№ := 4
		ле.символ()
	другое
		если ле.сим = КФ {
			ле.ошибка(нач-сим, "ЛЕК-ESCAPE-ЗАВЕРШЕНИЕ")
		} иначе {
			ле.ошибка(нач-сим, "ЛЕК-ОШ-ESCAPE")
		}
		вернуть ложь
	}

	пока № > 0 {
		пусть знач =значение цифры(ле.сим)
		если знач >= 0x10 {
			если ле.сим = КФ {
				ле.ошибка(ле.№-сим, "ЛЕК-ESCAPE-ЗАВЕРШЕНИЕ")
			} иначе {
				ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", ле.сим)
				вернуть ложь
			}
		}
		ле.символ()
		№--
	}

	вернуть истина
}

фн значение цифры(сим: Символ): Слово64 {
	выбор {
	когда '0' <= сим & сим <= '9':
		вернуть сим(:Слово64) - '0'(:Слово64)
	когда 'a' <= сим & сим <= 'f':
		вернуть сим(:Слово64) - 'a'(:Слово64) + 0xA
	когда 'A' <= сим & сим <= 'F':
		вернуть сим(:Слово64) - 'A'(:Слово64) + 0xA
	}
	вернуть 0x10 // больше чем значение любой цифры
}

//==== числа =====

фн (ле: Лексер) число() {
	
    пусть нач-байт = ле.нач-байт
    пусть база := 10

	//-- целая часть
	если ле.сим = '0' {
		ле.символ()
		если ле.сим = 'x' {
			ле.символ()
			база := 16
		}
	}

    ле.цифры(база)

	если ле.сим # '.' {
        ле.лек := ЦЕЛ
        ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт)  
		вернуть
	}

	// дробная часть
	если база # 10 {
		ле.ошибка(ле.№-сим, "ЛЕК-ВЕЩ-БАЗА")
	}

	ле.символ()
    ле.цифры(10)

    ле.лек := ВЕЩ
    ле.изо := строки.извлечь из байтов(ле.байты, нач-байт, ле.нач-байт - нач-байт) 
}

фн (ле: Лексер) цифры(база: Цел64) {
	если база = 10 {
		пока это цифра?(ле.сим) {
			ле.символ()
		}
	} иначе если база = 16 {
		пока это цифра16?(ле.сим) {
			ле.символ()
		}
	} иначе {
		авария("Неверная база числа")
	}
}

//==== разбор лексем =====

фн (ле: Лексер) пропустить пробелы() {
    пока ле.сим = ' ' | ле.сим = '\t' {
        ле.символ()
    }
}

фн (ле: Лексер) проверить след(лек0: Лексема, след: Символ, лек1: Лексема): Лексема {
	если ле.сим = след {
		ле.символ()
		вернуть лек1
	}
	вернуть лек0
}

фн (ле: Лексер) лексема*() {
    ле.пропустить пробелы()

    ле.поз := ле.исходник.позиция(ле.№-сим)
    ле.изо := ""
    пусть сим = ле.сим
    
    если это буква?(сим) {
        ле.идентификатор()
        вернуть
    }
    если это цифра?(сим) {
        ле.число()
        вернуть
    }
   
    ле.символ() // всегда сдвигаюсь
    выбор сим {
    когда КФ: ле.лек := КОН-ФАЙЛ
    когда '\n':
		// пропускаем все концы строк
		пока ле.сим = '\n' {
				ле.символ()
		}
		ле.лек := КОН-СТР
	когда '"':
		ле.строковый литерал('"')
	когда '\'':
		ле.символьный литерал('\'')
	когда '@':
			ле.модификатор()
	когда ':':
        выбор ле.сим  {
		когда '=':
			ле.лек := ПРИСВОИТЬ
			ле.символ()
		когда '&':
			ле.лек := БИТ-И
			ле.символ()
		когда '|':
			ле.лек := БИТ-ИЛИ
			ле.символ()
		когда '\\':
			ле.лек := БИТ-ИСК-ИЛИ
			ле.символ()
		когда '~':
			ле.лек := БИТ-НЕ
			ле.символ()
		другое
			ле.лек := ДВОЕТОЧИЕ
		}
	когда '.':
		ле.лек := ТОЧКА
		если ле.сим = '.' & ле.посмотреть байт() = '.'(:Байт) {
				ле.символ()
				ле.символ() // взять третью  '.'
				ле.лек := ТРОЕТОЧИЕ
		}
    когда ',': 
        ле.лек := ЗАПЯТАЯ
    когда ';': 
        ле.лек := ТОЧКА-ЗАП
        ле.изо := ";"
	когда '(':
		ле.лек := ле.проверить след(КРУГ-Л, ':', КОНВЕРСИЯ)
	когда ')':
		ле.лек := КРУГ-П
	когда '[':
		ле.лек := КВАД-Л
	когда ']':
		ле.лек := КВАД-П
	когда '{':
		ле.лек := ФИГ-Л
	когда '}':
		ле.лек := ФИГ-П
	когда '+':
		ле.лек := ле.проверить след(СЛОЖИТЬ, '+', УВЕЛИЧИТЬ)
	когда '-':
		ле.лек := ле.проверить след(ВЫЧЕСТЬ, '-', УМЕНЬШИТЬ)
	когда '*':
		ле.лек := УМНОЖИТЬ
	когда '/':
		если ле.сим = '/' {
            ле.строчный комментарий()
		} иначе если ле.сим = '*' {
            ле.блочный комментарий()
		} иначе {
			ле.лек := ДЕЛИТЬ
		}
	когда '%':
		ле.лек := ОСТАТОК
	когда '^':
		ле.лек := НЕ-ПУСТО
	когда '<':
		выбор ле.сим {
		когда '=':
			ле.лек := МЕНЬШЕ-РАВНО
			ле.символ()
		когда '<':
			ле.лек := СДВИГ-Л
			ле.символ()
		другое
			ле.лек := МЕНЬШЕ
		}
	когда '>':
		выбор ле.сим {
		когда '=':
			ле.лек := БОЛЬШЕ-РАВНО
			ле.символ()
		когда '>':
			ле.лек := СДВИГ-П
			ле.символ()
		другое
			ле.лек := БОЛЬШЕ
		}
	когда '=':
		ле.лек := РАВНО
	когда '#':
		ле.лек := НЕ-РАВНО
	когда '~':
		ле.лек := НЕ
	когда '&':
		ле.лек := И
	когда '|':
		ле.лек := ИЛИ 
	другое
        ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", сим(:Строка))
		ле.лек := НЕОП
        ле.изо := сим(:Строка)
	}
}

