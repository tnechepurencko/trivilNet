модуль лексер

импорт "стд::вывод"
импорт "стд::юникод/utf8"
//импорт "стд::строки"

импорт "трик/основа"

тип Лексер = класс {
    лек* := НЕОП

    исходник: основа.Исходник = позже
    байты: основа.Байты = позже
    декодер: utf8.Декодер = позже
    
    сим: Символ := ' ' // текущий символ (unicode)
    нач-сим := 0  // начало лексемы
    №-байта := 0 // позиция чтения (байты)
    №-сим := 0  // номер символа
}

конст КФ = 0x7F(:Символ) // используется как конец файла

фн начать*(исходник: основа.Исходник): Лексер {
    пусть ле = Лексер{
        исходник: исходник,
        байты: исходник.байты,
        декодер: utf8.декодер(исходник.байты),
    }

	// пропустить BOM, если есть
    если длина(ле.байты) >= 3 &  ле.байты[0] = 0xEF(:Байт) & ле.байты[1] = 0xBB(:Байт) & ле.байты[2] = 0xBF(:Байт) {
        ле.№-байта := 3
    }
    
    исходник.начало строки(ле.№-сим)
    ле.символ()
    
    вернуть ле
}

фн (ле: Лексер) ошибка(№-сим: Цел64, код: Строка, аргументы: ...*) {
    основа.добавить ошибку(ле.исходник.позиция(№-сим), код, аргументы...)
}

// Извлекает следующий unicode символ
фн (ле: Лексер) символ() {
    надо ле.№-байта < длина(ле.байты) 
    иначе { 
        ле.нач-сим := длина(ле.байты)
        ле.исходник.начало строки(ле.№-сим)
        ле.сим := КФ
        вернуть
    }
    
    ле.нач-сим := ле.№-байта
    пусть сим := ле.байты[ле.№-байта](:Символ)
    пусть байтов := 1 // число байтов в символе
    
    выбор {
    когда сим = 0(:Символ):
        ле.ошибка(ле.№-сим, "ЛЕК-ОШ-СИМ", 0(:Символ))
        ле.№-сим++
    когда сим = '\n':
        ле.№-сим++
        ле.исходник.начало строки(ле.№-сим)        
    когда сим = '\r':
			сим := '\n'
            ле.№-сим++
            если ле.№-байта + 1 < длина(ле.байты) & ле.байты[ле.№-байта + 1](:Символ) = '\n' {
                ле.№-сим++
                байтов := 2
			}
            ле.исходник.начало строки(ле.№-сим)        
    когда сим >= 0x80(:Символ):
        ле.декодер.№ := ле.№-байта
        сим := ле.декодер.символ()
        байтов := ле.декодер.число-байтов
        ле.№-сим++
        если сим = utf8.Недоп-символ {
            ле.ошибка(ле.№-сим, "ЛЕК-UTF8")
        }
    другое // это 7-битный символ
        ле.№-сим++
    }

    ле.сим := сим
    ле.№-байта := ле.№-байта + байтов
}

// Read the next Unicode char into s.ch.
// s.ch < 0 means end-of-file.
/*

		case r >= utf8.RuneSelf:
			// not ASCII
			r, w = utf8.DecodeRune(s.src[s.rdOffset:])
			if r == utf8.RuneError && w == 1 {
				s.error(s.offset, "ЛЕК-UTF8")
			}
			s.uOffset++
		default:
			s.uOffset++ // ascii
		}
		s.rdOffset += w
		s.ch = r

}
*/



