модуль лексер

импорт "стд::вывод"
импорт "стд::строки"

импорт "трик/лексер/ключевые-слова"

тип Лексема* = Цел64

// Лексемы
конст * (

    НЕОП = 0  // неопределенная лексема
    
    КОН-ФАЙЛ  // конец файла
    КОН-СТР  // конец строки
    
    КОММЕНТ-СТРОКА
    КОММЕНТ-БЛОК
    МОДИФИКАТОР
    
    //--- литералы
    ИДЕНТ
    ЦЕЛ
    ВЕЩ
    СТРОКА
    СИМВОЛ
    МУЛЬТИ-СТРОКА // многострочная неинтерпретируемая строка (raw)

	//--- знаки операций и пунктуация
    СЛОЖИТЬ
    ВЫЧЕСТЬ
    УМНОЖИТЬ
    ДЕЛИТЬ
    ОСТАТОК
    
    И
    ИЛИ
    НЕ

    БИТ-И
    БИТ-ИЛИ
    БИТ-ИСК-ИЛИ
    БИТ-НЕ

    СДВИГ-Л
    СДВИГ-П

	РАВНО  // =
	МЕНЬШЕ // <
	БОЛЬШЕ // >
	НЕ-РАВНО // #
	МЕНЬШЕ-РАВНО // <=
	БОЛЬШЕ-РАВНО // >=

	НЕ-ПУСТО // ^

	ПРИСВОИТЬ  // :=
    УВЕЛИЧИТЬ // ++
    УМЕНЬШИТЬ // --

    КРУГ-Л
    КРУГ-П
    КВАД-Л
    КВАД-П
    ФИГ-Л
    ФИГ-П
    
    КОНВЕРСИЯ // (:
	ТРОЕТОЧИЕ // ...

	ЗАПЯТАЯ
    ТОЧКА
    ТОЧКА-ЗАП
    ДВОЕТОЧИЕ
    
    //--- ключевые слова
    ключевые-до
    АВАРИЯ
    ВЕРНУТЬ
    ВХОД
    ВЫБОР
    ДРУГОЕ
    ЕСЛИ
    ИНАЧЕ
    ИМПОРТ
    КЛАСС
    КОГДА
    КОНСТ
    МБ
    МОДУЛЬ
    НАДО
    ОСТОРОЖНО
    ПОКА
    ПРЕРВАТЬ
    ПУСТЬ
    ПОЗЖЕ
    СРЕДИ
    ТИП
    ТИПА
    ФН
    ЦИКЛ
    ключевые-после
    
    ЭКСПОРТ = УМНОЖИТЬ
)

тип Строки = []Строка

пусть названия = Строки[
    *: "",

    НЕОП: "ошибочная лексема",
    
	КОН-ФАЙЛ: "конец файла",
	КОН-СТР:  "конец строки",

    КОММЕНТ-СТРОКА: "строковый комментарий",
    КОММЕНТ-БЛОК: "блочный комментарий",
    МОДИФИКАТОР: "@",

	ИДЕНТ:  "идент",
	ЦЕЛ:   "цел литерал",
	ВЕЩ:  "вещ литерал",
	СТРОКА: "стр литерал",
	СИМВОЛ: "сим литерал",
    МУЛЬТИ-СТРОКА: "многострочный литерал",

    СЛОЖИТЬ: "+",
    ВЫЧЕСТЬ: "-",
    УМНОЖИТЬ: "*",
    ДЕЛИТЬ: "/",
    ОСТАТОК: "%",

    И: "&",
    ИЛИ: "|",
    НЕ: "~",

    БИТ-И: ":&",
    БИТ-ИЛИ: ":|",
    БИТ-ИСК-ИЛИ: ":\\",
    БИТ-НЕ: ":~",
 
    СДВИГ-Л: "<<",
    СДВИГ-П: ">>",

	РАВНО: "=",
	НЕ-РАВНО: "#",
	БОЛЬШЕ: ">",
    МЕНЬШЕ: "<",
	МЕНЬШЕ-РАВНО: "<=",
	БОЛЬШЕ-РАВНО: ">=",

	НЕ-ПУСТО: "^",

	ПРИСВОИТЬ: ":=",
    УВЕЛИЧИТЬ: "++",
    УМЕНЬШИТЬ: "--", 
 
    КРУГ-Л: "(",
    КРУГ-П: ")",
    КВАД-Л: "[",
    КВАД-П: "]",
    ФИГ-Л: "{",
    ФИГ-П: "}",
    
    КОНВЕРСИЯ: "(:",
	ТРОЕТОЧИЕ: "...",
 
 	ЗАПЯТАЯ: ",",
    ТОЧКА: ".",
    ТОЧКА-ЗАП: ";",
    ДВОЕТОЧИЕ: ":",

	АВАРИЯ: "авария",
    ВЕРНУТЬ: "вернуть",
    ВХОД: "вход",
    ВЫБОР: "выбор",
    ДРУГОЕ: "другое",
    ЕСЛИ: "если",
    ИНАЧЕ: "иначе",
    ИМПОРТ: "импорт",
    КЛАСС: "класс",
    КОГДА: "когда",
    КОНСТ: "конст",
    МБ: "мб",
    МОДУЛЬ: "модуль",
    НАДО: "надо",
    ОСТОРОЖНО: "осторожно",
    ПОКА: "пока",
    ПРЕРВАТЬ: "прервать",
    ПУСТЬ: "пусть",
    ПОЗЖЕ: "позже",
    СРЕДИ: "среди",
    ТИП: "тип",
    ТИПА: "типа",
    ФН: "фн",
    ЦИКЛ: "цикл",
]

пусть ключи = ключевые-слова.Словарь{}

фн для показа*(лексема: Лексема): Строка {
    пусть с := ""
    если лексема >= 0 & лексема < длина(названия) {
        с := названия[лексема]
    }
    
    если с = "" {
        с := строки.ф("лексема($;)", лексема)
    }
    вернуть с
}

// Если ключевое слово, возвращает его номер, если нет ИДЕНТ
фн проверить на ключевое(идент: Строка): Лексема {
    пусть эл? = ключи.найти(идент)
    
    надо эл? # пусто иначе вернуть ИДЕНТ

    вернуть эл?^.значение
}

вход {
    пусть № := ключевые-до + 1
    пока № < ключевые-после {
        ключи.добавить(названия[№], №)
        №++
    }

/* TODO: перенести в тесты
    вывод.ф("$;\n", для показа(ИДЕНТ))
    вывод.ф("$;\n", для показа(МОДУЛЬ))

    вывод.ф("модуль: $;\n", для показа(проверить на ключевое("модуль")))
    вывод.ф("осторожно: $;\n", для показа(проверить на ключевое("осторожно")))
    вывод.ф("иначе: $;\n", для показа(проверить на ключевое("иначе")))
    вывод.ф("ошибка: $;\n", для показа(проверить на ключевое("ошибка")))
*/   
}




