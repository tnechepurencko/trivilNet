package check

import (
	"fmt"
	"testing"
	"trivil/env"
	"trivil/parser"
	"trivil/semantics/lookup"
)

type one struct {
	text string
	id   string
}

var error_tests = []one{
	{"модуль x; тип А = класс (Цел64) {}", "СЕМ-БАЗА-НЕ-КЛАСС"},
	{"модуль x; тип А = класс { ц: Цел64; ц: Цел64}", "СЕМ-ДУБЛЬ-В-КЛАССЕ"},
	{"модуль x; тип А = класс { ц: Цел64}; фн (а: А) ц() {}", "СЕМ-ДУБЛЬ-В-КЛАССЕ"},
	{"модуль x; тип А = класс {}; тип Б = класс (А){}; фн (а: А) Ф() {}; фн (б: Б) Ф(): Цел64 {}", "СЕМ-РАЗНЫЕ-ТИПЫ-МЕТОДОВ"},
	{"модуль x; тип А = класс {}; тип Б = класс (А){}; фн (а: А) Ф() {}; фн (б: Б) Ф(х: Цел64) {}", "СЕМ-РАЗНЫЕ-ТИПЫ-МЕТОДОВ"},
	{"модуль x; тип А = класс {}; тип Б = класс (А){}; фн (а: А) Ф(х: Лог) {}; фн (б: Б) Ф(х: Цел64) {}", "СЕМ-РАЗНЫЕ-ТИПЫ-МЕТОДОВ"},

	{"модуль x; вход { если 1 {} }", "СЕМ-ТИП-ВЫРАЖЕНИЯ"},

	{"модуль x; вход { 1() }", "СЕМ-ВЫЗОВ-НЕ_ФУНКТИП"},

	{"модуль x; вход { пусть ц: Цел64 = ложь }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},
	{"модуль x; вход { пусть ц: Цел64 = 1; ц := ложь }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},

	{"модуль x; фн Ф() {}; вход { Ф(1) }", "СЕМ-ЧИСЛО-АРГУМЕНТОВ"},
	{"модуль x; фн Ф(ц: Цел64) {}; вход { Ф() }", "СЕМ-ЧИСЛО-АРГУМЕНТОВ"},
	{"модуль x; фн Ф(ц1: Цел64, ц2: Цел64) {}; вход { Ф(1) }", "СЕМ-ЧИСЛО-АРГУМЕНТОВ"},
	{"модуль x; фн Ф(ц: Цел64) {}; вход { Ф(ложь) }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},
	{"модуль x; фн Ф(л: Лог) {}; вход { Ф(1) }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},

	{"модуль x; вход { если ~ 1 {} }", "СЕМ-ОШ-УНАРНАЯ-ТИП"},
	{"модуль x; вход { пусть ц = ложь; ц++ }", "СЕМ-ОШ-УНАРНАЯ-ТИП"},
	{"модуль x; вход { пусть ц = ложь; ц-- }", "СЕМ-ОШ-УНАРНАЯ-ТИП"},

	{"модуль x; вход { ложь + ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь - ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь * ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь / ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь % ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},

	{"модуль x; вход { 1 & ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { 1 | ложь }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь & 1 }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},
	{"модуль x; вход { ложь | 1 }", "СЕМ-ОШ-ТИП-ОПЕРАНДА"},

	{"модуль x; вход { 1 + ложь }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 - ложь }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 * ложь }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 / ложь }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 % ложь }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},

	{"модуль x; вход { 1 + 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 - 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 * 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 / 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 % 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},

	{"модуль x; вход { 1 = 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 # 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 < 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 <= 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 > 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},
	{"модуль x; вход { 1 >= 1.0 }", "СЕМ-ОПЕРАНДЫ-НЕ-СОВМЕСТИМЫ"},

	{"модуль x; фн Ф() { вернуть 1 }", "СЕМ-ОШ-ВЕРНУТЬ-ЛИШНЕЕ"},
	{"модуль x; фн Ф(): Цел64 { вернуть }", "СЕМ-ОШ-ВЕРНУТЬ-НУЖНО"},
	{"модуль x; фн Ф(): Цел64 { вернуть ложь }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},

	{"модуль x; вход { пусть а = ложь[] }", "СЕМ-МАССИВ-КОМПОЗИТ-НЕТ-ТИПА"},
	{"модуль x; вход { пусть а = Лог[] }", "СЕМ-МАССИВ-КОМПОЗИТ-ОШ-ТИП"},
	{"модуль x; тип А = []Цел64; вход { пусть а = А[ложь: 1] }", "СЕМ-МАССИВ-КОМПОЗИТ-ТИП-КЛЮЧА"},
	{"модуль x; тип А = []Цел64; вход { пусть ц = 0; пусть а = А[ц: 1] }", "СЕМ-ОШ-КОНСТ-ВЫРАЖЕНИЕ"},
	{"модуль x; тип А = []Цел64; вход { пусть а = А[1: ложь] }", "СЕМ-НЕСОВМЕСТИМО-ПРИСВ"},

	{"модуль x; вход { пусть ц = 0; ц[1] }", "СЕМ-ОЖИДАЛСЯ-ТИП-МАССИВА"},
	{"модуль x; тип А = []Цел64; вход { пусть а = А[]; а[ложь] }", "СЕМ-ОШ-ТИП-ИНДЕКСА"},
}

//===

func TestErrors(t *testing.T) {
	fmt.Printf("--- tests for errors: %d ---\n", len(error_tests))
	t.Run("error tests", func(t *testing.T) {
		for _, e := range error_tests {
			checkForError(t, e.text, e.id)
		}
	})
}

func checkForError(t *testing.T, text, id string) {
	compile(text)
	if env.ErrorCount() == 0 {
		t.Errorf("An error is expected in text:\n%s\n", text)
		return
	}
	if id != "" {
		if env.GetErrorId(0) != id {
			t.Errorf("Expected '%s' error, got '%s' in text:\n%s\n", id, env.GetErrorId(0), text)
		}
	}
	env.ClearErrors()
}

func compile(text string) {
	var src = env.AddImmSource(text)

	m := parser.Parse(src)
	if env.ErrorCount() > 0 {
		return
	}
	lookup.Process(m)
	if env.ErrorCount() > 0 {
		return
	}
	Process(m)
}
